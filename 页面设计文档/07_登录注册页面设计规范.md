# 登录注册页面设计规范文档

## 1. 页面概述

### 1.1 页面职责
登录注册页面是用户进入AI Agent市场的第一道门户，负责：
- 新用户注册和账户创建
- 老用户登录和身份验证
- 第三方账户集成登录
- 密码重置和账户恢复
- 用户协议和隐私条款确认

### 1.2 目标用户
- **新用户**：首次接触平台的潜在用户
- **回流用户**：已注册但需要重新登录的用户
- **忘记密码用户**：需要重置密码的用户
- **第三方登录用户**：希望快速登录的用户

### 1.3 关键指标
- 注册转化率 > 25%
- 登录成功率 > 98%
- 页面加载时间 < 2秒
- 表单验证响应时间 < 500ms

## 2. 前端设计规范

### 2.1 页面结构

```tsx
// pages/auth/login.tsx
import { GetServerSideProps } from 'next';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { motion, AnimatePresence } from 'framer-motion';
import { LoginForm } from '@/components/auth/LoginForm';
import { RegisterForm } from '@/components/auth/RegisterForm';
import { ForgotPasswordForm } from '@/components/auth/ForgotPasswordForm';
import { SocialLoginButtons } from '@/components/auth/SocialLoginButtons';
import { AuthBackground } from '@/components/auth/AuthBackground';
import { useAuth } from '@/hooks/useAuth';

interface AuthPageProps {
  mode: 'login' | 'register' | 'reset';
  redirectUrl?: string;
  inviteCode?: string;
}

export default function AuthPage({ mode, redirectUrl, inviteCode }: AuthPageProps) {
  const { user, isLoading } = useAuth();
  const router = useRouter();
  const [authMode, setAuthMode] = useState<'login' | 'register' | 'reset'>(mode);
  const [isTransitioning, setIsTransitioning] = useState(false);

  // 如果用户已登录，重定向到目标页面
  useEffect(() => {
    if (user && !isLoading) {
      const targetUrl = redirectUrl || '/dashboard';
      router.push(targetUrl);
    }
  }, [user, isLoading, redirectUrl, router]);

  const handleModeSwitch = (newMode: typeof authMode) => {
    if (newMode === authMode) return;
    
    setIsTransitioning(true);
    setTimeout(() => {
      setAuthMode(newMode);
      setIsTransitioning(false);
    }, 200);
  };

  if (isLoading) {
    return <AuthLoadingScreen />;
  }

  return (
    <div className="min-h-screen flex">
      {/* 左侧背景装饰 */}
      <AuthBackground className="hidden lg:flex lg:w-1/2" />
      
      {/* 右侧登录表单区域 */}
      <div className="flex-1 flex items-center justify-center px-4 sm:px-6 lg:px-20 xl:px-24">
        <div className="w-full max-w-sm lg:w-96">
          {/* Logo和标题 */}
          <div className="text-center mb-8">
            <img
              className="mx-auto h-12 w-auto"
              src="/logo.svg"
              alt="AI Agent Market"
            />
            <h2 className="mt-6 text-3xl font-bold text-gray-900">
              {authMode === 'login' && '欢迎回来'}
              {authMode === 'register' && '加入AI Agent市场'}
              {authMode === 'reset' && '重置密码'}
            </h2>
            <p className="mt-2 text-sm text-gray-600">
              {authMode === 'login' && '登录您的账户继续创意之旅'}
              {authMode === 'register' && '开始您的AI创意变现之旅'}
              {authMode === 'reset' && '我们将发送重置链接到您的邮箱'}
            </p>
          </div>

          {/* 主要表单区域 */}
          <AnimatePresence mode="wait">
            <motion.div
              key={authMode}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.3 }}
              className={isTransitioning ? 'pointer-events-none' : ''}
            >
              {authMode === 'login' && (
                <LoginForm
                  onSuccess={() => router.push(redirectUrl || '/dashboard')}
                  onSwitchToRegister={() => handleModeSwitch('register')}
                  onForgotPassword={() => handleModeSwitch('reset')}
                />
              )}
              
              {authMode === 'register' && (
                <RegisterForm
                  inviteCode={inviteCode}
                  onSuccess={() => router.push('/onboarding')}
                  onSwitchToLogin={() => handleModeSwitch('login')}
                />
              )}
              
              {authMode === 'reset' && (
                <ForgotPasswordForm
                  onSuccess={() => handleModeSwitch('login')}
                  onBackToLogin={() => handleModeSwitch('login')}
                />
              )}
            </motion.div>
          </AnimatePresence>

          {/* 第三方登录 */}
          {authMode !== 'reset' && (
            <div className="mt-6">
              <div className="relative">
                <div className="absolute inset-0 flex items-center">
                  <div className="w-full border-t border-gray-300" />
                </div>
                <div className="relative flex justify-center text-sm">
                  <span className="px-2 bg-white text-gray-500">或</span>
                </div>
              </div>

              <SocialLoginButtons
                mode={authMode}
                onSuccess={() => router.push(redirectUrl || '/dashboard')}
                className="mt-6"
              />
            </div>
          )}

          {/* 底部链接 */}
          <div className="mt-8 text-center text-sm">
            <p className="text-gray-600">
              {authMode === 'login' && (
                <>
                  还没有账户？
                  <button
                    onClick={() => handleModeSwitch('register')}
                    className="font-medium text-blue-600 hover:text-blue-500 ml-1"
                  >
                    立即注册
                  </button>
                </>
              )}
              {authMode === 'register' && (
                <>
                  已有账户？
                  <button
                    onClick={() => handleModeSwitch('login')}
                    className="font-medium text-blue-600 hover:text-blue-500 ml-1"
                  >
                    立即登录
                  </button>
                </>
              )}
            </p>
            
            <div className="mt-4 flex justify-center space-x-4 text-xs text-gray-500">
              <a href="/privacy" className="hover:text-gray-700">隐私政策</a>
              <a href="/terms" className="hover:text-gray-700">服务条款</a>
              <a href="/help" className="hover:text-gray-700">帮助中心</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const { mode = 'login', redirect, invite } = context.query;
  
  return {
    props: {
      mode: ['login', 'register', 'reset'].includes(mode as string) 
        ? mode as string 
        : 'login',
      redirectUrl: redirect as string || null,
      inviteCode: invite as string || null
    }
  };
};
```

### 2.2 核心组件设计

#### 2.2.1 登录表单组件

```tsx
// components/auth/LoginForm.tsx
import { useState, useRef } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline';
import { FormField } from '@/components/ui/FormField';
import { Button } from '@/components/ui/Button';
import { useAuth } from '@/hooks/useAuth';
import { toast } from '@/hooks/useToast';

const loginSchema = z.object({
  email: z
    .string()
    .min(1, '请输入邮箱地址')
    .email('请输入有效的邮箱地址'),
  password: z
    .string()
    .min(1, '请输入密码')
    .min(6, '密码至少需要6位字符'),
  rememberMe: z.boolean().default(false)
});

type LoginFormData = z.infer<typeof loginSchema>;

interface LoginFormProps {
  onSuccess: () => void;
  onSwitchToRegister: () => void;
  onForgotPassword: () => void;
}

export const LoginForm: React.FC<LoginFormProps> = ({
  onSuccess,
  onSwitchToRegister,
  onForgotPassword
}) => {
  const [showPassword, setShowPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const { login } = useAuth();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
    clearErrors
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema)
  });

  const onSubmit = async (data: LoginFormData) => {
    setIsLoading(true);
    clearErrors();

    try {
      const result = await login({
        email: data.email,
        password: data.password,
        rememberMe: data.rememberMe
      });

      if (result.success) {
        toast.success('登录成功！');
        onSuccess();
      } else {
        // 处理登录错误
        if (result.error?.field) {
          setError(result.error.field as keyof LoginFormData, {
            message: result.error.message
          });
        } else {
          toast.error(result.error?.message || '登录失败，请重试');
        }
      }
    } catch (error) {
      toast.error('网络错误，请检查连接后重试');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* 邮箱输入 */}
      <FormField
        label="邮箱地址"
        error={errors.email?.message}
        required
      >
        <input
          {...register('email')}
          type="email"
          autoComplete="email"
          className="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
          placeholder="请输入邮箱地址"
        />
      </FormField>

      {/* 密码输入 */}
      <FormField
        label="密码"
        error={errors.password?.message}
        required
      >
        <div className="relative">
          <input
            {...register('password')}
            type={showPassword ? 'text' : 'password'}
            autoComplete="current-password"
            className="appearance-none relative block w-full px-3 py-2 pr-10 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
            placeholder="请输入密码"
          />
          <button
            type="button"
            className="absolute inset-y-0 right-0 pr-3 flex items-center"
            onClick={() => setShowPassword(!showPassword)}
          >
            {showPassword ? (
              <EyeSlashIcon className="h-5 w-5 text-gray-400" />
            ) : (
              <EyeIcon className="h-5 w-5 text-gray-400" />
            )}
          </button>
        </div>
      </FormField>

      {/* 记住我和忘记密码 */}
      <div className="flex items-center justify-between">
        <div className="flex items-center">
          <input
            {...register('rememberMe')}
            id="remember-me"
            type="checkbox"
            className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
          />
          <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
            记住我
          </label>
        </div>

        <button
          type="button"
          onClick={onForgotPassword}
          className="text-sm text-blue-600 hover:text-blue-500"
        >
          忘记密码？
        </button>
      </div>

      {/* 登录按钮 */}
      <Button
        type="submit"
        loading={isLoading}
        className="w-full py-3"
        size="lg"
      >
        登录
      </Button>
    </form>
  );
};
```

#### 2.2.2 注册表单组件

```tsx
// components/auth/RegisterForm.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { EyeIcon, EyeSlashIcon } from '@heroicons/react/24/outline';
import { FormField } from '@/components/ui/FormField';
import { Button } from '@/components/ui/Button';
import { PasswordStrengthMeter } from '@/components/ui/PasswordStrengthMeter';
import { useAuth } from '@/hooks/useAuth';
import { toast } from '@/hooks/useToast';

const registerSchema = z.object({
  username: z
    .string()
    .min(1, '请输入用户名')
    .min(3, '用户名至少需要3位字符')
    .max(20, '用户名不能超过20位字符')
    .regex(/^[a-zA-Z0-9_\u4e00-\u9fa5]+$/, '用户名只能包含字母、数字、下划线和中文'),
  email: z
    .string()
    .min(1, '请输入邮箱地址')
    .email('请输入有效的邮箱地址'),
  password: z
    .string()
    .min(1, '请输入密码')
    .min(8, '密码至少需要8位字符')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, '密码必须包含大小写字母和数字'),
  confirmPassword: z
    .string()
    .min(1, '请确认密码'),
  agreeToTerms: z
    .boolean()
    .refine(val => val === true, '请同意服务条款和隐私政策'),
  inviteCode: z.string().optional()
}).refine((data) => data.password === data.confirmPassword, {
  message: '两次输入的密码不一致',
  path: ['confirmPassword']
});

type RegisterFormData = z.infer<typeof registerSchema>;

interface RegisterFormProps {
  inviteCode?: string;
  onSuccess: () => void;
  onSwitchToLogin: () => void;
}

export const RegisterForm: React.FC<RegisterFormProps> = ({
  inviteCode,
  onSuccess,
  onSwitchToLogin
}) => {
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const { register: registerUser } = useAuth();
  
  const {
    register,
    handleSubmit,
    watch,
    formState: { errors },
    setError,
    clearErrors
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      inviteCode: inviteCode || ''
    }
  });

  const password = watch('password');

  const onSubmit = async (data: RegisterFormData) => {
    setIsLoading(true);
    clearErrors();

    try {
      const result = await registerUser({
        username: data.username,
        email: data.email,
        password: data.password,
        confirmPassword: data.confirmPassword,
        inviteCode: data.inviteCode,
        agreeToTerms: data.agreeToTerms
      });

      if (result.success) {
        toast.success('注册成功！请查收邮箱验证邮件');
        onSuccess();
      } else {
        // 处理注册错误
        if (result.error?.field) {
          setError(result.error.field as keyof RegisterFormData, {
            message: result.error.message
          });
        } else {
          toast.error(result.error?.message || '注册失败，请重试');
        }
      }
    } catch (error) {
      toast.error('网络错误，请检查连接后重试');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* 用户名输入 */}
      <FormField
        label="用户名"
        error={errors.username?.message}
        required
      >
        <input
          {...register('username')}
          type="text"
          autoComplete="username"
          className="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
          placeholder="请输入用户名"
        />
      </FormField>

      {/* 邮箱输入 */}
      <FormField
        label="邮箱地址"
        error={errors.email?.message}
        required
      >
        <input
          {...register('email')}
          type="email"
          autoComplete="email"
          className="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
          placeholder="请输入邮箱地址"
        />
      </FormField>

      {/* 密码输入 */}
      <FormField
        label="密码"
        error={errors.password?.message}
        required
      >
        <div className="relative">
          <input
            {...register('password')}
            type={showPassword ? 'text' : 'password'}
            autoComplete="new-password"
            className="appearance-none relative block w-full px-3 py-2 pr-10 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
            placeholder="请输入密码"
          />
          <button
            type="button"
            className="absolute inset-y-0 right-0 pr-3 flex items-center"
            onClick={() => setShowPassword(!showPassword)}
          >
            {showPassword ? (
              <EyeSlashIcon className="h-5 w-5 text-gray-400" />
            ) : (
              <EyeIcon className="h-5 w-5 text-gray-400" />
            )}
          </button>
        </div>
        {password && <PasswordStrengthMeter password={password} />}
      </FormField>

      {/* 确认密码输入 */}
      <FormField
        label="确认密码"
        error={errors.confirmPassword?.message}
        required
      >
        <div className="relative">
          <input
            {...register('confirmPassword')}
            type={showConfirmPassword ? 'text' : 'password'}
            autoComplete="new-password"
            className="appearance-none relative block w-full px-3 py-2 pr-10 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
            placeholder="请再次输入密码"
          />
          <button
            type="button"
            className="absolute inset-y-0 right-0 pr-3 flex items-center"
            onClick={() => setShowConfirmPassword(!showConfirmPassword)}
          >
            {showConfirmPassword ? (
              <EyeSlashIcon className="h-5 w-5 text-gray-400" />
            ) : (
              <EyeIcon className="h-5 w-5 text-gray-400" />
            )}
          </button>
        </div>
      </FormField>

      {/* 邀请码（可选） */}
      {!inviteCode && (
        <FormField
          label="邀请码（可选）"
          error={errors.inviteCode?.message}
        >
          <input
            {...register('inviteCode')}
            type="text"
            className="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
            placeholder="如有邀请码，请输入"
          />
        </FormField>
      )}

      {/* 服务条款同意 */}
      <div className="flex items-start">
        <input
          {...register('agreeToTerms')}
          id="agree-terms"
          type="checkbox"
          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mt-1"
        />
        <label htmlFor="agree-terms" className="ml-2 block text-sm text-gray-900">
          我已阅读并同意
          <a href="/terms" className="text-blue-600 hover:text-blue-500 mx-1">
            服务条款
          </a>
          和
          <a href="/privacy" className="text-blue-600 hover:text-blue-500 mx-1">
            隐私政策
          </a>
        </label>
      </div>
      {errors.agreeToTerms && (
        <p className="mt-1 text-sm text-red-600">{errors.agreeToTerms.message}</p>
      )}

      {/* 注册按钮 */}
      <Button
        type="submit"
        loading={isLoading}
        className="w-full py-3"
        size="lg"
      >
        创建账户
      </Button>
    </form>
  );
};
```

#### 2.2.3 第三方登录组件

```tsx
// components/auth/SocialLoginButtons.tsx
import { useState } from 'react';
import { Button } from '@/components/ui/Button';
import { useAuth } from '@/hooks/useAuth';
import { toast } from '@/hooks/useToast';

interface SocialLoginButtonsProps {
  mode: 'login' | 'register';
  onSuccess: () => void;
  className?: string;
}

export const SocialLoginButtons: React.FC<SocialLoginButtonsProps> = ({
  mode,
  onSuccess,
  className = ''
}) => {
  const [loadingProvider, setLoadingProvider] = useState<string | null>(null);
  const { socialLogin } = useAuth();

  const handleSocialLogin = async (provider: 'wechat' | 'github' | 'google') => {
    setLoadingProvider(provider);

    try {
      const result = await socialLogin(provider);
      
      if (result.success) {
        toast.success(`${getProviderName(provider)}${mode === 'login' ? '登录' : '注册'}成功！`);
        onSuccess();
      } else {
        toast.error(result.error?.message || `${getProviderName(provider)}${mode === 'login' ? '登录' : '注册'}失败`);
      }
    } catch (error) {
      toast.error('网络错误，请重试');
    } finally {
      setLoadingProvider(null);
    }
  };

  const getProviderName = (provider: string) => {
    const names = {
      wechat: '微信',
      github: 'GitHub',
      google: 'Google'
    };
    return names[provider] || provider;
  };

  const providers = [
    {
      id: 'wechat',
      name: '微信',
      icon: '/icons/wechat.svg',
      bgColor: 'bg-green-500 hover:bg-green-600',
      textColor: 'text-white'
    },
    {
      id: 'github', 
      name: 'GitHub',
      icon: '/icons/github.svg',
      bgColor: 'bg-gray-900 hover:bg-gray-800',
      textColor: 'text-white'
    },
    {
      id: 'google',
      name: 'Google',
      icon: '/icons/google.svg',
      bgColor: 'bg-white hover:bg-gray-50 border border-gray-300',
      textColor: 'text-gray-900'
    }
  ];

  return (
    <div className={className}>
      <div className="grid grid-cols-1 gap-3">
        {providers.map((provider) => (
          <button
            key={provider.id}
            onClick={() => handleSocialLogin(provider.id as any)}
            disabled={loadingProvider !== null}
            className={`
              w-full inline-flex justify-center items-center px-4 py-2 
              ${provider.bgColor} ${provider.textColor}
              font-medium rounded-lg shadow-sm
              disabled:opacity-50 disabled:cursor-not-allowed
              transition-colors duration-200
            `}
          >
            {loadingProvider === provider.id ? (
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5" fill="none" viewBox="0 0 24 24">
                <circle 
                  className="opacity-25" 
                  cx="12" 
                  cy="12" 
                  r="10" 
                  stroke="currentColor" 
                  strokeWidth="4"
                />
                <path 
                  className="opacity-75" 
                  fill="currentColor" 
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                />
              </svg>
            ) : (
              <img
                src={provider.icon}
                alt={provider.name}
                className="w-5 h-5 mr-3"
              />
            )}
            使用 {provider.name} {mode === 'login' ? '登录' : '注册'}
          </button>
        ))}
      </div>
    </div>
  );
};
```

#### 2.2.4 背景装饰组件

```tsx
// components/auth/AuthBackground.tsx
import { motion } from 'framer-motion';

interface AuthBackgroundProps {
  className?: string;
}

export const AuthBackground: React.FC<AuthBackgroundProps> = ({ className = '' }) => {
  return (
    <div className={`relative ${className} bg-gradient-to-br from-blue-600 via-purple-600 to-pink-600`}>
      {/* 背景装饰图案 */}
      <div className="absolute inset-0 opacity-10">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <pattern id="circuit" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
              <path d="M10 10h80v80h-80z" fill="none" stroke="white" strokeWidth="1"/>
              <circle cx="10" cy="10" r="2" fill="white"/>
              <circle cx="90" cy="10" r="2" fill="white"/>
              <circle cx="90" cy="90" r="2" fill="white"/>
              <circle cx="10" cy="90" r="2" fill="white"/>
              <path d="M30 10v20h30v-20" fill="none" stroke="white" strokeWidth="1"/>
              <path d="M70 70v20h20v-20" fill="none" stroke="white" strokeWidth="1"/>
            </pattern>
          </defs>
          <rect width="100%" height="100%" fill="url(#circuit)"/>
        </svg>
      </div>

      {/* 浮动的Agent头像 */}
      <div className="absolute inset-0 overflow-hidden">
        {[
          { x: '20%', y: '20%', delay: 0, agent: 'wang' },
          { x: '80%', y: '30%', delay: 0.2, agent: 'lin' },
          { x: '30%', y: '60%', delay: 0.4, agent: 'alex' },
          { x: '70%', y: '70%', delay: 0.6, agent: 'allen' },
          { x: '50%', y: '80%', delay: 0.8, agent: 'li' }
        ].map((item, index) => (
          <motion.div
            key={index}
            className="absolute w-16 h-16 rounded-full opacity-20"
            style={{ left: item.x, top: item.y }}
            initial={{ scale: 0, rotate: 0 }}
            animate={{ 
              scale: [1, 1.2, 1],
              rotate: [0, 180, 360]
            }}
            transition={{
              duration: 10,
              delay: item.delay,
              repeat: Infinity,
              ease: 'linear'
            }}
          >
            <img
              src={`/avatars/${item.agent}.webp`}
              alt={`Agent ${item.agent}`}
              className="w-full h-full rounded-full"
            />
          </motion.div>
        ))}
      </div>

      {/* 主要内容 */}
      <div className="relative z-10 flex flex-col justify-center items-center h-full p-12 text-white text-center">
        <motion.div
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
        >
          <h1 className="text-4xl font-bold mb-6">
            欢迎来到AI Agent市场
          </h1>
          <p className="text-xl mb-8 max-w-md">
            与5位个性鲜明的AI专家合作，让你的创意想法变成有价值的产品
          </p>
          
          <div className="grid grid-cols-2 gap-4 max-w-sm">
            <div className="bg-white/10 rounded-lg p-4 backdrop-blur-sm">
              <div className="text-2xl font-bold">1,234+</div>
              <div className="text-sm opacity-80">创意已升级</div>
            </div>
            <div className="bg-white/10 rounded-lg p-4 backdrop-blur-sm">
              <div className="text-2xl font-bold">5,678+</div>
              <div className="text-sm opacity-80">用户信任</div>
            </div>
          </div>
        </motion.div>
      </div>
    </div>
  );
};
```

### 2.3 数据类型定义

```typescript
// types/auth.ts
export interface LoginRequest {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface LoginResponse {
  success: boolean;
  data?: {
    user: {
      id: string;
      username: string;
      email: string;
      avatar: string;
      level: number;
      verifiedStatus: boolean;
    };
    tokens: {
      accessToken: string;
      refreshToken: string;
      expiresIn: number;
    };
  };
  error?: {
    code: string;
    message: string;
    field?: string;
  };
}

export interface RegisterRequest {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  inviteCode?: string;
  agreeToTerms: boolean;
}

export interface RegisterResponse {
  success: boolean;
  data?: {
    userId: string;
    username: string;
    email: string;
    verificationEmailSent: boolean;
  };
  error?: {
    code: string;
    message: string;
    field?: string;
  };
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success: boolean;
  data?: {
    message: string;
  };
  error?: {
    code: string;
    message: string;
  };
}

export interface SocialLoginProvider {
  id: 'wechat' | 'github' | 'google';
  name: string;
  icon: string;
  redirectUrl: string;
}

export interface User {
  id: string;
  username: string;
  email: string;
  avatar: string;
  bio: string;
  level: {
    name: string;
    level: number;
    progress: number;
  };
  verifiedStatus: boolean;
  createdAt: string;
  preferences: UserPreferences;
}

export interface UserPreferences {
  notifications: {
    email: boolean;
    push: boolean;
    marketing: boolean;
  };
  language: string;
  theme: 'light' | 'dark' | 'auto';
}
```

## 3. 后端API规范

### 3.1 认证相关API

#### 3.1.1 用户登录

```typescript
// POST /api/auth/login
export interface LoginEndpoint {
  method: 'POST';
  path: '/api/auth/login';
  requestBody: LoginRequest;
  responseBody: LoginResponse;
}

export async function POST(request: Request) {
  try {
    const body: LoginRequest = await request.json();
    
    // 数据验证
    const validation = validateLoginData(body);
    if (!validation.valid) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: validation.message,
          field: validation.field
        }
      }, { status: 400 });
    }

    // 查找用户
    const user = await prisma.user.findUnique({
      where: { email: body.email },
      include: {
        level: true,
        preferences: true
      }
    });

    if (!user) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'USER_NOT_FOUND',
          message: '邮箱或密码错误',
          field: 'email'
        }
      }, { status: 400 });
    }

    // 验证密码
    const validPassword = await bcrypt.compare(body.password, user.password);
    if (!validPassword) {
      // 记录失败尝试
      await prisma.loginAttempt.create({
        data: {
          email: body.email,
          success: false,
          ipAddress: getClientIP(request),
          userAgent: request.headers.get('user-agent')
        }
      });

      return NextResponse.json({
        success: false,
        error: {
          code: 'INVALID_CREDENTIALS',
          message: '邮箱或密码错误',
          field: 'password'
        }
      }, { status: 400 });
    }

    // 检查账户状态
    if (user.status === 'suspended') {
      return NextResponse.json({
        success: false,
        error: {
          code: 'ACCOUNT_SUSPENDED',
          message: '账户已被暂停，请联系客服'
        }
      }, { status: 403 });
    }

    // 生成JWT tokens
    const tokens = await generateAuthTokens(user.id, body.rememberMe);

    // 更新最后登录时间
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLoginAt: new Date() }
    });

    // 记录成功登录
    await prisma.loginAttempt.create({
      data: {
        userId: user.id,
        email: body.email,
        success: true,
        ipAddress: getClientIP(request),
        userAgent: request.headers.get('user-agent')
      }
    });

    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          avatar: user.avatar,
          level: user.level?.level || 1,
          verifiedStatus: user.emailVerified
        },
        tokens
      }
    });

  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: '登录服务暂时不可用，请稍后重试'
      }
    }, { status: 500 });
  }
}
```

#### 3.1.2 用户注册

```typescript
// POST /api/auth/register
export async function POST(request: Request) {
  try {
    const body: RegisterRequest = await request.json();
    
    // 数据验证
    const validation = validateRegistrationData(body);
    if (!validation.valid) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: validation.message,
          field: validation.field
        }
      }, { status: 400 });
    }

    // 检查邮箱是否已存在
    const existingUserByEmail = await prisma.user.findUnique({
      where: { email: body.email }
    });

    if (existingUserByEmail) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'EMAIL_EXISTS',
          message: '此邮箱已被注册',
          field: 'email'
        }
      }, { status: 400 });
    }

    // 检查用户名是否已存在
    const existingUserByUsername = await prisma.user.findUnique({
      where: { username: body.username }
    });

    if (existingUserByUsername) {
      return NextResponse.json({
        success: false,
        error: {
          code: 'USERNAME_EXISTS',
          message: '此用户名已被使用',
          field: 'username'
        }
      }, { status: 400 });
    }

    // 验证邀请码（如果提供）
    let inviteBonus = 0;
    if (body.inviteCode) {
      const invite = await prisma.invitation.findUnique({
        where: { code: body.inviteCode, isActive: true }
      });

      if (!invite) {
        return NextResponse.json({
          success: false,
          error: {
            code: 'INVALID_INVITE_CODE',
            message: '邀请码无效或已过期',
            field: 'inviteCode'
          }
        }, { status: 400 });
      }

      inviteBonus = invite.bonusPoints;
    }

    // 开始数据库事务
    const result = await prisma.$transaction(async (tx) => {
      // 加密密码
      const hashedPassword = await bcrypt.hash(body.password, 12);

      // 创建用户
      const user = await tx.user.create({
        data: {
          username: body.username,
          email: body.email,
          password: hashedPassword,
          avatar: generateDefaultAvatar(body.username),
          status: 'active'
        }
      });

      // 创建用户钱包
      await tx.userWallet.create({
        data: {
          userId: user.id,
          balance: 100 + inviteBonus, // 注册奖励 + 邀请奖励
        }
      });

      // 创建用户偏好设置
      await tx.userPreferences.create({
        data: {
          userId: user.id,
          language: 'zh-CN',
          theme: 'light',
          notifications: {
            email: true,
            push: true,
            marketing: false
          }
        }
      });

      // 处理邀请码奖励
      if (body.inviteCode) {
        await tx.invitation.update({
          where: { code: body.inviteCode },
          data: { 
            usedBy: user.id,
            usedAt: new Date(),
            isActive: false
          }
        });

        // 给邀请人奖励
        const inviter = await tx.user.findUnique({
          where: { id: invite.inviterId }
        });

        if (inviter) {
          await tx.userWallet.update({
            where: { userId: invite.inviterId },
            data: { balance: { increment: 50 } }
          });
        }
      }

      // 生成邮箱验证token
      const verificationToken = generateVerificationToken();
      await tx.emailVerification.create({
        data: {
          userId: user.id,
          token: verificationToken,
          expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24小时后过期
        }
      });

      // 发送验证邮件
      await sendVerificationEmail(user.email, user.username, verificationToken);

      return {
        userId: user.id,
        username: user.username,
        email: user.email,
        verificationEmailSent: true
      };
    });

    return NextResponse.json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: '注册服务暂时不可用，请稍后重试'
      }
    }, { status: 500 });
  }
}
```

#### 3.1.3 第三方登录

```typescript
// GET /api/auth/social/{provider}
export async function GET(
  request: Request,
  { params }: { params: { provider: string } }
) {
  try {
    const { provider } = params;
    const { searchParams } = new URL(request.url);
    const redirectUrl = searchParams.get('redirect') || '/dashboard';

    if (!['wechat', 'github', 'google'].includes(provider)) {
      return NextResponse.json({
        success: false,
        error: { message: '不支持的登录方式' }
      }, { status: 400 });
    }

    // 生成state参数用于防CSRF攻击
    const state = generateRandomString(32);
    await redis.setex(`auth_state:${state}`, 600, JSON.stringify({ 
      provider, 
      redirectUrl 
    }));

    // 获取第三方登录URL
    const authUrl = getSocialAuthUrl(provider, state);

    return NextResponse.json({
      success: true,
      data: { authUrl }
    });

  } catch (error) {
    return NextResponse.json({
      success: false,
      error: { message: '获取登录链接失败' }
    }, { status: 500 });
  }
}

// GET /api/auth/social/{provider}/callback
export async function GET(
  request: Request,
  { params }: { params: { provider: string } }
) {
  try {
    const { provider } = params;
    const { searchParams } = new URL(request.url);
    const code = searchParams.get('code');
    const state = searchParams.get('state');

    // 验证state参数
    if (!state) {
      throw new Error('Missing state parameter');
    }

    const stateData = await redis.get(`auth_state:${state}`);
    if (!stateData) {
      throw new Error('Invalid or expired state');
    }

    const { redirectUrl } = JSON.parse(stateData);
    await redis.del(`auth_state:${state}`);

    // 获取第三方用户信息
    const socialUser = await getSocialUserInfo(provider, code);
    
    // 查找或创建用户
    let user = await prisma.user.findFirst({
      where: {
        OR: [
          { email: socialUser.email },
          { 
            socialAccounts: {
              some: {
                provider,
                providerId: socialUser.id
              }
            }
          }
        ]
      },
      include: { level: true }
    });

    if (!user) {
      // 创建新用户
      user = await prisma.$transaction(async (tx) => {
        const newUser = await tx.user.create({
          data: {
            username: socialUser.username || generateUsername(),
            email: socialUser.email,
            avatar: socialUser.avatar || generateDefaultAvatar(),
            emailVerified: true, // 第三方登录默认邮箱已验证
            status: 'active'
          }
        });

        // 创建社交账户关联
        await tx.socialAccount.create({
          data: {
            userId: newUser.id,
            provider,
            providerId: socialUser.id,
            profileData: socialUser
          }
        });

        // 创建钱包和偏好设置
        await tx.userWallet.create({
          data: {
            userId: newUser.id,
            balance: 100 // 注册奖励
          }
        });

        await tx.userPreferences.create({
          data: {
            userId: newUser.id,
            language: 'zh-CN',
            theme: 'light'
          }
        });

        return newUser;
      });
    } else {
      // 更新社交账户信息
      await prisma.socialAccount.upsert({
        where: {
          userId_provider: {
            userId: user.id,
            provider
          }
        },
        create: {
          userId: user.id,
          provider,
          providerId: socialUser.id,
          profileData: socialUser
        },
        update: {
          profileData: socialUser
        }
      });
    }

    // 生成JWT tokens
    const tokens = await generateAuthTokens(user.id);

    // 更新最后登录时间
    await prisma.user.update({
      where: { id: user.id },
      data: { lastLoginAt: new Date() }
    });

    // 重定向到前端，带上token
    return NextResponse.redirect(
      `${process.env.FRONTEND_URL}/auth/callback?token=${tokens.accessToken}&redirect=${encodeURIComponent(redirectUrl)}`
    );

  } catch (error) {
    console.error('Social login error:', error);
    return NextResponse.redirect(
      `${process.env.FRONTEND_URL}/auth/error?message=${encodeURIComponent('登录失败')}`
    );
  }
}
```

## 4. 数据库设计

### 4.1 用户相关表结构

```sql
-- 用户表
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255), -- 第三方登录用户可能为空
  avatar VARCHAR(500),
  bio TEXT,
  status VARCHAR(20) DEFAULT 'active', -- active, suspended, deleted
  email_verified BOOLEAN DEFAULT FALSE,
  last_login_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 社交账户关联表
CREATE TABLE social_accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  provider VARCHAR(20) NOT NULL, -- wechat, github, google
  provider_id VARCHAR(255) NOT NULL,
  profile_data JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(user_id, provider)
);

-- 用户偏好设置表
CREATE TABLE user_preferences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  language VARCHAR(10) DEFAULT 'zh-CN',
  theme VARCHAR(10) DEFAULT 'light', -- light, dark, auto
  notifications JSONB DEFAULT '{"email": true, "push": true, "marketing": false}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 邮箱验证表
CREATE TABLE email_verifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 密码重置表
CREATE TABLE password_resets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) NOT NULL,
  token VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 登录尝试记录表
CREATE TABLE login_attempts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  email VARCHAR(255),
  success BOOLEAN NOT NULL,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 邀请码表
CREATE TABLE invitations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  code VARCHAR(50) UNIQUE NOT NULL,
  inviter_id UUID REFERENCES users(id) ON DELETE CASCADE,
  used_by UUID REFERENCES users(id) ON DELETE SET NULL,
  bonus_points INTEGER DEFAULT 50,
  is_active BOOLEAN DEFAULT TRUE,
  expires_at TIMESTAMP,
  used_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

-- 用户钱包表
CREATE TABLE user_wallets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  balance DECIMAL(10,2) DEFAULT 0.00,
  frozen_balance DECIMAL(10,2) DEFAULT 0.00,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_social_accounts_provider ON social_accounts(provider, provider_id);
CREATE INDEX idx_email_verifications_token ON email_verifications(token);
CREATE INDEX idx_password_resets_token ON password_resets(token);
CREATE INDEX idx_login_attempts_email ON login_attempts(email, created_at);
CREATE INDEX idx_invitations_code ON invitations(code);
```

## 5. 安全机制

### 5.1 密码安全

```typescript
// utils/security.ts
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

export const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12;
  return bcrypt.hash(password, saltRounds);
};

export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

export const generateSecureToken = (length: number = 32): string => {
  return crypto.randomBytes(length).toString('hex');
};

export const isPasswordStrong = (password: string): boolean => {
  // 至少8位，包含大小写字母、数字
  const strongRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  return strongRegex.test(password);
};
```

### 5.2 JWT Token管理

```typescript
// utils/jwt.ts
import jwt from 'jsonwebtoken';

interface TokenPayload {
  userId: string;
  email: string;
  type: 'access' | 'refresh';
}

export const generateAccessToken = (userId: string, email: string): string => {
  return jwt.sign(
    { userId, email, type: 'access' },
    process.env.JWT_ACCESS_SECRET!,
    { expiresIn: '15m' }
  );
};

export const generateRefreshToken = (userId: string, email: string): string => {
  return jwt.sign(
    { userId, email, type: 'refresh' },
    process.env.JWT_REFRESH_SECRET!,
    { expiresIn: '7d' }
  );
};

export const verifyToken = (token: string, type: 'access' | 'refresh'): TokenPayload => {
  const secret = type === 'access' 
    ? process.env.JWT_ACCESS_SECRET!
    : process.env.JWT_REFRESH_SECRET!;
    
  return jwt.verify(token, secret) as TokenPayload;
};
```

### 5.3 速率限制

```typescript
// middleware/rateLimit.ts
import { NextRequest, NextResponse } from 'next/server';
import { redis } from '@/lib/redis';

interface RateLimitConfig {
  windowMs: number;  // 时间窗口（毫秒）
  max: number;       // 最大请求数
  message?: string;
}

export const createRateLimit = (config: RateLimitConfig) => {
  return async (req: NextRequest) => {
    const ip = getClientIP(req);
    const key = `ratelimit:${ip}:${req.nextUrl.pathname}`;
    
    const current = await redis.incr(key);
    
    if (current === 1) {
      await redis.expire(key, Math.floor(config.windowMs / 1000));
    }
    
    if (current > config.max) {
      return NextResponse.json(
        {
          success: false,
          error: {
            code: 'RATE_LIMIT_EXCEEDED',
            message: config.message || '请求过于频繁，请稍后重试'
          }
        },
        { 
          status: 429,
          headers: {
            'X-RateLimit-Limit': config.max.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': new Date(Date.now() + config.windowMs).toISOString()
          }
        }
      );
    }
    
    return NextResponse.next({
      headers: {
        'X-RateLimit-Limit': config.max.toString(),
        'X-RateLimit-Remaining': (config.max - current).toString()
      }
    });
  };
};

// 登录页面速率限制
export const loginRateLimit = createRateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 5, // 最多5次登录尝试
  message: '登录尝试次数过多，请15分钟后再试'
});

// 注册页面速率限制
export const registerRateLimit = createRateLimit({
  windowMs: 60 * 60 * 1000, // 1小时
  max: 3, // 最多3次注册
  message: '注册次数过多，请1小时后再试'
});
```

## 6. 移动端适配

### 6.1 移动端登录界面

```tsx
// components/auth/MobileAuthInterface.tsx
const MobileAuthInterface: React.FC = () => {
  const [authMode, setAuthMode] = useState<'login' | 'register'>('login');

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-600 to-purple-600 flex flex-col">
      {/* 顶部装饰 */}
      <div className="flex-1 flex items-center justify-center p-6">
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          className="w-full max-w-sm"
        >
          {/* Logo */}
          <div className="text-center mb-8">
            <img src="/logo-white.svg" alt="AI Agent Market" className="h-12 mx-auto mb-4" />
            <h1 className="text-2xl font-bold text-white mb-2">AI Agent市场</h1>
            <p className="text-white/80 text-sm">让创意与AI大师碰撞出火花</p>
          </div>

          {/* 表单卡片 */}
          <div className="bg-white/10 backdrop-blur-md rounded-2xl p-6 border border-white/20">
            {authMode === 'login' ? (
              <MobileLoginForm 
                onSwitchToRegister={() => setAuthMode('register')}
              />
            ) : (
              <MobileRegisterForm 
                onSwitchToLogin={() => setAuthMode('login')}
              />
            )}
          </div>

          {/* 第三方登录 */}
          <div className="mt-6 space-y-3">
            <SocialLoginButtons mode={authMode} />
          </div>
        </motion.div>
      </div>
    </div>
  );
};
```

## 7. 性能优化

### 7.1 表单验证优化

```typescript
// hooks/useFormValidation.ts
import { useState, useMemo } from 'react';
import { debounce } from 'lodash';

export const useAsyncValidation = (validator: (value: string) => Promise<boolean>) => {
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<boolean | null>(null);

  const debouncedValidator = useMemo(
    () => debounce(async (value: string) => {
      if (!value) {
        setValidationResult(null);
        return;
      }

      setIsValidating(true);
      try {
        const result = await validator(value);
        setValidationResult(result);
      } catch (error) {
        setValidationResult(false);
      } finally {
        setIsValidating(false);
      }
    }, 500),
    [validator]
  );

  return {
    validate: debouncedValidator,
    isValidating,
    validationResult,
    reset: () => {
      setValidationResult(null);
      setIsValidating(false);
    }
  };
};

// 使用示例：邮箱唯一性检查
const EmailField: React.FC = () => {
  const checkEmailUnique = async (email: string) => {
    const response = await fetch(`/api/auth/check-email?email=${email}`);
    const data = await response.json();
    return data.available;
  };

  const { validate, isValidating, validationResult } = useAsyncValidation(checkEmailUnique);

  return (
    <div>
      <input
        type="email"
        onChange={(e) => validate(e.target.value)}
        className={`
          ${validationResult === false ? 'border-red-500' : ''}
          ${validationResult === true ? 'border-green-500' : ''}
        `}
      />
      {isValidating && <span>检查中...</span>}
      {validationResult === false && <span className="text-red-500">邮箱已被使用</span>}
      {validationResult === true && <span className="text-green-500">邮箱可用</span>}
    </div>
  );
};
```

## 8. 总结

这个登录注册页面设计规范文档提供了完整的前后端实现方案，包括：

### 核心功能特性
1. **多种登录方式** - 邮箱密码、第三方社交登录
2. **强安全机制** - 密码加密、JWT认证、速率限制
3. **完整的用户生命周期** - 注册、验证、登录、密码重置
4. **优秀的用户体验** - 响应式设计、实时验证、友好提示
5. **移动端优化** - 专门的移动端界面设计

### 技术亮点
- **表单验证**：客户端和服务端双重验证
- **安全防护**：CSRF防护、速率限制、密码强度检查
- **第三方集成**：微信、GitHub、Google登录
- **数据库设计**：完整的用户认证相关表结构
- **性能优化**：异步验证、防抖处理

### 安全机制
- **密码安全**：bcrypt加密存储
- **Token管理**：JWT访问令牌和刷新令牌机制
- **速率限制**：防止暴力破解和恶意注册
- **CSRF防护**：状态参数验证
- **数据验证**：前后端双重验证机制

这套完整的登录注册系统为AI Agent市场提供了安全、友好、高效的用户认证入口。

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"activeForm": "\u8bbe\u8ba1\u9996\u9875\u8be6\u7ec6\u89c4\u8303\u6587\u6863", "content": "\u8bbe\u8ba1\u9996\u9875\u8be6\u7ec6\u89c4\u8303\u6587\u6863", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1\u521b\u610f\u63d0\u4ea4\u9875\u9762\u6587\u6863", "content": "\u8bbe\u8ba1\u521b\u610f\u63d0\u4ea4\u9875\u9762\u6587\u6863", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1\u5b9e\u65f6\u8ba8\u8bba\u9875\u9762\u6587\u6863", "content": "\u8bbe\u8ba1\u5b9e\u65f6\u8ba8\u8bba\u9875\u9762\u6587\u6863", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1Agent\u5546\u5e97\u9875\u9762\u6587\u6863", "content": "\u8bbe\u8ba1Agent\u5546\u5e97\u9875\u9762\u6587\u6863", "status": "completed"}, {"activeForm": "\u8bbe\u8ba1\u7528\u6237\u4e2a\u4eba\u4e2d\u5fc3\u6587\u6863", "content": "\u8bbe\u8ba1\u7528\u6237\u4e2a\u4eba\u4e2d\u5fc3\u6587\u6863", "status": "completed"}, {"activeForm": "\u6574\u7406API\u63a5\u53e3\u89c4\u8303\u6587\u6863", "content": "\u6574\u7406API\u63a5\u53e3\u89c4\u8303\u6587\u6863", "status": "completed"}, {"activeForm": "\u8865\u5145\u767b\u5f55\u6ce8\u518c\u9875\u9762\u8bbe\u8ba1\u6587\u6863", "content": "\u8865\u5145\u767b\u5f55\u6ce8\u518c\u9875\u9762\u8bbe\u8ba1\u6587\u6863", "status": "completed"}]