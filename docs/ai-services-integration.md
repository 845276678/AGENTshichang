# AIæœåŠ¡é›†æˆå¼€å‘æ–‡æ¡£

## ğŸ¤– AIæœåŠ¡æ¦‚è§ˆ

### é›†æˆçš„5ä¸ªAIæœåŠ¡
| AIæœåŠ¡ | æä¾›å•† | ä¸»è¦åŠŸèƒ½ | APIæ–‡æ¡£ |
|--------|--------|----------|---------|
| æ–‡å¿ƒä¸€è¨€ | ç™¾åº¦ | åˆ›æ„è§£æä¸ç†è§£ | [æ–‡å¿ƒä¸€è¨€API](https://cloud.baidu.com/doc/WENXINWORKSHOP) |
| é€šä¹‰åƒé—® | é˜¿é‡Œå·´å·´ | æŠ€æœ¯æ¶æ„è®¾è®¡ | [é€šä¹‰åƒé—®API](https://help.aliyun.com/dashscope/) |
| æ˜Ÿç«å¤§æ¨¡å‹ | è®¯é£ | å¸‚åœºè°ƒç ”ä¸åˆ†æ | [æ˜Ÿç«API](https://www.xfyun.cn/doc/spark/Web.html) |
| æ··å…ƒ | è…¾è®¯ | è´¢åŠ¡å»ºæ¨¡ä¸é¢„æµ‹ | [æ··å…ƒAPI](https://cloud.tencent.com/document/product/1729) |
| GLM | æ™ºè°±AI | æ³•å¾‹åˆè§„åˆ†æ | [GLM API](https://open.bigmodel.cn/dev/api) |

## ğŸ”‘ APIå¯†é’¥ç”³è¯·æŒ‡å—

### 1. ç™¾åº¦æ–‡å¿ƒä¸€è¨€
```bash
# ç”³è¯·åœ°å€
https://cloud.baidu.com/product/wenxinworkshop

# ç”³è¯·æµç¨‹
1. æ³¨å†Œç™¾åº¦æ™ºèƒ½äº‘è´¦å·
2. å®åè®¤è¯ï¼ˆä¸ªäºº/ä¼ä¸šï¼‰
3. ç”³è¯·æ–‡å¿ƒä¸€è¨€æœåŠ¡
4. åˆ›å»ºåº”ç”¨è·å–API Keyå’ŒSecret Key
5. å……å€¼ï¼ˆå…è´¹é¢åº¦ç”¨å®Œåéœ€ä»˜è´¹ï¼‰

# è´¹ç”¨æ ‡å‡†
- å…è´¹é¢åº¦: æ¯æœˆ1000æ¬¡è°ƒç”¨
- ä»˜è´¹ä»·æ ¼: 0.012å…ƒ/1K tokens
```

### 2. é˜¿é‡Œé€šä¹‰åƒé—®
```bash
# ç”³è¯·åœ°å€
https://dashscope.aliyun.com

# ç”³è¯·æµç¨‹
1. å¼€é€šé˜¿é‡Œäº‘è´¦å·
2. å®åè®¤è¯
3. å¼€é€šDashScopeæœåŠ¡
4. åˆ›å»ºAPI Key
5. é€‰æ‹©è®¡è´¹æ¨¡å¼

# è´¹ç”¨æ ‡å‡†
- å…è´¹é¢åº¦: æ¯æœˆ100ä¸‡tokens
- ä»˜è´¹ä»·æ ¼: 0.002å…ƒ/1K tokens
```

### 3. è®¯é£æ˜Ÿç«
```bash
# ç”³è¯·åœ°å€
https://console.xfyun.cn

# ç”³è¯·æµç¨‹
1. æ³¨å†Œè®¯é£å¼€æ”¾å¹³å°è´¦å·
2. å®åè®¤è¯
3. åˆ›å»ºæ˜Ÿç«åº”ç”¨
4. è·å–APPIDã€APISecretã€APIKey
5. å……å€¼è´­ä¹°æœåŠ¡

# è´¹ç”¨æ ‡å‡†
- å…è´¹é¢åº¦: æ¯æ—¥200æ¬¡
- ä»˜è´¹ä»·æ ¼: 0.018å…ƒ/1K tokens
```

### 4. è…¾è®¯æ··å…ƒ
```bash
# ç”³è¯·åœ°å€
https://cloud.tencent.com/product/hunyuan

# ç”³è¯·æµç¨‹
1. æ³¨å†Œè…¾è®¯äº‘è´¦å·
2. å®Œæˆå®åè®¤è¯
3. å¼€é€šæ··å…ƒæœåŠ¡
4. åˆ›å»ºå¯†é’¥(SecretId/SecretKey)
5. å¼€é€šè®¡è´¹

# è´¹ç”¨æ ‡å‡†
- å…è´¹é¢åº¦: æ¯æœˆ10ä¸‡tokens
- ä»˜è´¹ä»·æ ¼: 0.01å…ƒ/1K tokens
```

### 5. æ™ºè°±GLM
```bash
# ç”³è¯·åœ°å€
https://open.bigmodel.cn

# ç”³è¯·æµç¨‹
1. æ³¨å†Œæ™ºè°±AIè´¦å·
2. å®åè®¤è¯
3. ç”³è¯·APIè®¿é—®æƒé™
4. è·å–API Key
5. å……å€¼è´¦æˆ·

# è´¹ç”¨æ ‡å‡†
- å…è´¹é¢åº¦: æ³¨å†Œé€18å…ƒä½“éªŒé‡‘
- ä»˜è´¹ä»·æ ¼: 0.005å…ƒ/1K tokens
```

## ğŸ”§ APIæ¥å£å°è£…

### AIæœåŠ¡ç®¡ç†å™¨
```typescript
// src/lib/ai-services.ts
import { AI_PROMPTS } from './ai-prompts'

export interface AIService {
  name: string
  provider: string
  task: string
  call(prompt: string, data: any): Promise<AIResponse>
}

export interface AIResponse {
  success: boolean
  data?: any
  error?: string
  usage?: {
    promptTokens: number
    completionTokens: number
    totalTokens: number
  }
}

export class AIServiceManager {
  private services: Map<string, AIService> = new Map()

  constructor() {
    this.initializeServices()
  }

  private initializeServices() {
    this.services.set('baidu', new BaiduService())
    this.services.set('alibaba', new AlibabaService())
    this.services.set('iflytek', new IflytekService())
    this.services.set('tencent', new TencentService())
    this.services.set('zhipu', new ZhipuService())
  }

  async callService(serviceId: string, task: string, data: any): Promise<AIResponse> {
    const service = this.services.get(serviceId)
    if (!service) {
      throw new Error(`AI service ${serviceId} not found`)
    }

    const prompt = this.buildPrompt(task, data)
    return await service.call(prompt, data)
  }

  private buildPrompt(task: string, data: any): string {
    const promptTemplate = AI_PROMPTS[task as keyof typeof AI_PROMPTS]
    if (!promptTemplate) {
      throw new Error(`Prompt template for ${task} not found`)
    }

    // æ›¿æ¢æ¨¡æ¿å˜é‡
    return promptTemplate
      .replace('{ideaTitle}', data.title || '')
      .replace('{ideaDescription}', data.description || '')
      .replace('{category}', data.category || '')
      .replace('{submittedAt}', data.submittedAt || '')
  }
}
```

### ç™¾åº¦æ–‡å¿ƒä¸€è¨€å®ç°
```typescript
// src/lib/ai-services/baidu.ts
import crypto from 'crypto'

export class BaiduService implements AIService {
  name = 'ç™¾åº¦æ–‡å¿ƒä¸€è¨€'
  provider = 'baidu'
  task = 'åˆ›æ„è§£æä¸ç†è§£'

  private apiKey = process.env.BAIDU_API_KEY!
  private secretKey = process.env.BAIDU_SECRET_KEY!
  private baseUrl = 'https://aip.baidubce.com'

  async call(prompt: string, data: any): Promise<AIResponse> {
    try {
      // è·å–access token
      const accessToken = await this.getAccessToken()

      // è°ƒç”¨æ–‡å¿ƒä¸€è¨€API
      const response = await fetch(
        `${this.baseUrl}/rpc/2.0/ai_custom/v1/wenxinworkshop/chat/completions?access_token=${accessToken}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ],
            temperature: 0.7,
            top_p: 0.9,
            penalty_score: 1.0
          })
        }
      )

      const result = await response.json()

      if (result.error_code) {
        return {
          success: false,
          error: `ç™¾åº¦APIé”™è¯¯: ${result.error_msg}`
        }
      }

      return {
        success: true,
        data: result.result,
        usage: {
          promptTokens: result.usage?.prompt_tokens || 0,
          completionTokens: result.usage?.completion_tokens || 0,
          totalTokens: result.usage?.total_tokens || 0
        }
      }

    } catch (error) {
      return {
        success: false,
        error: `ç™¾åº¦æœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`
      }
    }
  }

  private async getAccessToken(): Promise<string> {
    const cacheKey = 'baidu_access_token'

    // å…ˆä»ç¼“å­˜è·å–
    const cachedToken = await redis.get(cacheKey)
    if (cachedToken) {
      return cachedToken
    }

    // è·å–æ–°token
    const response = await fetch(
      `${this.baseUrl}/oauth/2.0/token?grant_type=client_credentials&client_id=${this.apiKey}&client_secret=${this.secretKey}`,
      { method: 'POST' }
    )

    const result = await response.json()

    if (result.error) {
      throw new Error(`è·å–ç™¾åº¦access tokenå¤±è´¥: ${result.error_description}`)
    }

    // ç¼“å­˜tokenï¼ˆæœ‰æ•ˆæœŸ30å¤©ï¼Œæˆ‘ä»¬ç¼“å­˜25å¤©ï¼‰
    await redis.setex(cacheKey, 25 * 24 * 3600, result.access_token)

    return result.access_token
  }
}
```

### é˜¿é‡Œé€šä¹‰åƒé—®å®ç°
```typescript
// src/lib/ai-services/alibaba.ts
export class AlibabaService implements AIService {
  name = 'é˜¿é‡Œé€šä¹‰åƒé—®'
  provider = 'alibaba'
  task = 'æŠ€æœ¯æ¶æ„è®¾è®¡'

  private apiKey = process.env.ALIBABA_DASHSCOPE_API_KEY!
  private baseUrl = 'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation'

  async call(prompt: string, data: any): Promise<AIResponse> {
    try {
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'qwen-turbo',
          input: {
            messages: [
              {
                role: 'user',
                content: prompt
              }
            ]
          },
          parameters: {
            temperature: 0.7,
            top_p: 0.9,
            max_tokens: 2000
          }
        })
      })

      const result = await response.json()

      if (result.code && result.code !== '200') {
        return {
          success: false,
          error: `é˜¿é‡ŒAPIé”™è¯¯: ${result.message}`
        }
      }

      return {
        success: true,
        data: result.output?.text || result.output?.choices?.[0]?.message?.content,
        usage: {
          promptTokens: result.usage?.input_tokens || 0,
          completionTokens: result.usage?.output_tokens || 0,
          totalTokens: result.usage?.total_tokens || 0
        }
      }

    } catch (error) {
      return {
        success: false,
        error: `é˜¿é‡ŒæœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`
      }
    }
  }
}
```

### è®¯é£æ˜Ÿç«å®ç°
```typescript
// src/lib/ai-services/iflytek.ts
import crypto from 'crypto'
import WebSocket from 'ws'

export class IflytekService implements AIService {
  name = 'è®¯é£æ˜Ÿç«'
  provider = 'iflytek'
  task = 'å¸‚åœºè°ƒç ”ä¸åˆ†æ'

  private appId = process.env.IFLYTEK_APP_ID!
  private apiSecret = process.env.IFLYTEK_API_SECRET!
  private apiKey = process.env.IFLYTEK_API_KEY!
  private baseUrl = 'wss://spark-api.xf-yun.com/v3.1/chat'

  async call(prompt: string, data: any): Promise<AIResponse> {
    return new Promise((resolve) => {
      try {
        const url = this.generateUrl()
        const ws = new WebSocket(url)

        let response = ''
        let usage = { promptTokens: 0, completionTokens: 0, totalTokens: 0 }

        ws.on('open', () => {
          const params = {
            header: {
              app_id: this.appId,
              uid: 'aimarket'
            },
            parameter: {
              chat: {
                domain: 'generalv3',
                temperature: 0.7,
                max_tokens: 2048
              }
            },
            payload: {
              message: {
                text: [
                  {
                    role: 'user',
                    content: prompt
                  }
                ]
              }
            }
          }

          ws.send(JSON.stringify(params))
        })

        ws.on('message', (data) => {
          const result = JSON.parse(data.toString())

          if (result.header.code !== 0) {
            resolve({
              success: false,
              error: `è®¯é£APIé”™è¯¯: ${result.header.message}`
            })
            return
          }

          // ç´¯ç§¯å“åº”å†…å®¹
          if (result.payload?.choices?.text) {
            result.payload.choices.text.forEach((item: any) => {
              response += item.content
            })
          }

          // è®°å½•tokenä½¿ç”¨é‡
          if (result.payload?.usage) {
            usage = {
              promptTokens: result.payload.usage.text.prompt_tokens,
              completionTokens: result.payload.usage.text.completion_tokens,
              totalTokens: result.payload.usage.text.total_tokens
            }
          }

          // æ£€æŸ¥æ˜¯å¦ç»“æŸ
          if (result.header.status === 2) {
            ws.close()
            resolve({
              success: true,
              data: response.trim(),
              usage
            })
          }
        })

        ws.on('error', (error) => {
          resolve({
            success: false,
            error: `è®¯é£WebSocketé”™è¯¯: ${error.message}`
          })
        })

        // 30ç§’è¶…æ—¶
        setTimeout(() => {
          ws.close()
          resolve({
            success: false,
            error: 'è®¯é£æœåŠ¡è°ƒç”¨è¶…æ—¶'
          })
        }, 30000)

      } catch (error) {
        resolve({
          success: false,
          error: `è®¯é£æœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`
        })
      }
    })
  }

  private generateUrl(): string {
    const host = 'spark-api.xf-yun.com'
    const path = '/v3.1/chat'
    const date = new Date().toUTCString()

    // ç”Ÿæˆç­¾å
    const signatureOrigin = `host: ${host}\ndate: ${date}\nGET ${path} HTTP/1.1`
    const signature = crypto
      .createHmac('sha256', this.apiSecret)
      .update(signatureOrigin)
      .digest('base64')

    const authorizationOrigin = `api_key="${this.apiKey}", algorithm="hmac-sha256", headers="host date request-line", signature="${signature}"`
    const authorization = Buffer.from(authorizationOrigin).toString('base64')

    return `wss://${host}${path}?authorization=${authorization}&date=${encodeURIComponent(date)}&host=${host}`
  }
}
```

### è…¾è®¯æ··å…ƒå®ç°
```typescript
// src/lib/ai-services/tencent.ts
import crypto from 'crypto'

export class TencentService implements AIService {
  name = 'è…¾è®¯æ··å…ƒ'
  provider = 'tencent'
  task = 'è´¢åŠ¡å»ºæ¨¡ä¸é¢„æµ‹'

  private secretId = process.env.TENCENT_SECRET_ID!
  private secretKey = process.env.TENCENT_SECRET_KEY!
  private region = 'ap-beijing'
  private service = 'hunyuan'
  private host = 'hunyuan.tencentcloudapi.com'

  async call(prompt: string, data: any): Promise<AIResponse> {
    try {
      const payload = {
        Model: 'hunyuan-lite',
        Messages: [
          {
            Role: 'user',
            Content: prompt
          }
        ],
        Temperature: 0.7,
        TopP: 0.9
      }

      const headers = this.generateHeaders(JSON.stringify(payload))

      const response = await fetch(`https://${this.host}/`, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload)
      })

      const result = await response.json()

      if (result.Response?.Error) {
        return {
          success: false,
          error: `è…¾è®¯APIé”™è¯¯: ${result.Response.Error.Message}`
        }
      }

      return {
        success: true,
        data: result.Response?.Choices?.[0]?.Message?.Content || '',
        usage: {
          promptTokens: result.Response?.Usage?.PromptTokens || 0,
          completionTokens: result.Response?.Usage?.CompletionTokens || 0,
          totalTokens: result.Response?.Usage?.TotalTokens || 0
        }
      }

    } catch (error) {
      return {
        success: false,
        error: `è…¾è®¯æœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`
      }
    }
  }

  private generateHeaders(payload: string): Record<string, string> {
    const timestamp = Math.floor(Date.now() / 1000).toString()
    const date = new Date(parseInt(timestamp) * 1000).toISOString().substr(0, 10)

    // æ„å»ºç­¾å
    const hashedPayload = crypto.createHash('sha256').update(payload).digest('hex')
    const canonicalRequest = [
      'POST',
      '/',
      '',
      `content-type:application/json\nhost:${this.host}\n`,
      'content-type;host',
      hashedPayload
    ].join('\n')

    const stringToSign = [
      'TC3-HMAC-SHA256',
      timestamp,
      `${date}/${this.service}/tc3_request`,
      crypto.createHash('sha256').update(canonicalRequest).digest('hex')
    ].join('\n')

    const secretDate = crypto.createHmac('sha256', `TC3${this.secretKey}`).update(date).digest()
    const secretService = crypto.createHmac('sha256', secretDate).update(this.service).digest()
    const secretSigning = crypto.createHmac('sha256', secretService).update('tc3_request').digest()
    const signature = crypto.createHmac('sha256', secretSigning).update(stringToSign).digest('hex')

    const authorization = [
      'TC3-HMAC-SHA256',
      `Credential=${this.secretId}/${date}/${this.service}/tc3_request`,
      'SignedHeaders=content-type;host',
      `Signature=${signature}`
    ].join(', ')

    return {
      'Content-Type': 'application/json',
      'Host': this.host,
      'Authorization': authorization,
      'X-TC-Timestamp': timestamp,
      'X-TC-Version': '2023-09-01',
      'X-TC-Region': this.region,
      'X-TC-Action': 'ChatCompletions'
    }
  }
}
```

### æ™ºè°±GLMå®ç°
```typescript
// src/lib/ai-services/zhipu.ts
import jwt from 'jsonwebtoken'

export class ZhipuService implements AIService {
  name = 'æ™ºè°±GLM'
  provider = 'zhipu'
  task = 'æ³•å¾‹åˆè§„åˆ†æ'

  private apiKey = process.env.ZHIPU_API_KEY!
  private baseUrl = 'https://open.bigmodel.cn/api/paas/v4/chat/completions'

  async call(prompt: string, data: any): Promise<AIResponse> {
    try {
      const token = this.generateJWT()

      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'glm-4',
          messages: [
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.7,
          top_p: 0.9,
          max_tokens: 2000
        })
      })

      const result = await response.json()

      if (result.error) {
        return {
          success: false,
          error: `æ™ºè°±APIé”™è¯¯: ${result.error.message}`
        }
      }

      return {
        success: true,
        data: result.choices?.[0]?.message?.content || '',
        usage: {
          promptTokens: result.usage?.prompt_tokens || 0,
          completionTokens: result.usage?.completion_tokens || 0,
          totalTokens: result.usage?.total_tokens || 0
        }
      }

    } catch (error) {
      return {
        success: false,
        error: `æ™ºè°±æœåŠ¡è°ƒç”¨å¤±è´¥: ${error.message}`
      }
    }
  }

  private generateJWT(): string {
    const [apiKey, secret] = this.apiKey.split('.')

    const payload = {
      iss: apiKey,
      exp: Math.floor(Date.now() / 1000) + 3600, // 1å°æ—¶è¿‡æœŸ
      iat: Math.floor(Date.now() / 1000)
    }

    return jwt.sign(payload, secret, { algorithm: 'HS256' })
  }
}
```

## ğŸš€ å•†ä¸šè®¡åˆ’ç”ŸæˆAPI

### ä¸»è¦APIæ¥å£
```typescript
// src/app/api/business-plan/generate/route.ts
import { AIServiceManager } from '@/lib/ai-services'
import { verifyToken } from '@/lib/auth'

export async function POST(request: NextRequest) {
  try {
    // éªŒè¯ç”¨æˆ·èº«ä»½
    const authResult = await verifyToken(request)
    if (!authResult.success) {
      return NextResponse.json({ error: 'æœªæˆæƒè®¿é—®' }, { status: 401 })
    }

    const body = await request.json()
    const { ideaId, options } = body

    // è·å–åˆ›æ„ä¿¡æ¯
    const idea = await db.execute(
      'SELECT * FROM ideas WHERE id = ?',
      [ideaId]
    )

    if (idea.length === 0) {
      return NextResponse.json({ error: 'åˆ›æ„ä¸å­˜åœ¨' }, { status: 404 })
    }

    const ideaData = idea[0]

    // æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
    const user = authResult.user
    const businessPlanCost = 500 // ç”Ÿæˆå•†ä¸šè®¡åˆ’éœ€è¦500ç§¯åˆ†

    if (user.credits < businessPlanCost) {
      return NextResponse.json(
        { error: 'ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦500ç§¯åˆ†ç”Ÿæˆå•†ä¸šè®¡åˆ’' },
        { status: 400 }
      )
    }

    // åˆ›å»ºå•†ä¸šè®¡åˆ’è®°å½•
    const businessPlanResult = await db.execute(
      'INSERT INTO business_plans (idea_id, user_id, status) VALUES (?, ?, ?)',
      [ideaId, user.id, 'generating']
    )

    const businessPlanId = businessPlanResult.insertId

    // å¼‚æ­¥ç”Ÿæˆå•†ä¸šè®¡åˆ’
    generateBusinessPlanAsync(businessPlanId, ideaData, options)

    return NextResponse.json({
      success: true,
      businessPlanId,
      message: 'å•†ä¸šè®¡åˆ’ç”Ÿæˆå·²å¼€å§‹ï¼Œè¯·ç¨åæŸ¥çœ‹ç»“æœ'
    })

  } catch (error) {
    console.error('Business plan generation error:', error)
    return NextResponse.json(
      { error: 'å•†ä¸šè®¡åˆ’ç”Ÿæˆå¤±è´¥' },
      { status: 500 }
    )
  }
}

// å¼‚æ­¥ç”Ÿæˆå•†ä¸šè®¡åˆ’
async function generateBusinessPlanAsync(
  businessPlanId: number,
  ideaData: any,
  options: any
) {
  const aiManager = new AIServiceManager()
  const stages = [
    { service: 'baidu', task: 'WENXIN_CONCEPT_ANALYSIS' },
    { service: 'iflytek', task: 'SPARK_MARKET_RESEARCH' },
    { service: 'alibaba', task: 'QWEN_TECH_ARCHITECTURE' },
    { service: 'tencent', task: 'HUNYUAN_FINANCIAL_MODEL' },
    { service: 'zhipu', task: 'GLM_LEGAL_COMPLIANCE' }
  ]

  const results = {}
  let completedStages = 0

  try {
    for (const stage of stages) {
      // è°ƒç”¨AIæœåŠ¡
      const result = await aiManager.callService(
        stage.service,
        stage.task,
        ideaData
      )

      results[stage.task] = result
      completedStages++

      // æ›´æ–°è¿›åº¦
      await db.execute(
        'UPDATE business_plans SET generation_stages = ? WHERE id = ?',
        [JSON.stringify({ completed: completedStages, total: stages.length, results }), businessPlanId]
      )
    }

    // è®¡ç®—ç»¼åˆè¯„åˆ†
    const overallScore = calculateOverallScore(results)

    // æ›´æ–°æœ€ç»ˆç»“æœ
    await db.execute(
      'UPDATE business_plans SET plan_data = ?, overall_score = ?, status = ?, completed_at = NOW() WHERE id = ?',
      [JSON.stringify(results), overallScore, 'completed', businessPlanId]
    )

    // æ‰£é™¤ç”¨æˆ·ç§¯åˆ†
    await db.execute(
      'UPDATE users SET credits = credits - 500 WHERE id = ?',
      [ideaData.author_id]
    )

  } catch (error) {
    console.error('AI generation error:', error)

    // æ ‡è®°ä¸ºå¤±è´¥
    await db.execute(
      'UPDATE business_plans SET status = ? WHERE id = ?',
      ['failed', businessPlanId]
    )
  }
}

function calculateOverallScore(results: any): number {
  // æ ¹æ®å„AIæœåŠ¡çš„ç»“æœè®¡ç®—ç»¼åˆè¯„åˆ†
  let totalScore = 0
  let validResults = 0

  Object.values(results).forEach((result: any) => {
    if (result.success && result.data) {
      totalScore += 8.5 // å‡è®¾æ¯ä¸ªAIç»™å‡º8.5åˆ†çš„å¹³å‡åˆ†
      validResults++
    }
  })

  return validResults > 0 ? totalScore / validResults : 0
}
```

## ğŸ“Š é”™è¯¯å¤„ç†å’Œç›‘æ§

### é”™è¯¯å¤„ç†ç­–ç•¥
```typescript
// src/lib/ai-error-handler.ts
export class AIErrorHandler {
  static async handleError(service: string, error: any): Promise<void> {
    // è®°å½•é”™è¯¯æ—¥å¿—
    console.error(`AI Service Error [${service}]:`, error)

    // å‘é€ç›‘æ§å‘Šè­¦
    await sendAlert({
      service,
      error: error.message,
      timestamp: new Date().toISOString()
    })

    // è®°å½•åˆ°æ•°æ®åº“
    await db.execute(
      'INSERT INTO ai_service_logs (service, error_message, created_at) VALUES (?, ?, NOW())',
      [service, error.message]
    )
  }

  static async retry<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3,
    delay: number = 1000
  ): Promise<T> {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await fn()
      } catch (error) {
        if (i === maxRetries - 1) throw error
        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)))
      }
    }
    throw new Error('Max retries exceeded')
  }
}
```

### ä½¿ç”¨é‡ç›‘æ§
```typescript
// src/lib/ai-usage-monitor.ts
export class AIUsageMonitor {
  static async trackUsage(service: string, usage: any): Promise<void> {
    await db.execute(
      'INSERT INTO ai_usage_stats (service, prompt_tokens, completion_tokens, total_tokens, cost, created_at) VALUES (?, ?, ?, ?, ?, NOW())',
      [
        service,
        usage.promptTokens,
        usage.completionTokens,
        usage.totalTokens,
        this.calculateCost(service, usage.totalTokens)
      ]
    )
  }

  private static calculateCost(service: string, tokens: number): number {
    const prices = {
      baidu: 0.012,    // å…ƒ/1K tokens
      alibaba: 0.002,  // å…ƒ/1K tokens
      iflytek: 0.018,  // å…ƒ/1K tokens
      tencent: 0.01,   // å…ƒ/1K tokens
      zhipu: 0.005     // å…ƒ/1K tokens
    }

    return (tokens / 1000) * (prices[service as keyof typeof prices] || 0.01)
  }

  static async getDailyUsage(): Promise<any> {
    return await db.execute(`
      SELECT
        service,
        SUM(total_tokens) as total_tokens,
        SUM(cost) as total_cost,
        COUNT(*) as request_count
      FROM ai_usage_stats
      WHERE DATE(created_at) = CURDATE()
      GROUP BY service
    `)
  }
}
```

## ğŸ”„ ç¼“å­˜ä¼˜åŒ–

### AIç»“æœç¼“å­˜
```typescript
// src/lib/ai-cache.ts
export class AICacheManager {
  private static CACHE_PREFIX = 'ai_result:'
  private static DEFAULT_TTL = 24 * 3600 // 24å°æ—¶

  static async getCachedResult(key: string): Promise<any> {
    const cacheKey = `${this.CACHE_PREFIX}${key}`
    const cached = await redis.get(cacheKey)
    return cached ? JSON.parse(cached) : null
  }

  static async setCachedResult(key: string, result: any, ttl?: number): Promise<void> {
    const cacheKey = `${this.CACHE_PREFIX}${key}`
    await redis.setex(cacheKey, ttl || this.DEFAULT_TTL, JSON.stringify(result))
  }

  static generateCacheKey(service: string, prompt: string): string {
    const hash = crypto.createHash('md5').update(prompt).digest('hex')
    return `${service}:${hash}`
  }
}
```

---

**é›†æˆå®Œæˆåï¼Œç³»ç»Ÿå°†å…·å¤‡**:
- 5ä¸ªAIæœåŠ¡çš„å®Œæ•´é›†æˆ
- æ™ºèƒ½ç¼“å­˜å’Œé”™è¯¯é‡è¯•æœºåˆ¶
- è¯¦ç»†çš„ä½¿ç”¨é‡ç›‘æ§å’Œæˆæœ¬æ§åˆ¶
- é«˜å¹¶å‘ä¸‹çš„ç¨³å®šæœåŠ¡è°ƒç”¨
- å®Œæ•´çš„å•†ä¸šè®¡åˆ’ç”Ÿæˆæµç¨‹