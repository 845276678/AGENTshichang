
/**
 * Client
**/

import * as runtime from './runtime/binary.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Idea
 * 
 */
export type Idea = $Result.DefaultSelection<Prisma.$IdeaPayload>
/**
 * Model BiddingSession
 * 
 */
export type BiddingSession = $Result.DefaultSelection<Prisma.$BiddingSessionPayload>
/**
 * Model Bid
 * 
 */
export type Bid = $Result.DefaultSelection<Prisma.$BidPayload>
/**
 * Model PriceGuess
 * 
 */
export type PriceGuess = $Result.DefaultSelection<Prisma.$PriceGuessPayload>
/**
 * Model AIInteraction
 * 
 */
export type AIInteraction = $Result.DefaultSelection<Prisma.$AIInteractionPayload>
/**
 * Model UserBiddingBehavior
 * 
 */
export type UserBiddingBehavior = $Result.DefaultSelection<Prisma.$UserBiddingBehaviorPayload>
/**
 * Model AIServiceUsage
 * 
 */
export type AIServiceUsage = $Result.DefaultSelection<Prisma.$AIServiceUsagePayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model ResearchReport
 * 
 */
export type ResearchReport = $Result.DefaultSelection<Prisma.$ResearchReportPayload>
/**
 * Model CreditTransaction
 * 
 */
export type CreditTransaction = $Result.DefaultSelection<Prisma.$CreditTransactionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model AIUsageStats
 * 
 */
export type AIUsageStats = $Result.DefaultSelection<Prisma.$AIUsageStatsPayload>
/**
 * Model IdeaDiscussion
 * 
 */
export type IdeaDiscussion = $Result.DefaultSelection<Prisma.$IdeaDiscussionPayload>
/**
 * Model DiscussionMessage
 * 
 */
export type DiscussionMessage = $Result.DefaultSelection<Prisma.$DiscussionMessagePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  BANNED: 'BANNED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserLevel: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM',
  DIAMOND: 'DIAMOND'
};

export type UserLevel = (typeof UserLevel)[keyof typeof UserLevel]


export const IdeaCategory: {
  TECH: 'TECH',
  LIFESTYLE: 'LIFESTYLE',
  EDUCATION: 'EDUCATION',
  HEALTH: 'HEALTH',
  FINANCE: 'FINANCE',
  ENTERTAINMENT: 'ENTERTAINMENT',
  BUSINESS: 'BUSINESS',
  RETAIL: 'RETAIL',
  OTHER: 'OTHER'
};

export type IdeaCategory = (typeof IdeaCategory)[keyof typeof IdeaCategory]


export const IdeaStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ARCHIVED: 'ARCHIVED'
};

export type IdeaStatus = (typeof IdeaStatus)[keyof typeof IdeaStatus]


export const IdeaVisibility: {
  PUBLIC: 'PUBLIC',
  PRIVATE: 'PRIVATE',
  UNLISTED: 'UNLISTED'
};

export type IdeaVisibility = (typeof IdeaVisibility)[keyof typeof IdeaVisibility]


export const BiddingStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  ENDED: 'ENDED',
  CANCELLED: 'CANCELLED',
  FAILED: 'FAILED'
};

export type BiddingStatus = (typeof BiddingStatus)[keyof typeof BiddingStatus]


export const BiddingPhase: {
  DISCUSSION: 'DISCUSSION',
  BIDDING: 'BIDDING',
  RESULTS: 'RESULTS'
};

export type BiddingPhase = (typeof BiddingPhase)[keyof typeof BiddingPhase]


export const AIInteractionType: {
  opening: 'opening',
  bid_reaction: 'bid_reaction',
  psychology: 'psychology',
  result: 'result',
  glitch: 'glitch',
  mimicry: 'mimicry',
  conflict: 'conflict',
  alliance: 'alliance',
  breakdown: 'breakdown',
  user_response: 'user_response'
};

export type AIInteractionType = (typeof AIInteractionType)[keyof typeof AIInteractionType]


export const UserBiddingAction: {
  enter_session: 'enter_session',
  leave_session: 'leave_session',
  support_agent: 'support_agent',
  react_to_dialogue: 'react_to_dialogue',
  submit_guess: 'submit_guess',
  adjust_guess: 'adjust_guess',
  share_session: 'share_session',
  report_issue: 'report_issue'
};

export type UserBiddingAction = (typeof UserBiddingAction)[keyof typeof UserBiddingAction]


export const ReportStatus: {
  GENERATING: 'GENERATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const CreditTransactionType: {
  REGISTER_BONUS: 'REGISTER_BONUS',
  PURCHASE: 'PURCHASE',
  RESEARCH_COST: 'RESEARCH_COST',
  REFUND: 'REFUND',
  ADMIN_ADJUSTMENT: 'ADMIN_ADJUSTMENT',
  WITHDRAW: 'WITHDRAW'
};

export type CreditTransactionType = (typeof CreditTransactionType)[keyof typeof CreditTransactionType]


export const DiscussionStatus: {
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED',
  CANCELLED: 'CANCELLED'
};

export type DiscussionStatus = (typeof DiscussionStatus)[keyof typeof DiscussionStatus]


export const MessageType: {
  INITIAL_ANALYSIS: 'INITIAL_ANALYSIS',
  CLARIFICATION_REQUEST: 'CLARIFICATION_REQUEST',
  USER_RESPONSE: 'USER_RESPONSE',
  IMPROVEMENT_SUGGESTION: 'IMPROVEMENT_SUGGESTION',
  FINAL_ASSESSMENT: 'FINAL_ASSESSMENT'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const SenderType: {
  USER: 'USER',
  AI_AGENT: 'AI_AGENT'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const AgentType: {
  CREATIVE: 'CREATIVE',
  ANALYTICAL: 'ANALYTICAL',
  TECHNICAL: 'TECHNICAL',
  BUSINESS: 'BUSINESS',
  MARKETING: 'MARKETING'
};

export type AgentType = (typeof AgentType)[keyof typeof AgentType]


export const AgentStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE'
};

export type AgentStatus = (typeof AgentStatus)[keyof typeof AgentStatus]

}

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserLevel = $Enums.UserLevel

export const UserLevel: typeof $Enums.UserLevel

export type IdeaCategory = $Enums.IdeaCategory

export const IdeaCategory: typeof $Enums.IdeaCategory

export type IdeaStatus = $Enums.IdeaStatus

export const IdeaStatus: typeof $Enums.IdeaStatus

export type IdeaVisibility = $Enums.IdeaVisibility

export const IdeaVisibility: typeof $Enums.IdeaVisibility

export type BiddingStatus = $Enums.BiddingStatus

export const BiddingStatus: typeof $Enums.BiddingStatus

export type BiddingPhase = $Enums.BiddingPhase

export const BiddingPhase: typeof $Enums.BiddingPhase

export type AIInteractionType = $Enums.AIInteractionType

export const AIInteractionType: typeof $Enums.AIInteractionType

export type UserBiddingAction = $Enums.UserBiddingAction

export const UserBiddingAction: typeof $Enums.UserBiddingAction

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type CreditTransactionType = $Enums.CreditTransactionType

export const CreditTransactionType: typeof $Enums.CreditTransactionType

export type DiscussionStatus = $Enums.DiscussionStatus

export const DiscussionStatus: typeof $Enums.DiscussionStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type AgentType = $Enums.AgentType

export const AgentType: typeof $Enums.AgentType

export type AgentStatus = $Enums.AgentStatus

export const AgentStatus: typeof $Enums.AgentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => $Utils.JsPromise<void> : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.idea`: Exposes CRUD operations for the **Idea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ideas
    * const ideas = await prisma.idea.findMany()
    * ```
    */
  get idea(): Prisma.IdeaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.biddingSession`: Exposes CRUD operations for the **BiddingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiddingSessions
    * const biddingSessions = await prisma.biddingSession.findMany()
    * ```
    */
  get biddingSession(): Prisma.BiddingSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bid`: Exposes CRUD operations for the **Bid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bids
    * const bids = await prisma.bid.findMany()
    * ```
    */
  get bid(): Prisma.BidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceGuess`: Exposes CRUD operations for the **PriceGuess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceGuesses
    * const priceGuesses = await prisma.priceGuess.findMany()
    * ```
    */
  get priceGuess(): Prisma.PriceGuessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIInteraction`: Exposes CRUD operations for the **AIInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIInteractions
    * const aIInteractions = await prisma.aIInteraction.findMany()
    * ```
    */
  get aIInteraction(): Prisma.AIInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBiddingBehavior`: Exposes CRUD operations for the **UserBiddingBehavior** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBiddingBehaviors
    * const userBiddingBehaviors = await prisma.userBiddingBehavior.findMany()
    * ```
    */
  get userBiddingBehavior(): Prisma.UserBiddingBehaviorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIServiceUsage`: Exposes CRUD operations for the **AIServiceUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIServiceUsages
    * const aIServiceUsages = await prisma.aIServiceUsage.findMany()
    * ```
    */
  get aIServiceUsage(): Prisma.AIServiceUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchReport`: Exposes CRUD operations for the **ResearchReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchReports
    * const researchReports = await prisma.researchReport.findMany()
    * ```
    */
  get researchReport(): Prisma.ResearchReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditTransaction`: Exposes CRUD operations for the **CreditTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditTransactions
    * const creditTransactions = await prisma.creditTransaction.findMany()
    * ```
    */
  get creditTransaction(): Prisma.CreditTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIUsageStats`: Exposes CRUD operations for the **AIUsageStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIUsageStats
    * const aIUsageStats = await prisma.aIUsageStats.findMany()
    * ```
    */
  get aIUsageStats(): Prisma.AIUsageStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ideaDiscussion`: Exposes CRUD operations for the **IdeaDiscussion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IdeaDiscussions
    * const ideaDiscussions = await prisma.ideaDiscussion.findMany()
    * ```
    */
  get ideaDiscussion(): Prisma.IdeaDiscussionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discussionMessage`: Exposes CRUD operations for the **DiscussionMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscussionMessages
    * const discussionMessages = await prisma.discussionMessage.findMany()
    * ```
    */
  get discussionMessage(): Prisma.DiscussionMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSession: 'UserSession',
    RefreshToken: 'RefreshToken',
    Idea: 'Idea',
    BiddingSession: 'BiddingSession',
    Bid: 'Bid',
    PriceGuess: 'PriceGuess',
    AIInteraction: 'AIInteraction',
    UserBiddingBehavior: 'UserBiddingBehavior',
    AIServiceUsage: 'AIServiceUsage',
    UserAchievement: 'UserAchievement',
    ResearchReport: 'ResearchReport',
    CreditTransaction: 'CreditTransaction',
    Payment: 'Payment',
    Refund: 'Refund',
    File: 'File',
    SystemConfig: 'SystemConfig',
    AIUsageStats: 'AIUsageStats',
    IdeaDiscussion: 'IdeaDiscussion',
    DiscussionMessage: 'DiscussionMessage',
    Order: 'Order',
    CartItem: 'CartItem',
    Agent: 'Agent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSession" | "refreshToken" | "idea" | "biddingSession" | "bid" | "priceGuess" | "aIInteraction" | "userBiddingBehavior" | "aIServiceUsage" | "userAchievement" | "researchReport" | "creditTransaction" | "payment" | "refund" | "file" | "systemConfig" | "aIUsageStats" | "ideaDiscussion" | "discussionMessage" | "order" | "cartItem" | "agent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Idea: {
        payload: Prisma.$IdeaPayload<ExtArgs>
        fields: Prisma.IdeaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdeaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdeaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          findFirst: {
            args: Prisma.IdeaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdeaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          findMany: {
            args: Prisma.IdeaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          create: {
            args: Prisma.IdeaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          createMany: {
            args: Prisma.IdeaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdeaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          delete: {
            args: Prisma.IdeaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          update: {
            args: Prisma.IdeaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          deleteMany: {
            args: Prisma.IdeaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdeaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdeaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>[]
          }
          upsert: {
            args: Prisma.IdeaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaPayload>
          }
          aggregate: {
            args: Prisma.IdeaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdea>
          }
          groupBy: {
            args: Prisma.IdeaGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdeaGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdeaCountArgs<ExtArgs>
            result: $Utils.Optional<IdeaCountAggregateOutputType> | number
          }
        }
      }
      BiddingSession: {
        payload: Prisma.$BiddingSessionPayload<ExtArgs>
        fields: Prisma.BiddingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiddingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiddingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          findFirst: {
            args: Prisma.BiddingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiddingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          findMany: {
            args: Prisma.BiddingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>[]
          }
          create: {
            args: Prisma.BiddingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          createMany: {
            args: Prisma.BiddingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiddingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>[]
          }
          delete: {
            args: Prisma.BiddingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          update: {
            args: Prisma.BiddingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          deleteMany: {
            args: Prisma.BiddingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiddingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BiddingSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>[]
          }
          upsert: {
            args: Prisma.BiddingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiddingSessionPayload>
          }
          aggregate: {
            args: Prisma.BiddingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiddingSession>
          }
          groupBy: {
            args: Prisma.BiddingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiddingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiddingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<BiddingSessionCountAggregateOutputType> | number
          }
        }
      }
      Bid: {
        payload: Prisma.$BidPayload<ExtArgs>
        fields: Prisma.BidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findFirst: {
            args: Prisma.BidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          findMany: {
            args: Prisma.BidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          create: {
            args: Prisma.BidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          createMany: {
            args: Prisma.BidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          delete: {
            args: Prisma.BidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          update: {
            args: Prisma.BidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          deleteMany: {
            args: Prisma.BidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>[]
          }
          upsert: {
            args: Prisma.BidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BidPayload>
          }
          aggregate: {
            args: Prisma.BidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBid>
          }
          groupBy: {
            args: Prisma.BidGroupByArgs<ExtArgs>
            result: $Utils.Optional<BidGroupByOutputType>[]
          }
          count: {
            args: Prisma.BidCountArgs<ExtArgs>
            result: $Utils.Optional<BidCountAggregateOutputType> | number
          }
        }
      }
      PriceGuess: {
        payload: Prisma.$PriceGuessPayload<ExtArgs>
        fields: Prisma.PriceGuessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceGuessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceGuessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          findFirst: {
            args: Prisma.PriceGuessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceGuessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          findMany: {
            args: Prisma.PriceGuessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>[]
          }
          create: {
            args: Prisma.PriceGuessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          createMany: {
            args: Prisma.PriceGuessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceGuessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>[]
          }
          delete: {
            args: Prisma.PriceGuessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          update: {
            args: Prisma.PriceGuessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          deleteMany: {
            args: Prisma.PriceGuessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceGuessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceGuessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>[]
          }
          upsert: {
            args: Prisma.PriceGuessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceGuessPayload>
          }
          aggregate: {
            args: Prisma.PriceGuessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceGuess>
          }
          groupBy: {
            args: Prisma.PriceGuessGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceGuessGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceGuessCountArgs<ExtArgs>
            result: $Utils.Optional<PriceGuessCountAggregateOutputType> | number
          }
        }
      }
      AIInteraction: {
        payload: Prisma.$AIInteractionPayload<ExtArgs>
        fields: Prisma.AIInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          findFirst: {
            args: Prisma.AIInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          findMany: {
            args: Prisma.AIInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>[]
          }
          create: {
            args: Prisma.AIInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          createMany: {
            args: Prisma.AIInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>[]
          }
          delete: {
            args: Prisma.AIInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          update: {
            args: Prisma.AIInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          deleteMany: {
            args: Prisma.AIInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>[]
          }
          upsert: {
            args: Prisma.AIInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIInteractionPayload>
          }
          aggregate: {
            args: Prisma.AIInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIInteraction>
          }
          groupBy: {
            args: Prisma.AIInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<AIInteractionCountAggregateOutputType> | number
          }
        }
      }
      UserBiddingBehavior: {
        payload: Prisma.$UserBiddingBehaviorPayload<ExtArgs>
        fields: Prisma.UserBiddingBehaviorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBiddingBehaviorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBiddingBehaviorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          findFirst: {
            args: Prisma.UserBiddingBehaviorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBiddingBehaviorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          findMany: {
            args: Prisma.UserBiddingBehaviorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>[]
          }
          create: {
            args: Prisma.UserBiddingBehaviorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          createMany: {
            args: Prisma.UserBiddingBehaviorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBiddingBehaviorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>[]
          }
          delete: {
            args: Prisma.UserBiddingBehaviorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          update: {
            args: Prisma.UserBiddingBehaviorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          deleteMany: {
            args: Prisma.UserBiddingBehaviorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBiddingBehaviorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBiddingBehaviorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>[]
          }
          upsert: {
            args: Prisma.UserBiddingBehaviorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBiddingBehaviorPayload>
          }
          aggregate: {
            args: Prisma.UserBiddingBehaviorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBiddingBehavior>
          }
          groupBy: {
            args: Prisma.UserBiddingBehaviorGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBiddingBehaviorGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBiddingBehaviorCountArgs<ExtArgs>
            result: $Utils.Optional<UserBiddingBehaviorCountAggregateOutputType> | number
          }
        }
      }
      AIServiceUsage: {
        payload: Prisma.$AIServiceUsagePayload<ExtArgs>
        fields: Prisma.AIServiceUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIServiceUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIServiceUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          findFirst: {
            args: Prisma.AIServiceUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIServiceUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          findMany: {
            args: Prisma.AIServiceUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>[]
          }
          create: {
            args: Prisma.AIServiceUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          createMany: {
            args: Prisma.AIServiceUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIServiceUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>[]
          }
          delete: {
            args: Prisma.AIServiceUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          update: {
            args: Prisma.AIServiceUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          deleteMany: {
            args: Prisma.AIServiceUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIServiceUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIServiceUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>[]
          }
          upsert: {
            args: Prisma.AIServiceUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIServiceUsagePayload>
          }
          aggregate: {
            args: Prisma.AIServiceUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIServiceUsage>
          }
          groupBy: {
            args: Prisma.AIServiceUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIServiceUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIServiceUsageCountArgs<ExtArgs>
            result: $Utils.Optional<AIServiceUsageCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      ResearchReport: {
        payload: Prisma.$ResearchReportPayload<ExtArgs>
        fields: Prisma.ResearchReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          findFirst: {
            args: Prisma.ResearchReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          findMany: {
            args: Prisma.ResearchReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>[]
          }
          create: {
            args: Prisma.ResearchReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          createMany: {
            args: Prisma.ResearchReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>[]
          }
          delete: {
            args: Prisma.ResearchReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          update: {
            args: Prisma.ResearchReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          deleteMany: {
            args: Prisma.ResearchReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>[]
          }
          upsert: {
            args: Prisma.ResearchReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchReportPayload>
          }
          aggregate: {
            args: Prisma.ResearchReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchReport>
          }
          groupBy: {
            args: Prisma.ResearchReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchReportCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchReportCountAggregateOutputType> | number
          }
        }
      }
      CreditTransaction: {
        payload: Prisma.$CreditTransactionPayload<ExtArgs>
        fields: Prisma.CreditTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          findFirst: {
            args: Prisma.CreditTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          findMany: {
            args: Prisma.CreditTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          create: {
            args: Prisma.CreditTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          createMany: {
            args: Prisma.CreditTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          delete: {
            args: Prisma.CreditTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          update: {
            args: Prisma.CreditTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CreditTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CreditTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditTransactionPayload>
          }
          aggregate: {
            args: Prisma.CreditTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditTransaction>
          }
          groupBy: {
            args: Prisma.CreditTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CreditTransactionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      AIUsageStats: {
        payload: Prisma.$AIUsageStatsPayload<ExtArgs>
        fields: Prisma.AIUsageStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIUsageStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIUsageStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          findFirst: {
            args: Prisma.AIUsageStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIUsageStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          findMany: {
            args: Prisma.AIUsageStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>[]
          }
          create: {
            args: Prisma.AIUsageStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          createMany: {
            args: Prisma.AIUsageStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIUsageStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>[]
          }
          delete: {
            args: Prisma.AIUsageStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          update: {
            args: Prisma.AIUsageStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          deleteMany: {
            args: Prisma.AIUsageStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIUsageStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIUsageStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>[]
          }
          upsert: {
            args: Prisma.AIUsageStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIUsageStatsPayload>
          }
          aggregate: {
            args: Prisma.AIUsageStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIUsageStats>
          }
          groupBy: {
            args: Prisma.AIUsageStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIUsageStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIUsageStatsCountArgs<ExtArgs>
            result: $Utils.Optional<AIUsageStatsCountAggregateOutputType> | number
          }
        }
      }
      IdeaDiscussion: {
        payload: Prisma.$IdeaDiscussionPayload<ExtArgs>
        fields: Prisma.IdeaDiscussionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IdeaDiscussionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IdeaDiscussionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          findFirst: {
            args: Prisma.IdeaDiscussionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IdeaDiscussionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          findMany: {
            args: Prisma.IdeaDiscussionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>[]
          }
          create: {
            args: Prisma.IdeaDiscussionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          createMany: {
            args: Prisma.IdeaDiscussionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IdeaDiscussionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>[]
          }
          delete: {
            args: Prisma.IdeaDiscussionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          update: {
            args: Prisma.IdeaDiscussionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          deleteMany: {
            args: Prisma.IdeaDiscussionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IdeaDiscussionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IdeaDiscussionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>[]
          }
          upsert: {
            args: Prisma.IdeaDiscussionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IdeaDiscussionPayload>
          }
          aggregate: {
            args: Prisma.IdeaDiscussionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIdeaDiscussion>
          }
          groupBy: {
            args: Prisma.IdeaDiscussionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IdeaDiscussionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IdeaDiscussionCountArgs<ExtArgs>
            result: $Utils.Optional<IdeaDiscussionCountAggregateOutputType> | number
          }
        }
      }
      DiscussionMessage: {
        payload: Prisma.$DiscussionMessagePayload<ExtArgs>
        fields: Prisma.DiscussionMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscussionMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscussionMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          findFirst: {
            args: Prisma.DiscussionMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscussionMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          findMany: {
            args: Prisma.DiscussionMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          create: {
            args: Prisma.DiscussionMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          createMany: {
            args: Prisma.DiscussionMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscussionMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          delete: {
            args: Prisma.DiscussionMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          update: {
            args: Prisma.DiscussionMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          deleteMany: {
            args: Prisma.DiscussionMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscussionMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscussionMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>[]
          }
          upsert: {
            args: Prisma.DiscussionMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionMessagePayload>
          }
          aggregate: {
            args: Prisma.DiscussionMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscussionMessage>
          }
          groupBy: {
            args: Prisma.DiscussionMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscussionMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscussionMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DiscussionMessageCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSession?: UserSessionOmit
    refreshToken?: RefreshTokenOmit
    idea?: IdeaOmit
    biddingSession?: BiddingSessionOmit
    bid?: BidOmit
    priceGuess?: PriceGuessOmit
    aIInteraction?: AIInteractionOmit
    userBiddingBehavior?: UserBiddingBehaviorOmit
    aIServiceUsage?: AIServiceUsageOmit
    userAchievement?: UserAchievementOmit
    researchReport?: ResearchReportOmit
    creditTransaction?: CreditTransactionOmit
    payment?: PaymentOmit
    refund?: RefundOmit
    file?: FileOmit
    systemConfig?: SystemConfigOmit
    aIUsageStats?: AIUsageStatsOmit
    ideaDiscussion?: IdeaDiscussionOmit
    discussionMessage?: DiscussionMessageOmit
    order?: OrderOmit
    cartItem?: CartItemOmit
    agent?: AgentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ideas: number
    researchReports: number
    creditTransactions: number
    payments: number
    sessions: number
    refreshTokens: number
    files: number
    discussions: number
    orders: number
    cartItems: number
    biddingSessions: number
    priceGuesses: number
    biddingBehaviors: number
    achievements: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ideas?: boolean | UserCountOutputTypeCountIdeasArgs
    researchReports?: boolean | UserCountOutputTypeCountResearchReportsArgs
    creditTransactions?: boolean | UserCountOutputTypeCountCreditTransactionsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
    discussions?: boolean | UserCountOutputTypeCountDiscussionsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    cartItems?: boolean | UserCountOutputTypeCountCartItemsArgs
    biddingSessions?: boolean | UserCountOutputTypeCountBiddingSessionsArgs
    priceGuesses?: boolean | UserCountOutputTypeCountPriceGuessesArgs
    biddingBehaviors?: boolean | UserCountOutputTypeCountBiddingBehaviorsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIdeasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResearchReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreditTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaDiscussionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBiddingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPriceGuessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceGuessWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBiddingBehaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBiddingBehaviorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type IdeaCountOutputType
   */

  export type IdeaCountOutputType = {
    researchReports: number
    discussions: number
    biddingSessions: number
  }

  export type IdeaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    researchReports?: boolean | IdeaCountOutputTypeCountResearchReportsArgs
    discussions?: boolean | IdeaCountOutputTypeCountDiscussionsArgs
    biddingSessions?: boolean | IdeaCountOutputTypeCountBiddingSessionsArgs
  }

  // Custom InputTypes
  /**
   * IdeaCountOutputType without action
   */
  export type IdeaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaCountOutputType
     */
    select?: IdeaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IdeaCountOutputType without action
   */
  export type IdeaCountOutputTypeCountResearchReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchReportWhereInput
  }

  /**
   * IdeaCountOutputType without action
   */
  export type IdeaCountOutputTypeCountDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaDiscussionWhereInput
  }

  /**
   * IdeaCountOutputType without action
   */
  export type IdeaCountOutputTypeCountBiddingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingSessionWhereInput
  }


  /**
   * Count Type BiddingSessionCountOutputType
   */

  export type BiddingSessionCountOutputType = {
    bids: number
    priceGuesses: number
    interactions: number
    behaviors: number
  }

  export type BiddingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | BiddingSessionCountOutputTypeCountBidsArgs
    priceGuesses?: boolean | BiddingSessionCountOutputTypeCountPriceGuessesArgs
    interactions?: boolean | BiddingSessionCountOutputTypeCountInteractionsArgs
    behaviors?: boolean | BiddingSessionCountOutputTypeCountBehaviorsArgs
  }

  // Custom InputTypes
  /**
   * BiddingSessionCountOutputType without action
   */
  export type BiddingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSessionCountOutputType
     */
    select?: BiddingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiddingSessionCountOutputType without action
   */
  export type BiddingSessionCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
  }

  /**
   * BiddingSessionCountOutputType without action
   */
  export type BiddingSessionCountOutputTypeCountPriceGuessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceGuessWhereInput
  }

  /**
   * BiddingSessionCountOutputType without action
   */
  export type BiddingSessionCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInteractionWhereInput
  }

  /**
   * BiddingSessionCountOutputType without action
   */
  export type BiddingSessionCountOutputTypeCountBehaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBiddingBehaviorWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    refunds: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Count Type IdeaDiscussionCountOutputType
   */

  export type IdeaDiscussionCountOutputType = {
    sessions: number
    messages: number
  }

  export type IdeaDiscussionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | IdeaDiscussionCountOutputTypeCountSessionsArgs
    messages?: boolean | IdeaDiscussionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * IdeaDiscussionCountOutputType without action
   */
  export type IdeaDiscussionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussionCountOutputType
     */
    select?: IdeaDiscussionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IdeaDiscussionCountOutputType without action
   */
  export type IdeaDiscussionCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingSessionWhereInput
  }

  /**
   * IdeaDiscussionCountOutputType without action
   */
  export type IdeaDiscussionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    credits: number | null
    totalSpent: number | null
    totalEarned: number | null
    totalGuesses: number | null
    guessAccuracy: number | null
    guessEarnings: number | null
    guessLevel: number | null
    levelProgress: number | null
    consecutiveGuesses: number | null
    bestStreak: number | null
  }

  export type UserSumAggregateOutputType = {
    credits: number | null
    totalSpent: number | null
    totalEarned: number | null
    totalGuesses: number | null
    guessAccuracy: number | null
    guessEarnings: number | null
    guessLevel: number | null
    levelProgress: number | null
    consecutiveGuesses: number | null
    bestStreak: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    bio: string | null
    status: $Enums.UserStatus | null
    role: $Enums.UserRole | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    credits: number | null
    level: $Enums.UserLevel | null
    totalSpent: number | null
    totalEarned: number | null
    totalGuesses: number | null
    guessAccuracy: number | null
    guessEarnings: number | null
    guessLevel: number | null
    levelProgress: number | null
    consecutiveGuesses: number | null
    bestStreak: number | null
    favoriteAgent: string | null
    emailNotifications: boolean | null
    marketingEmails: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    bio: string | null
    status: $Enums.UserStatus | null
    role: $Enums.UserRole | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    credits: number | null
    level: $Enums.UserLevel | null
    totalSpent: number | null
    totalEarned: number | null
    totalGuesses: number | null
    guessAccuracy: number | null
    guessEarnings: number | null
    guessLevel: number | null
    levelProgress: number | null
    consecutiveGuesses: number | null
    bestStreak: number | null
    favoriteAgent: string | null
    emailNotifications: boolean | null
    marketingEmails: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    firstName: number
    lastName: number
    phone: number
    avatar: number
    bio: number
    status: number
    role: number
    isEmailVerified: number
    isPhoneVerified: number
    credits: number
    level: number
    totalSpent: number
    totalEarned: number
    totalGuesses: number
    guessAccuracy: number
    guessEarnings: number
    guessLevel: number
    levelProgress: number
    consecutiveGuesses: number
    bestStreak: number
    favoriteAgent: number
    emailNotifications: number
    marketingEmails: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    credits?: true
    totalSpent?: true
    totalEarned?: true
    totalGuesses?: true
    guessAccuracy?: true
    guessEarnings?: true
    guessLevel?: true
    levelProgress?: true
    consecutiveGuesses?: true
    bestStreak?: true
  }

  export type UserSumAggregateInputType = {
    credits?: true
    totalSpent?: true
    totalEarned?: true
    totalGuesses?: true
    guessAccuracy?: true
    guessEarnings?: true
    guessLevel?: true
    levelProgress?: true
    consecutiveGuesses?: true
    bestStreak?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    bio?: true
    status?: true
    role?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    credits?: true
    level?: true
    totalSpent?: true
    totalEarned?: true
    totalGuesses?: true
    guessAccuracy?: true
    guessEarnings?: true
    guessLevel?: true
    levelProgress?: true
    consecutiveGuesses?: true
    bestStreak?: true
    favoriteAgent?: true
    emailNotifications?: true
    marketingEmails?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    bio?: true
    status?: true
    role?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    credits?: true
    level?: true
    totalSpent?: true
    totalEarned?: true
    totalGuesses?: true
    guessAccuracy?: true
    guessEarnings?: true
    guessLevel?: true
    levelProgress?: true
    consecutiveGuesses?: true
    bestStreak?: true
    favoriteAgent?: true
    emailNotifications?: true
    marketingEmails?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phone?: true
    avatar?: true
    bio?: true
    status?: true
    role?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    credits?: true
    level?: true
    totalSpent?: true
    totalEarned?: true
    totalGuesses?: true
    guessAccuracy?: true
    guessEarnings?: true
    guessLevel?: true
    levelProgress?: true
    consecutiveGuesses?: true
    bestStreak?: true
    favoriteAgent?: true
    emailNotifications?: true
    marketingEmails?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string
    firstName: string | null
    lastName: string | null
    phone: string | null
    avatar: string | null
    bio: string | null
    status: $Enums.UserStatus
    role: $Enums.UserRole
    isEmailVerified: boolean
    isPhoneVerified: boolean
    credits: number
    level: $Enums.UserLevel
    totalSpent: number
    totalEarned: number
    totalGuesses: number
    guessAccuracy: number
    guessEarnings: number
    guessLevel: number
    levelProgress: number
    consecutiveGuesses: number
    bestStreak: number
    favoriteAgent: string | null
    emailNotifications: boolean
    marketingEmails: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    bio?: boolean
    status?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: boolean
    level?: boolean
    totalSpent?: boolean
    totalEarned?: boolean
    totalGuesses?: boolean
    guessAccuracy?: boolean
    guessEarnings?: boolean
    guessLevel?: boolean
    levelProgress?: boolean
    consecutiveGuesses?: boolean
    bestStreak?: boolean
    favoriteAgent?: boolean
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    ideas?: boolean | User$ideasArgs<ExtArgs>
    researchReports?: boolean | User$researchReportsArgs<ExtArgs>
    creditTransactions?: boolean | User$creditTransactionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    discussions?: boolean | User$discussionsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    cartItems?: boolean | User$cartItemsArgs<ExtArgs>
    biddingSessions?: boolean | User$biddingSessionsArgs<ExtArgs>
    priceGuesses?: boolean | User$priceGuessesArgs<ExtArgs>
    biddingBehaviors?: boolean | User$biddingBehaviorsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    bio?: boolean
    status?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: boolean
    level?: boolean
    totalSpent?: boolean
    totalEarned?: boolean
    totalGuesses?: boolean
    guessAccuracy?: boolean
    guessEarnings?: boolean
    guessLevel?: boolean
    levelProgress?: boolean
    consecutiveGuesses?: boolean
    bestStreak?: boolean
    favoriteAgent?: boolean
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    bio?: boolean
    status?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: boolean
    level?: boolean
    totalSpent?: boolean
    totalEarned?: boolean
    totalGuesses?: boolean
    guessAccuracy?: boolean
    guessEarnings?: boolean
    guessLevel?: boolean
    levelProgress?: boolean
    consecutiveGuesses?: boolean
    bestStreak?: boolean
    favoriteAgent?: boolean
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    avatar?: boolean
    bio?: boolean
    status?: boolean
    role?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: boolean
    level?: boolean
    totalSpent?: boolean
    totalEarned?: boolean
    totalGuesses?: boolean
    guessAccuracy?: boolean
    guessEarnings?: boolean
    guessLevel?: boolean
    levelProgress?: boolean
    consecutiveGuesses?: boolean
    bestStreak?: boolean
    favoriteAgent?: boolean
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "passwordHash" | "firstName" | "lastName" | "phone" | "avatar" | "bio" | "status" | "role" | "isEmailVerified" | "isPhoneVerified" | "credits" | "level" | "totalSpent" | "totalEarned" | "totalGuesses" | "guessAccuracy" | "guessEarnings" | "guessLevel" | "levelProgress" | "consecutiveGuesses" | "bestStreak" | "favoriteAgent" | "emailNotifications" | "marketingEmails" | "createdAt" | "updatedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ideas?: boolean | User$ideasArgs<ExtArgs>
    researchReports?: boolean | User$researchReportsArgs<ExtArgs>
    creditTransactions?: boolean | User$creditTransactionsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    discussions?: boolean | User$discussionsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    cartItems?: boolean | User$cartItemsArgs<ExtArgs>
    biddingSessions?: boolean | User$biddingSessionsArgs<ExtArgs>
    priceGuesses?: boolean | User$priceGuessesArgs<ExtArgs>
    biddingBehaviors?: boolean | User$biddingBehaviorsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      ideas: Prisma.$IdeaPayload<ExtArgs>[]
      researchReports: Prisma.$ResearchReportPayload<ExtArgs>[]
      creditTransactions: Prisma.$CreditTransactionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      discussions: Prisma.$IdeaDiscussionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      biddingSessions: Prisma.$BiddingSessionPayload<ExtArgs>[]
      priceGuesses: Prisma.$PriceGuessPayload<ExtArgs>[]
      biddingBehaviors: Prisma.$UserBiddingBehaviorPayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string
      firstName: string | null
      lastName: string | null
      phone: string | null
      avatar: string | null
      bio: string | null
      status: $Enums.UserStatus
      role: $Enums.UserRole
      isEmailVerified: boolean
      isPhoneVerified: boolean
      credits: number
      level: $Enums.UserLevel
      totalSpent: number
      totalEarned: number
      totalGuesses: number
      guessAccuracy: number
      guessEarnings: number
      guessLevel: number
      levelProgress: number
      consecutiveGuesses: number
      bestStreak: number
      favoriteAgent: string | null
      emailNotifications: boolean
      marketingEmails: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ideas<T extends User$ideasArgs<ExtArgs> = {}>(args?: Subset<T, User$ideasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    researchReports<T extends User$researchReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$researchReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creditTransactions<T extends User$creditTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$creditTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends User$filesArgs<ExtArgs> = {}>(args?: Subset<T, User$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discussions<T extends User$discussionsArgs<ExtArgs> = {}>(args?: Subset<T, User$discussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends User$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    biddingSessions<T extends User$biddingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$biddingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceGuesses<T extends User$priceGuessesArgs<ExtArgs> = {}>(args?: Subset<T, User$priceGuessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    biddingBehaviors<T extends User$biddingBehaviorsArgs<ExtArgs> = {}>(args?: Subset<T, User$biddingBehaviorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isPhoneVerified: FieldRef<"User", 'Boolean'>
    readonly credits: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'UserLevel'>
    readonly totalSpent: FieldRef<"User", 'Int'>
    readonly totalEarned: FieldRef<"User", 'Int'>
    readonly totalGuesses: FieldRef<"User", 'Int'>
    readonly guessAccuracy: FieldRef<"User", 'Float'>
    readonly guessEarnings: FieldRef<"User", 'Int'>
    readonly guessLevel: FieldRef<"User", 'Int'>
    readonly levelProgress: FieldRef<"User", 'Float'>
    readonly consecutiveGuesses: FieldRef<"User", 'Int'>
    readonly bestStreak: FieldRef<"User", 'Int'>
    readonly favoriteAgent: FieldRef<"User", 'String'>
    readonly emailNotifications: FieldRef<"User", 'Boolean'>
    readonly marketingEmails: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.ideas
   */
  export type User$ideasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    where?: IdeaWhereInput
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    cursor?: IdeaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * User.researchReports
   */
  export type User$researchReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    where?: ResearchReportWhereInput
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    cursor?: ResearchReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchReportScalarFieldEnum | ResearchReportScalarFieldEnum[]
  }

  /**
   * User.creditTransactions
   */
  export type User$creditTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    where?: CreditTransactionWhereInput
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    cursor?: CreditTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.files
   */
  export type User$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User.discussions
   */
  export type User$discussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    where?: IdeaDiscussionWhereInput
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    cursor?: IdeaDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeaDiscussionScalarFieldEnum | IdeaDiscussionScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.cartItems
   */
  export type User$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * User.biddingSessions
   */
  export type User$biddingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    where?: BiddingSessionWhereInput
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    cursor?: BiddingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * User.priceGuesses
   */
  export type User$priceGuessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    where?: PriceGuessWhereInput
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    cursor?: PriceGuessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceGuessScalarFieldEnum | PriceGuessScalarFieldEnum[]
  }

  /**
   * User.biddingBehaviors
   */
  export type User$biddingBehaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    where?: UserBiddingBehaviorWhereInput
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    cursor?: UserBiddingBehaviorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBiddingBehaviorScalarFieldEnum | UserBiddingBehaviorScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    isRevoked: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    isRevoked: boolean
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "isRevoked" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      isRevoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Idea
   */

  export type AggregateIdea = {
    _count: IdeaCountAggregateOutputType | null
    _avg: IdeaAvgAggregateOutputType | null
    _sum: IdeaSumAggregateOutputType | null
    _min: IdeaMinAggregateOutputType | null
    _max: IdeaMaxAggregateOutputType | null
  }

  export type IdeaAvgAggregateOutputType = {
    viewCount: number | null
    likeCount: number | null
  }

  export type IdeaSumAggregateOutputType = {
    viewCount: number | null
    likeCount: number | null
  }

  export type IdeaMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.IdeaCategory | null
    tags: string | null
    userId: string | null
    isAnonymous: boolean | null
    status: $Enums.IdeaStatus | null
    visibility: $Enums.IdeaVisibility | null
    viewCount: number | null
    likeCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: $Enums.IdeaCategory | null
    tags: string | null
    userId: string | null
    isAnonymous: boolean | null
    status: $Enums.IdeaStatus | null
    visibility: $Enums.IdeaVisibility | null
    viewCount: number | null
    likeCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IdeaCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    tags: number
    userId: number
    isAnonymous: number
    status: number
    visibility: number
    viewCount: number
    likeCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IdeaAvgAggregateInputType = {
    viewCount?: true
    likeCount?: true
  }

  export type IdeaSumAggregateInputType = {
    viewCount?: true
    likeCount?: true
  }

  export type IdeaMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    tags?: true
    userId?: true
    isAnonymous?: true
    status?: true
    visibility?: true
    viewCount?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    tags?: true
    userId?: true
    isAnonymous?: true
    status?: true
    visibility?: true
    viewCount?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IdeaCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    tags?: true
    userId?: true
    isAnonymous?: true
    status?: true
    visibility?: true
    viewCount?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IdeaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Idea to aggregate.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ideas
    **/
    _count?: true | IdeaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdeaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdeaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdeaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdeaMaxAggregateInputType
  }

  export type GetIdeaAggregateType<T extends IdeaAggregateArgs> = {
        [P in keyof T & keyof AggregateIdea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdea[P]>
      : GetScalarType<T[P], AggregateIdea[P]>
  }




  export type IdeaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaWhereInput
    orderBy?: IdeaOrderByWithAggregationInput | IdeaOrderByWithAggregationInput[]
    by: IdeaScalarFieldEnum[] | IdeaScalarFieldEnum
    having?: IdeaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdeaCountAggregateInputType | true
    _avg?: IdeaAvgAggregateInputType
    _sum?: IdeaSumAggregateInputType
    _min?: IdeaMinAggregateInputType
    _max?: IdeaMaxAggregateInputType
  }

  export type IdeaGroupByOutputType = {
    id: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags: string
    userId: string
    isAnonymous: boolean
    status: $Enums.IdeaStatus
    visibility: $Enums.IdeaVisibility
    viewCount: number
    likeCount: number
    createdAt: Date
    updatedAt: Date
    _count: IdeaCountAggregateOutputType | null
    _avg: IdeaAvgAggregateOutputType | null
    _sum: IdeaSumAggregateOutputType | null
    _min: IdeaMinAggregateOutputType | null
    _max: IdeaMaxAggregateOutputType | null
  }

  type GetIdeaGroupByPayload<T extends IdeaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdeaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdeaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdeaGroupByOutputType[P]>
            : GetScalarType<T[P], IdeaGroupByOutputType[P]>
        }
      >
    >


  export type IdeaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    userId?: boolean
    isAnonymous?: boolean
    status?: boolean
    visibility?: boolean
    viewCount?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    researchReports?: boolean | Idea$researchReportsArgs<ExtArgs>
    discussions?: boolean | Idea$discussionsArgs<ExtArgs>
    biddingSessions?: boolean | Idea$biddingSessionsArgs<ExtArgs>
    _count?: boolean | IdeaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    userId?: boolean
    isAnonymous?: boolean
    status?: boolean
    visibility?: boolean
    viewCount?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    userId?: boolean
    isAnonymous?: boolean
    status?: boolean
    visibility?: boolean
    viewCount?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["idea"]>

  export type IdeaSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    userId?: boolean
    isAnonymous?: boolean
    status?: boolean
    visibility?: boolean
    viewCount?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IdeaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "tags" | "userId" | "isAnonymous" | "status" | "visibility" | "viewCount" | "likeCount" | "createdAt" | "updatedAt", ExtArgs["result"]["idea"]>
  export type IdeaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    researchReports?: boolean | Idea$researchReportsArgs<ExtArgs>
    discussions?: boolean | Idea$discussionsArgs<ExtArgs>
    biddingSessions?: boolean | Idea$biddingSessionsArgs<ExtArgs>
    _count?: boolean | IdeaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IdeaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IdeaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IdeaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Idea"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      researchReports: Prisma.$ResearchReportPayload<ExtArgs>[]
      discussions: Prisma.$IdeaDiscussionPayload<ExtArgs>[]
      biddingSessions: Prisma.$BiddingSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: $Enums.IdeaCategory
      tags: string
      userId: string
      isAnonymous: boolean
      status: $Enums.IdeaStatus
      visibility: $Enums.IdeaVisibility
      viewCount: number
      likeCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["idea"]>
    composites: {}
  }

  type IdeaGetPayload<S extends boolean | null | undefined | IdeaDefaultArgs> = $Result.GetResult<Prisma.$IdeaPayload, S>

  type IdeaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdeaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdeaCountAggregateInputType | true
    }

  export interface IdeaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Idea'], meta: { name: 'Idea' } }
    /**
     * Find zero or one Idea that matches the filter.
     * @param {IdeaFindUniqueArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdeaFindUniqueArgs>(args: SelectSubset<T, IdeaFindUniqueArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Idea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdeaFindUniqueOrThrowArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdeaFindUniqueOrThrowArgs>(args: SelectSubset<T, IdeaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Idea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindFirstArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdeaFindFirstArgs>(args?: SelectSubset<T, IdeaFindFirstArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Idea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindFirstOrThrowArgs} args - Arguments to find a Idea
     * @example
     * // Get one Idea
     * const idea = await prisma.idea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdeaFindFirstOrThrowArgs>(args?: SelectSubset<T, IdeaFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ideas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ideas
     * const ideas = await prisma.idea.findMany()
     * 
     * // Get first 10 Ideas
     * const ideas = await prisma.idea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ideaWithIdOnly = await prisma.idea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdeaFindManyArgs>(args?: SelectSubset<T, IdeaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Idea.
     * @param {IdeaCreateArgs} args - Arguments to create a Idea.
     * @example
     * // Create one Idea
     * const Idea = await prisma.idea.create({
     *   data: {
     *     // ... data to create a Idea
     *   }
     * })
     * 
     */
    create<T extends IdeaCreateArgs>(args: SelectSubset<T, IdeaCreateArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ideas.
     * @param {IdeaCreateManyArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const idea = await prisma.idea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdeaCreateManyArgs>(args?: SelectSubset<T, IdeaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ideas and returns the data saved in the database.
     * @param {IdeaCreateManyAndReturnArgs} args - Arguments to create many Ideas.
     * @example
     * // Create many Ideas
     * const idea = await prisma.idea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ideas and only return the `id`
     * const ideaWithIdOnly = await prisma.idea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdeaCreateManyAndReturnArgs>(args?: SelectSubset<T, IdeaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Idea.
     * @param {IdeaDeleteArgs} args - Arguments to delete one Idea.
     * @example
     * // Delete one Idea
     * const Idea = await prisma.idea.delete({
     *   where: {
     *     // ... filter to delete one Idea
     *   }
     * })
     * 
     */
    delete<T extends IdeaDeleteArgs>(args: SelectSubset<T, IdeaDeleteArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Idea.
     * @param {IdeaUpdateArgs} args - Arguments to update one Idea.
     * @example
     * // Update one Idea
     * const idea = await prisma.idea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdeaUpdateArgs>(args: SelectSubset<T, IdeaUpdateArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ideas.
     * @param {IdeaDeleteManyArgs} args - Arguments to filter Ideas to delete.
     * @example
     * // Delete a few Ideas
     * const { count } = await prisma.idea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdeaDeleteManyArgs>(args?: SelectSubset<T, IdeaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ideas
     * const idea = await prisma.idea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdeaUpdateManyArgs>(args: SelectSubset<T, IdeaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ideas and returns the data updated in the database.
     * @param {IdeaUpdateManyAndReturnArgs} args - Arguments to update many Ideas.
     * @example
     * // Update many Ideas
     * const idea = await prisma.idea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ideas and only return the `id`
     * const ideaWithIdOnly = await prisma.idea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdeaUpdateManyAndReturnArgs>(args: SelectSubset<T, IdeaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Idea.
     * @param {IdeaUpsertArgs} args - Arguments to update or create a Idea.
     * @example
     * // Update or create a Idea
     * const idea = await prisma.idea.upsert({
     *   create: {
     *     // ... data to create a Idea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Idea we want to update
     *   }
     * })
     */
    upsert<T extends IdeaUpsertArgs>(args: SelectSubset<T, IdeaUpsertArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ideas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaCountArgs} args - Arguments to filter Ideas to count.
     * @example
     * // Count the number of Ideas
     * const count = await prisma.idea.count({
     *   where: {
     *     // ... the filter for the Ideas we want to count
     *   }
     * })
    **/
    count<T extends IdeaCountArgs>(
      args?: Subset<T, IdeaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdeaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdeaAggregateArgs>(args: Subset<T, IdeaAggregateArgs>): Prisma.PrismaPromise<GetIdeaAggregateType<T>>

    /**
     * Group by Idea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdeaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdeaGroupByArgs['orderBy'] }
        : { orderBy?: IdeaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdeaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdeaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Idea model
   */
  readonly fields: IdeaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Idea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdeaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    researchReports<T extends Idea$researchReportsArgs<ExtArgs> = {}>(args?: Subset<T, Idea$researchReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discussions<T extends Idea$discussionsArgs<ExtArgs> = {}>(args?: Subset<T, Idea$discussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    biddingSessions<T extends Idea$biddingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Idea$biddingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Idea model
   */
  interface IdeaFieldRefs {
    readonly id: FieldRef<"Idea", 'String'>
    readonly title: FieldRef<"Idea", 'String'>
    readonly description: FieldRef<"Idea", 'String'>
    readonly category: FieldRef<"Idea", 'IdeaCategory'>
    readonly tags: FieldRef<"Idea", 'String'>
    readonly userId: FieldRef<"Idea", 'String'>
    readonly isAnonymous: FieldRef<"Idea", 'Boolean'>
    readonly status: FieldRef<"Idea", 'IdeaStatus'>
    readonly visibility: FieldRef<"Idea", 'IdeaVisibility'>
    readonly viewCount: FieldRef<"Idea", 'Int'>
    readonly likeCount: FieldRef<"Idea", 'Int'>
    readonly createdAt: FieldRef<"Idea", 'DateTime'>
    readonly updatedAt: FieldRef<"Idea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Idea findUnique
   */
  export type IdeaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea findUniqueOrThrow
   */
  export type IdeaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea findFirst
   */
  export type IdeaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ideas.
     */
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea findFirstOrThrow
   */
  export type IdeaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Idea to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ideas.
     */
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea findMany
   */
  export type IdeaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter, which Ideas to fetch.
     */
    where?: IdeaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ideas to fetch.
     */
    orderBy?: IdeaOrderByWithRelationInput | IdeaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ideas.
     */
    cursor?: IdeaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ideas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ideas.
     */
    skip?: number
    distinct?: IdeaScalarFieldEnum | IdeaScalarFieldEnum[]
  }

  /**
   * Idea create
   */
  export type IdeaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The data needed to create a Idea.
     */
    data: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
  }

  /**
   * Idea createMany
   */
  export type IdeaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ideas.
     */
    data: IdeaCreateManyInput | IdeaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Idea createManyAndReturn
   */
  export type IdeaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * The data used to create many Ideas.
     */
    data: IdeaCreateManyInput | IdeaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Idea update
   */
  export type IdeaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The data needed to update a Idea.
     */
    data: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
    /**
     * Choose, which Idea to update.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea updateMany
   */
  export type IdeaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ideas.
     */
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyInput>
    /**
     * Filter which Ideas to update
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to update.
     */
    limit?: number
  }

  /**
   * Idea updateManyAndReturn
   */
  export type IdeaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * The data used to update Ideas.
     */
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyInput>
    /**
     * Filter which Ideas to update
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Idea upsert
   */
  export type IdeaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * The filter to search for the Idea to update in case it exists.
     */
    where: IdeaWhereUniqueInput
    /**
     * In case the Idea found by the `where` argument doesn't exist, create a new Idea with this data.
     */
    create: XOR<IdeaCreateInput, IdeaUncheckedCreateInput>
    /**
     * In case the Idea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdeaUpdateInput, IdeaUncheckedUpdateInput>
  }

  /**
   * Idea delete
   */
  export type IdeaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
    /**
     * Filter which Idea to delete.
     */
    where: IdeaWhereUniqueInput
  }

  /**
   * Idea deleteMany
   */
  export type IdeaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ideas to delete
     */
    where?: IdeaWhereInput
    /**
     * Limit how many Ideas to delete.
     */
    limit?: number
  }

  /**
   * Idea.researchReports
   */
  export type Idea$researchReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    where?: ResearchReportWhereInput
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    cursor?: ResearchReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchReportScalarFieldEnum | ResearchReportScalarFieldEnum[]
  }

  /**
   * Idea.discussions
   */
  export type Idea$discussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    where?: IdeaDiscussionWhereInput
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    cursor?: IdeaDiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IdeaDiscussionScalarFieldEnum | IdeaDiscussionScalarFieldEnum[]
  }

  /**
   * Idea.biddingSessions
   */
  export type Idea$biddingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    where?: BiddingSessionWhereInput
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    cursor?: BiddingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * Idea without action
   */
  export type IdeaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Idea
     */
    select?: IdeaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Idea
     */
    omit?: IdeaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaInclude<ExtArgs> | null
  }


  /**
   * Model BiddingSession
   */

  export type AggregateBiddingSession = {
    _count: BiddingSessionCountAggregateOutputType | null
    _avg: BiddingSessionAvgAggregateOutputType | null
    _sum: BiddingSessionSumAggregateOutputType | null
    _min: BiddingSessionMinAggregateOutputType | null
    _max: BiddingSessionMaxAggregateOutputType | null
  }

  export type BiddingSessionAvgAggregateOutputType = {
    startPrice: number | null
    currentHigh: number | null
    finalPrice: number | null
    enhancementScore: number | null
    participantCount: number | null
    viewerCount: number | null
    maxViewerCount: number | null
    totalInteractions: number | null
    durationSeconds: number | null
    discussionDuration: number | null
    biddingDuration: number | null
    avgResponseTime: number | null
    aiServiceCost: number | null
    userEngagementScore: number | null
    contentQualityScore: number | null
  }

  export type BiddingSessionSumAggregateOutputType = {
    startPrice: number | null
    currentHigh: number | null
    finalPrice: number | null
    enhancementScore: number | null
    participantCount: number | null
    viewerCount: number | null
    maxViewerCount: number | null
    totalInteractions: number | null
    durationSeconds: number | null
    discussionDuration: number | null
    biddingDuration: number | null
    avgResponseTime: number | null
    aiServiceCost: number | null
    userEngagementScore: number | null
    contentQualityScore: number | null
  }

  export type BiddingSessionMinAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    startPrice: number | null
    currentHigh: number | null
    winnerAgent: string | null
    winnerAgentType: string | null
    finalPrice: number | null
    status: $Enums.BiddingStatus | null
    phase: $Enums.BiddingPhase | null
    enhancedByDiscussion: boolean | null
    discussionId: string | null
    enhancementScore: number | null
    participantCount: number | null
    viewerCount: number | null
    maxViewerCount: number | null
    totalInteractions: number | null
    durationSeconds: number | null
    discussionDuration: number | null
    biddingDuration: number | null
    startedAt: Date | null
    endedAt: Date | null
    discussionStartedAt: Date | null
    biddingStartedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    avgResponseTime: number | null
    aiServiceCost: number | null
    userEngagementScore: number | null
    contentQualityScore: number | null
  }

  export type BiddingSessionMaxAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    startPrice: number | null
    currentHigh: number | null
    winnerAgent: string | null
    winnerAgentType: string | null
    finalPrice: number | null
    status: $Enums.BiddingStatus | null
    phase: $Enums.BiddingPhase | null
    enhancedByDiscussion: boolean | null
    discussionId: string | null
    enhancementScore: number | null
    participantCount: number | null
    viewerCount: number | null
    maxViewerCount: number | null
    totalInteractions: number | null
    durationSeconds: number | null
    discussionDuration: number | null
    biddingDuration: number | null
    startedAt: Date | null
    endedAt: Date | null
    discussionStartedAt: Date | null
    biddingStartedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    avgResponseTime: number | null
    aiServiceCost: number | null
    userEngagementScore: number | null
    contentQualityScore: number | null
  }

  export type BiddingSessionCountAggregateOutputType = {
    id: number
    ideaId: number
    userId: number
    startPrice: number
    currentHigh: number
    winnerAgent: number
    winnerAgentType: number
    finalPrice: number
    status: number
    phase: number
    enhancedByDiscussion: number
    discussionId: number
    enhancementScore: number
    participantCount: number
    viewerCount: number
    maxViewerCount: number
    totalInteractions: number
    durationSeconds: number
    discussionDuration: number
    biddingDuration: number
    startedAt: number
    endedAt: number
    discussionStartedAt: number
    biddingStartedAt: number
    createdAt: number
    updatedAt: number
    avgResponseTime: number
    aiServiceCost: number
    userEngagementScore: number
    contentQualityScore: number
    _all: number
  }


  export type BiddingSessionAvgAggregateInputType = {
    startPrice?: true
    currentHigh?: true
    finalPrice?: true
    enhancementScore?: true
    participantCount?: true
    viewerCount?: true
    maxViewerCount?: true
    totalInteractions?: true
    durationSeconds?: true
    discussionDuration?: true
    biddingDuration?: true
    avgResponseTime?: true
    aiServiceCost?: true
    userEngagementScore?: true
    contentQualityScore?: true
  }

  export type BiddingSessionSumAggregateInputType = {
    startPrice?: true
    currentHigh?: true
    finalPrice?: true
    enhancementScore?: true
    participantCount?: true
    viewerCount?: true
    maxViewerCount?: true
    totalInteractions?: true
    durationSeconds?: true
    discussionDuration?: true
    biddingDuration?: true
    avgResponseTime?: true
    aiServiceCost?: true
    userEngagementScore?: true
    contentQualityScore?: true
  }

  export type BiddingSessionMinAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    startPrice?: true
    currentHigh?: true
    winnerAgent?: true
    winnerAgentType?: true
    finalPrice?: true
    status?: true
    phase?: true
    enhancedByDiscussion?: true
    discussionId?: true
    enhancementScore?: true
    participantCount?: true
    viewerCount?: true
    maxViewerCount?: true
    totalInteractions?: true
    durationSeconds?: true
    discussionDuration?: true
    biddingDuration?: true
    startedAt?: true
    endedAt?: true
    discussionStartedAt?: true
    biddingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    avgResponseTime?: true
    aiServiceCost?: true
    userEngagementScore?: true
    contentQualityScore?: true
  }

  export type BiddingSessionMaxAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    startPrice?: true
    currentHigh?: true
    winnerAgent?: true
    winnerAgentType?: true
    finalPrice?: true
    status?: true
    phase?: true
    enhancedByDiscussion?: true
    discussionId?: true
    enhancementScore?: true
    participantCount?: true
    viewerCount?: true
    maxViewerCount?: true
    totalInteractions?: true
    durationSeconds?: true
    discussionDuration?: true
    biddingDuration?: true
    startedAt?: true
    endedAt?: true
    discussionStartedAt?: true
    biddingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    avgResponseTime?: true
    aiServiceCost?: true
    userEngagementScore?: true
    contentQualityScore?: true
  }

  export type BiddingSessionCountAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    startPrice?: true
    currentHigh?: true
    winnerAgent?: true
    winnerAgentType?: true
    finalPrice?: true
    status?: true
    phase?: true
    enhancedByDiscussion?: true
    discussionId?: true
    enhancementScore?: true
    participantCount?: true
    viewerCount?: true
    maxViewerCount?: true
    totalInteractions?: true
    durationSeconds?: true
    discussionDuration?: true
    biddingDuration?: true
    startedAt?: true
    endedAt?: true
    discussionStartedAt?: true
    biddingStartedAt?: true
    createdAt?: true
    updatedAt?: true
    avgResponseTime?: true
    aiServiceCost?: true
    userEngagementScore?: true
    contentQualityScore?: true
    _all?: true
  }

  export type BiddingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiddingSession to aggregate.
     */
    where?: BiddingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingSessions to fetch.
     */
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiddingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiddingSessions
    **/
    _count?: true | BiddingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiddingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiddingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiddingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiddingSessionMaxAggregateInputType
  }

  export type GetBiddingSessionAggregateType<T extends BiddingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBiddingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiddingSession[P]>
      : GetScalarType<T[P], AggregateBiddingSession[P]>
  }




  export type BiddingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingSessionWhereInput
    orderBy?: BiddingSessionOrderByWithAggregationInput | BiddingSessionOrderByWithAggregationInput[]
    by: BiddingSessionScalarFieldEnum[] | BiddingSessionScalarFieldEnum
    having?: BiddingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiddingSessionCountAggregateInputType | true
    _avg?: BiddingSessionAvgAggregateInputType
    _sum?: BiddingSessionSumAggregateInputType
    _min?: BiddingSessionMinAggregateInputType
    _max?: BiddingSessionMaxAggregateInputType
  }

  export type BiddingSessionGroupByOutputType = {
    id: string
    ideaId: string
    userId: string | null
    startPrice: number
    currentHigh: number
    winnerAgent: string | null
    winnerAgentType: string | null
    finalPrice: number | null
    status: $Enums.BiddingStatus
    phase: $Enums.BiddingPhase
    enhancedByDiscussion: boolean
    discussionId: string | null
    enhancementScore: number
    participantCount: number
    viewerCount: number
    maxViewerCount: number
    totalInteractions: number
    durationSeconds: number
    discussionDuration: number
    biddingDuration: number
    startedAt: Date | null
    endedAt: Date | null
    discussionStartedAt: Date | null
    biddingStartedAt: Date | null
    createdAt: Date
    updatedAt: Date
    avgResponseTime: number
    aiServiceCost: number
    userEngagementScore: number
    contentQualityScore: number
    _count: BiddingSessionCountAggregateOutputType | null
    _avg: BiddingSessionAvgAggregateOutputType | null
    _sum: BiddingSessionSumAggregateOutputType | null
    _min: BiddingSessionMinAggregateOutputType | null
    _max: BiddingSessionMaxAggregateOutputType | null
  }

  type GetBiddingSessionGroupByPayload<T extends BiddingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiddingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiddingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiddingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], BiddingSessionGroupByOutputType[P]>
        }
      >
    >


  export type BiddingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    startPrice?: boolean
    currentHigh?: boolean
    winnerAgent?: boolean
    winnerAgentType?: boolean
    finalPrice?: boolean
    status?: boolean
    phase?: boolean
    enhancedByDiscussion?: boolean
    discussionId?: boolean
    enhancementScore?: boolean
    participantCount?: boolean
    viewerCount?: boolean
    maxViewerCount?: boolean
    totalInteractions?: boolean
    durationSeconds?: boolean
    discussionDuration?: boolean
    biddingDuration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    discussionStartedAt?: boolean
    biddingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avgResponseTime?: boolean
    aiServiceCost?: boolean
    userEngagementScore?: boolean
    contentQualityScore?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
    bids?: boolean | BiddingSession$bidsArgs<ExtArgs>
    priceGuesses?: boolean | BiddingSession$priceGuessesArgs<ExtArgs>
    interactions?: boolean | BiddingSession$interactionsArgs<ExtArgs>
    behaviors?: boolean | BiddingSession$behaviorsArgs<ExtArgs>
    _count?: boolean | BiddingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biddingSession"]>

  export type BiddingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    startPrice?: boolean
    currentHigh?: boolean
    winnerAgent?: boolean
    winnerAgentType?: boolean
    finalPrice?: boolean
    status?: boolean
    phase?: boolean
    enhancedByDiscussion?: boolean
    discussionId?: boolean
    enhancementScore?: boolean
    participantCount?: boolean
    viewerCount?: boolean
    maxViewerCount?: boolean
    totalInteractions?: boolean
    durationSeconds?: boolean
    discussionDuration?: boolean
    biddingDuration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    discussionStartedAt?: boolean
    biddingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avgResponseTime?: boolean
    aiServiceCost?: boolean
    userEngagementScore?: boolean
    contentQualityScore?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
  }, ExtArgs["result"]["biddingSession"]>

  export type BiddingSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    startPrice?: boolean
    currentHigh?: boolean
    winnerAgent?: boolean
    winnerAgentType?: boolean
    finalPrice?: boolean
    status?: boolean
    phase?: boolean
    enhancedByDiscussion?: boolean
    discussionId?: boolean
    enhancementScore?: boolean
    participantCount?: boolean
    viewerCount?: boolean
    maxViewerCount?: boolean
    totalInteractions?: boolean
    durationSeconds?: boolean
    discussionDuration?: boolean
    biddingDuration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    discussionStartedAt?: boolean
    biddingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avgResponseTime?: boolean
    aiServiceCost?: boolean
    userEngagementScore?: boolean
    contentQualityScore?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
  }, ExtArgs["result"]["biddingSession"]>

  export type BiddingSessionSelectScalar = {
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    startPrice?: boolean
    currentHigh?: boolean
    winnerAgent?: boolean
    winnerAgentType?: boolean
    finalPrice?: boolean
    status?: boolean
    phase?: boolean
    enhancedByDiscussion?: boolean
    discussionId?: boolean
    enhancementScore?: boolean
    participantCount?: boolean
    viewerCount?: boolean
    maxViewerCount?: boolean
    totalInteractions?: boolean
    durationSeconds?: boolean
    discussionDuration?: boolean
    biddingDuration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    discussionStartedAt?: boolean
    biddingStartedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avgResponseTime?: boolean
    aiServiceCost?: boolean
    userEngagementScore?: boolean
    contentQualityScore?: boolean
  }

  export type BiddingSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ideaId" | "userId" | "startPrice" | "currentHigh" | "winnerAgent" | "winnerAgentType" | "finalPrice" | "status" | "phase" | "enhancedByDiscussion" | "discussionId" | "enhancementScore" | "participantCount" | "viewerCount" | "maxViewerCount" | "totalInteractions" | "durationSeconds" | "discussionDuration" | "biddingDuration" | "startedAt" | "endedAt" | "discussionStartedAt" | "biddingStartedAt" | "createdAt" | "updatedAt" | "avgResponseTime" | "aiServiceCost" | "userEngagementScore" | "contentQualityScore", ExtArgs["result"]["biddingSession"]>
  export type BiddingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
    bids?: boolean | BiddingSession$bidsArgs<ExtArgs>
    priceGuesses?: boolean | BiddingSession$priceGuessesArgs<ExtArgs>
    interactions?: boolean | BiddingSession$interactionsArgs<ExtArgs>
    behaviors?: boolean | BiddingSession$behaviorsArgs<ExtArgs>
    _count?: boolean | BiddingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiddingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
  }
  export type BiddingSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | BiddingSession$userArgs<ExtArgs>
    discussion?: boolean | BiddingSession$discussionArgs<ExtArgs>
  }

  export type $BiddingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiddingSession"
    objects: {
      idea: Prisma.$IdeaPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      discussion: Prisma.$IdeaDiscussionPayload<ExtArgs> | null
      bids: Prisma.$BidPayload<ExtArgs>[]
      priceGuesses: Prisma.$PriceGuessPayload<ExtArgs>[]
      interactions: Prisma.$AIInteractionPayload<ExtArgs>[]
      behaviors: Prisma.$UserBiddingBehaviorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ideaId: string
      userId: string | null
      startPrice: number
      currentHigh: number
      winnerAgent: string | null
      winnerAgentType: string | null
      finalPrice: number | null
      status: $Enums.BiddingStatus
      phase: $Enums.BiddingPhase
      enhancedByDiscussion: boolean
      discussionId: string | null
      enhancementScore: number
      participantCount: number
      viewerCount: number
      maxViewerCount: number
      totalInteractions: number
      durationSeconds: number
      discussionDuration: number
      biddingDuration: number
      startedAt: Date | null
      endedAt: Date | null
      discussionStartedAt: Date | null
      biddingStartedAt: Date | null
      createdAt: Date
      updatedAt: Date
      avgResponseTime: number
      aiServiceCost: number
      userEngagementScore: number
      contentQualityScore: number
    }, ExtArgs["result"]["biddingSession"]>
    composites: {}
  }

  type BiddingSessionGetPayload<S extends boolean | null | undefined | BiddingSessionDefaultArgs> = $Result.GetResult<Prisma.$BiddingSessionPayload, S>

  type BiddingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BiddingSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BiddingSessionCountAggregateInputType | true
    }

  export interface BiddingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiddingSession'], meta: { name: 'BiddingSession' } }
    /**
     * Find zero or one BiddingSession that matches the filter.
     * @param {BiddingSessionFindUniqueArgs} args - Arguments to find a BiddingSession
     * @example
     * // Get one BiddingSession
     * const biddingSession = await prisma.biddingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiddingSessionFindUniqueArgs>(args: SelectSubset<T, BiddingSessionFindUniqueArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BiddingSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BiddingSessionFindUniqueOrThrowArgs} args - Arguments to find a BiddingSession
     * @example
     * // Get one BiddingSession
     * const biddingSession = await prisma.biddingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiddingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, BiddingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiddingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionFindFirstArgs} args - Arguments to find a BiddingSession
     * @example
     * // Get one BiddingSession
     * const biddingSession = await prisma.biddingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiddingSessionFindFirstArgs>(args?: SelectSubset<T, BiddingSessionFindFirstArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BiddingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionFindFirstOrThrowArgs} args - Arguments to find a BiddingSession
     * @example
     * // Get one BiddingSession
     * const biddingSession = await prisma.biddingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiddingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, BiddingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BiddingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiddingSessions
     * const biddingSessions = await prisma.biddingSession.findMany()
     * 
     * // Get first 10 BiddingSessions
     * const biddingSessions = await prisma.biddingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biddingSessionWithIdOnly = await prisma.biddingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiddingSessionFindManyArgs>(args?: SelectSubset<T, BiddingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BiddingSession.
     * @param {BiddingSessionCreateArgs} args - Arguments to create a BiddingSession.
     * @example
     * // Create one BiddingSession
     * const BiddingSession = await prisma.biddingSession.create({
     *   data: {
     *     // ... data to create a BiddingSession
     *   }
     * })
     * 
     */
    create<T extends BiddingSessionCreateArgs>(args: SelectSubset<T, BiddingSessionCreateArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BiddingSessions.
     * @param {BiddingSessionCreateManyArgs} args - Arguments to create many BiddingSessions.
     * @example
     * // Create many BiddingSessions
     * const biddingSession = await prisma.biddingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiddingSessionCreateManyArgs>(args?: SelectSubset<T, BiddingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiddingSessions and returns the data saved in the database.
     * @param {BiddingSessionCreateManyAndReturnArgs} args - Arguments to create many BiddingSessions.
     * @example
     * // Create many BiddingSessions
     * const biddingSession = await prisma.biddingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiddingSessions and only return the `id`
     * const biddingSessionWithIdOnly = await prisma.biddingSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiddingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, BiddingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BiddingSession.
     * @param {BiddingSessionDeleteArgs} args - Arguments to delete one BiddingSession.
     * @example
     * // Delete one BiddingSession
     * const BiddingSession = await prisma.biddingSession.delete({
     *   where: {
     *     // ... filter to delete one BiddingSession
     *   }
     * })
     * 
     */
    delete<T extends BiddingSessionDeleteArgs>(args: SelectSubset<T, BiddingSessionDeleteArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BiddingSession.
     * @param {BiddingSessionUpdateArgs} args - Arguments to update one BiddingSession.
     * @example
     * // Update one BiddingSession
     * const biddingSession = await prisma.biddingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiddingSessionUpdateArgs>(args: SelectSubset<T, BiddingSessionUpdateArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BiddingSessions.
     * @param {BiddingSessionDeleteManyArgs} args - Arguments to filter BiddingSessions to delete.
     * @example
     * // Delete a few BiddingSessions
     * const { count } = await prisma.biddingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiddingSessionDeleteManyArgs>(args?: SelectSubset<T, BiddingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiddingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiddingSessions
     * const biddingSession = await prisma.biddingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiddingSessionUpdateManyArgs>(args: SelectSubset<T, BiddingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiddingSessions and returns the data updated in the database.
     * @param {BiddingSessionUpdateManyAndReturnArgs} args - Arguments to update many BiddingSessions.
     * @example
     * // Update many BiddingSessions
     * const biddingSession = await prisma.biddingSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BiddingSessions and only return the `id`
     * const biddingSessionWithIdOnly = await prisma.biddingSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BiddingSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, BiddingSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BiddingSession.
     * @param {BiddingSessionUpsertArgs} args - Arguments to update or create a BiddingSession.
     * @example
     * // Update or create a BiddingSession
     * const biddingSession = await prisma.biddingSession.upsert({
     *   create: {
     *     // ... data to create a BiddingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiddingSession we want to update
     *   }
     * })
     */
    upsert<T extends BiddingSessionUpsertArgs>(args: SelectSubset<T, BiddingSessionUpsertArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BiddingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionCountArgs} args - Arguments to filter BiddingSessions to count.
     * @example
     * // Count the number of BiddingSessions
     * const count = await prisma.biddingSession.count({
     *   where: {
     *     // ... the filter for the BiddingSessions we want to count
     *   }
     * })
    **/
    count<T extends BiddingSessionCountArgs>(
      args?: Subset<T, BiddingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiddingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiddingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiddingSessionAggregateArgs>(args: Subset<T, BiddingSessionAggregateArgs>): Prisma.PrismaPromise<GetBiddingSessionAggregateType<T>>

    /**
     * Group by BiddingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiddingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiddingSessionGroupByArgs['orderBy'] }
        : { orderBy?: BiddingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiddingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiddingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiddingSession model
   */
  readonly fields: BiddingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiddingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiddingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    idea<T extends IdeaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDefaultArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends BiddingSession$userArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    discussion<T extends BiddingSession$discussionArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$discussionArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bids<T extends BiddingSession$bidsArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceGuesses<T extends BiddingSession$priceGuessesArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$priceGuessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends BiddingSession$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    behaviors<T extends BiddingSession$behaviorsArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSession$behaviorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiddingSession model
   */
  interface BiddingSessionFieldRefs {
    readonly id: FieldRef<"BiddingSession", 'String'>
    readonly ideaId: FieldRef<"BiddingSession", 'String'>
    readonly userId: FieldRef<"BiddingSession", 'String'>
    readonly startPrice: FieldRef<"BiddingSession", 'Int'>
    readonly currentHigh: FieldRef<"BiddingSession", 'Int'>
    readonly winnerAgent: FieldRef<"BiddingSession", 'String'>
    readonly winnerAgentType: FieldRef<"BiddingSession", 'String'>
    readonly finalPrice: FieldRef<"BiddingSession", 'Int'>
    readonly status: FieldRef<"BiddingSession", 'BiddingStatus'>
    readonly phase: FieldRef<"BiddingSession", 'BiddingPhase'>
    readonly enhancedByDiscussion: FieldRef<"BiddingSession", 'Boolean'>
    readonly discussionId: FieldRef<"BiddingSession", 'String'>
    readonly enhancementScore: FieldRef<"BiddingSession", 'Float'>
    readonly participantCount: FieldRef<"BiddingSession", 'Int'>
    readonly viewerCount: FieldRef<"BiddingSession", 'Int'>
    readonly maxViewerCount: FieldRef<"BiddingSession", 'Int'>
    readonly totalInteractions: FieldRef<"BiddingSession", 'Int'>
    readonly durationSeconds: FieldRef<"BiddingSession", 'Int'>
    readonly discussionDuration: FieldRef<"BiddingSession", 'Int'>
    readonly biddingDuration: FieldRef<"BiddingSession", 'Int'>
    readonly startedAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly endedAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly discussionStartedAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly biddingStartedAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly createdAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"BiddingSession", 'DateTime'>
    readonly avgResponseTime: FieldRef<"BiddingSession", 'Float'>
    readonly aiServiceCost: FieldRef<"BiddingSession", 'Float'>
    readonly userEngagementScore: FieldRef<"BiddingSession", 'Float'>
    readonly contentQualityScore: FieldRef<"BiddingSession", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * BiddingSession findUnique
   */
  export type BiddingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BiddingSession to fetch.
     */
    where: BiddingSessionWhereUniqueInput
  }

  /**
   * BiddingSession findUniqueOrThrow
   */
  export type BiddingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BiddingSession to fetch.
     */
    where: BiddingSessionWhereUniqueInput
  }

  /**
   * BiddingSession findFirst
   */
  export type BiddingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BiddingSession to fetch.
     */
    where?: BiddingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingSessions to fetch.
     */
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiddingSessions.
     */
    cursor?: BiddingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiddingSessions.
     */
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * BiddingSession findFirstOrThrow
   */
  export type BiddingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BiddingSession to fetch.
     */
    where?: BiddingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingSessions to fetch.
     */
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiddingSessions.
     */
    cursor?: BiddingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiddingSessions.
     */
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * BiddingSession findMany
   */
  export type BiddingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter, which BiddingSessions to fetch.
     */
    where?: BiddingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingSessions to fetch.
     */
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiddingSessions.
     */
    cursor?: BiddingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingSessions.
     */
    skip?: number
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * BiddingSession create
   */
  export type BiddingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a BiddingSession.
     */
    data: XOR<BiddingSessionCreateInput, BiddingSessionUncheckedCreateInput>
  }

  /**
   * BiddingSession createMany
   */
  export type BiddingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiddingSessions.
     */
    data: BiddingSessionCreateManyInput | BiddingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiddingSession createManyAndReturn
   */
  export type BiddingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * The data used to create many BiddingSessions.
     */
    data: BiddingSessionCreateManyInput | BiddingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiddingSession update
   */
  export type BiddingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a BiddingSession.
     */
    data: XOR<BiddingSessionUpdateInput, BiddingSessionUncheckedUpdateInput>
    /**
     * Choose, which BiddingSession to update.
     */
    where: BiddingSessionWhereUniqueInput
  }

  /**
   * BiddingSession updateMany
   */
  export type BiddingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiddingSessions.
     */
    data: XOR<BiddingSessionUpdateManyMutationInput, BiddingSessionUncheckedUpdateManyInput>
    /**
     * Filter which BiddingSessions to update
     */
    where?: BiddingSessionWhereInput
    /**
     * Limit how many BiddingSessions to update.
     */
    limit?: number
  }

  /**
   * BiddingSession updateManyAndReturn
   */
  export type BiddingSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * The data used to update BiddingSessions.
     */
    data: XOR<BiddingSessionUpdateManyMutationInput, BiddingSessionUncheckedUpdateManyInput>
    /**
     * Filter which BiddingSessions to update
     */
    where?: BiddingSessionWhereInput
    /**
     * Limit how many BiddingSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiddingSession upsert
   */
  export type BiddingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the BiddingSession to update in case it exists.
     */
    where: BiddingSessionWhereUniqueInput
    /**
     * In case the BiddingSession found by the `where` argument doesn't exist, create a new BiddingSession with this data.
     */
    create: XOR<BiddingSessionCreateInput, BiddingSessionUncheckedCreateInput>
    /**
     * In case the BiddingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiddingSessionUpdateInput, BiddingSessionUncheckedUpdateInput>
  }

  /**
   * BiddingSession delete
   */
  export type BiddingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    /**
     * Filter which BiddingSession to delete.
     */
    where: BiddingSessionWhereUniqueInput
  }

  /**
   * BiddingSession deleteMany
   */
  export type BiddingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiddingSessions to delete
     */
    where?: BiddingSessionWhereInput
    /**
     * Limit how many BiddingSessions to delete.
     */
    limit?: number
  }

  /**
   * BiddingSession.user
   */
  export type BiddingSession$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BiddingSession.discussion
   */
  export type BiddingSession$discussionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    where?: IdeaDiscussionWhereInput
  }

  /**
   * BiddingSession.bids
   */
  export type BiddingSession$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    where?: BidWhereInput
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    cursor?: BidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * BiddingSession.priceGuesses
   */
  export type BiddingSession$priceGuessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    where?: PriceGuessWhereInput
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    cursor?: PriceGuessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceGuessScalarFieldEnum | PriceGuessScalarFieldEnum[]
  }

  /**
   * BiddingSession.interactions
   */
  export type BiddingSession$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    where?: AIInteractionWhereInput
    orderBy?: AIInteractionOrderByWithRelationInput | AIInteractionOrderByWithRelationInput[]
    cursor?: AIInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AIInteractionScalarFieldEnum | AIInteractionScalarFieldEnum[]
  }

  /**
   * BiddingSession.behaviors
   */
  export type BiddingSession$behaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    where?: UserBiddingBehaviorWhereInput
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    cursor?: UserBiddingBehaviorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBiddingBehaviorScalarFieldEnum | UserBiddingBehaviorScalarFieldEnum[]
  }

  /**
   * BiddingSession without action
   */
  export type BiddingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
  }


  /**
   * Model Bid
   */

  export type AggregateBid = {
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  export type BidAvgAggregateOutputType = {
    amount: number | null
    confidence: number | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    understandingDepth: number | null
    contextRichness: number | null
  }

  export type BidSumAggregateOutputType = {
    amount: number | null
    confidence: number | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    understandingDepth: number | null
    contextRichness: number | null
  }

  export type BidMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    agentType: string | null
    amount: number | null
    comment: string | null
    confidence: number | null
    reasoning: string | null
    emotionalState: string | null
    isScripted: boolean | null
    aiServiceUsed: string | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    understandingDepth: number | null
    contextRichness: number | null
    createdAt: Date | null
  }

  export type BidMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    agentType: string | null
    amount: number | null
    comment: string | null
    confidence: number | null
    reasoning: string | null
    emotionalState: string | null
    isScripted: boolean | null
    aiServiceUsed: string | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    understandingDepth: number | null
    contextRichness: number | null
    createdAt: Date | null
  }

  export type BidCountAggregateOutputType = {
    id: number
    sessionId: number
    agentName: number
    agentType: number
    amount: number
    comment: number
    confidence: number
    analysisData: number
    reasoning: number
    emotionalState: number
    isScripted: number
    aiServiceUsed: number
    generationCost: number
    responseTimeMs: number
    qualityScore: number
    understandingDepth: number
    contextRichness: number
    createdAt: number
    _all: number
  }


  export type BidAvgAggregateInputType = {
    amount?: true
    confidence?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    understandingDepth?: true
    contextRichness?: true
  }

  export type BidSumAggregateInputType = {
    amount?: true
    confidence?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    understandingDepth?: true
    contextRichness?: true
  }

  export type BidMinAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    amount?: true
    comment?: true
    confidence?: true
    reasoning?: true
    emotionalState?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    understandingDepth?: true
    contextRichness?: true
    createdAt?: true
  }

  export type BidMaxAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    amount?: true
    comment?: true
    confidence?: true
    reasoning?: true
    emotionalState?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    understandingDepth?: true
    contextRichness?: true
    createdAt?: true
  }

  export type BidCountAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    amount?: true
    comment?: true
    confidence?: true
    analysisData?: true
    reasoning?: true
    emotionalState?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    understandingDepth?: true
    contextRichness?: true
    createdAt?: true
    _all?: true
  }

  export type BidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bid to aggregate.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bids
    **/
    _count?: true | BidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BidMaxAggregateInputType
  }

  export type GetBidAggregateType<T extends BidAggregateArgs> = {
        [P in keyof T & keyof AggregateBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBid[P]>
      : GetScalarType<T[P], AggregateBid[P]>
  }




  export type BidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BidWhereInput
    orderBy?: BidOrderByWithAggregationInput | BidOrderByWithAggregationInput[]
    by: BidScalarFieldEnum[] | BidScalarFieldEnum
    having?: BidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BidCountAggregateInputType | true
    _avg?: BidAvgAggregateInputType
    _sum?: BidSumAggregateInputType
    _min?: BidMinAggregateInputType
    _max?: BidMaxAggregateInputType
  }

  export type BidGroupByOutputType = {
    id: string
    sessionId: string
    agentName: string
    agentType: string
    amount: number
    comment: string | null
    confidence: number | null
    analysisData: JsonValue | null
    reasoning: string | null
    emotionalState: string
    isScripted: boolean
    aiServiceUsed: string | null
    generationCost: number
    responseTimeMs: number
    qualityScore: number
    understandingDepth: number
    contextRichness: number
    createdAt: Date
    _count: BidCountAggregateOutputType | null
    _avg: BidAvgAggregateOutputType | null
    _sum: BidSumAggregateOutputType | null
    _min: BidMinAggregateOutputType | null
    _max: BidMaxAggregateOutputType | null
  }

  type GetBidGroupByPayload<T extends BidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BidGroupByOutputType[P]>
            : GetScalarType<T[P], BidGroupByOutputType[P]>
        }
      >
    >


  export type BidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    amount?: boolean
    comment?: boolean
    confidence?: boolean
    analysisData?: boolean
    reasoning?: boolean
    emotionalState?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    understandingDepth?: boolean
    contextRichness?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    amount?: boolean
    comment?: boolean
    confidence?: boolean
    analysisData?: boolean
    reasoning?: boolean
    emotionalState?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    understandingDepth?: boolean
    contextRichness?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    amount?: boolean
    comment?: boolean
    confidence?: boolean
    analysisData?: boolean
    reasoning?: boolean
    emotionalState?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    understandingDepth?: boolean
    contextRichness?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bid"]>

  export type BidSelectScalar = {
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    amount?: boolean
    comment?: boolean
    confidence?: boolean
    analysisData?: boolean
    reasoning?: boolean
    emotionalState?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    understandingDepth?: boolean
    contextRichness?: boolean
    createdAt?: boolean
  }

  export type BidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "agentName" | "agentType" | "amount" | "comment" | "confidence" | "analysisData" | "reasoning" | "emotionalState" | "isScripted" | "aiServiceUsed" | "generationCost" | "responseTimeMs" | "qualityScore" | "understandingDepth" | "contextRichness" | "createdAt", ExtArgs["result"]["bid"]>
  export type BidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }
  export type BidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }
  export type BidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }

  export type $BidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bid"
    objects: {
      session: Prisma.$BiddingSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      agentName: string
      agentType: string
      amount: number
      comment: string | null
      confidence: number | null
      analysisData: Prisma.JsonValue | null
      reasoning: string | null
      emotionalState: string
      isScripted: boolean
      aiServiceUsed: string | null
      generationCost: number
      responseTimeMs: number
      qualityScore: number
      understandingDepth: number
      contextRichness: number
      createdAt: Date
    }, ExtArgs["result"]["bid"]>
    composites: {}
  }

  type BidGetPayload<S extends boolean | null | undefined | BidDefaultArgs> = $Result.GetResult<Prisma.$BidPayload, S>

  type BidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BidCountAggregateInputType | true
    }

  export interface BidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bid'], meta: { name: 'Bid' } }
    /**
     * Find zero or one Bid that matches the filter.
     * @param {BidFindUniqueArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BidFindUniqueArgs>(args: SelectSubset<T, BidFindUniqueArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BidFindUniqueOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BidFindUniqueOrThrowArgs>(args: SelectSubset<T, BidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BidFindFirstArgs>(args?: SelectSubset<T, BidFindFirstArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindFirstOrThrowArgs} args - Arguments to find a Bid
     * @example
     * // Get one Bid
     * const bid = await prisma.bid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BidFindFirstOrThrowArgs>(args?: SelectSubset<T, BidFindFirstOrThrowArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bids
     * const bids = await prisma.bid.findMany()
     * 
     * // Get first 10 Bids
     * const bids = await prisma.bid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bidWithIdOnly = await prisma.bid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BidFindManyArgs>(args?: SelectSubset<T, BidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bid.
     * @param {BidCreateArgs} args - Arguments to create a Bid.
     * @example
     * // Create one Bid
     * const Bid = await prisma.bid.create({
     *   data: {
     *     // ... data to create a Bid
     *   }
     * })
     * 
     */
    create<T extends BidCreateArgs>(args: SelectSubset<T, BidCreateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bids.
     * @param {BidCreateManyArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BidCreateManyArgs>(args?: SelectSubset<T, BidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bids and returns the data saved in the database.
     * @param {BidCreateManyAndReturnArgs} args - Arguments to create many Bids.
     * @example
     * // Create many Bids
     * const bid = await prisma.bid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BidCreateManyAndReturnArgs>(args?: SelectSubset<T, BidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bid.
     * @param {BidDeleteArgs} args - Arguments to delete one Bid.
     * @example
     * // Delete one Bid
     * const Bid = await prisma.bid.delete({
     *   where: {
     *     // ... filter to delete one Bid
     *   }
     * })
     * 
     */
    delete<T extends BidDeleteArgs>(args: SelectSubset<T, BidDeleteArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bid.
     * @param {BidUpdateArgs} args - Arguments to update one Bid.
     * @example
     * // Update one Bid
     * const bid = await prisma.bid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BidUpdateArgs>(args: SelectSubset<T, BidUpdateArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bids.
     * @param {BidDeleteManyArgs} args - Arguments to filter Bids to delete.
     * @example
     * // Delete a few Bids
     * const { count } = await prisma.bid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BidDeleteManyArgs>(args?: SelectSubset<T, BidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BidUpdateManyArgs>(args: SelectSubset<T, BidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bids and returns the data updated in the database.
     * @param {BidUpdateManyAndReturnArgs} args - Arguments to update many Bids.
     * @example
     * // Update many Bids
     * const bid = await prisma.bid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bids and only return the `id`
     * const bidWithIdOnly = await prisma.bid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BidUpdateManyAndReturnArgs>(args: SelectSubset<T, BidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bid.
     * @param {BidUpsertArgs} args - Arguments to update or create a Bid.
     * @example
     * // Update or create a Bid
     * const bid = await prisma.bid.upsert({
     *   create: {
     *     // ... data to create a Bid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bid we want to update
     *   }
     * })
     */
    upsert<T extends BidUpsertArgs>(args: SelectSubset<T, BidUpsertArgs<ExtArgs>>): Prisma__BidClient<$Result.GetResult<Prisma.$BidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidCountArgs} args - Arguments to filter Bids to count.
     * @example
     * // Count the number of Bids
     * const count = await prisma.bid.count({
     *   where: {
     *     // ... the filter for the Bids we want to count
     *   }
     * })
    **/
    count<T extends BidCountArgs>(
      args?: Subset<T, BidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BidAggregateArgs>(args: Subset<T, BidAggregateArgs>): Prisma.PrismaPromise<GetBidAggregateType<T>>

    /**
     * Group by Bid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BidGroupByArgs['orderBy'] }
        : { orderBy?: BidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bid model
   */
  readonly fields: BidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends BiddingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSessionDefaultArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bid model
   */
  interface BidFieldRefs {
    readonly id: FieldRef<"Bid", 'String'>
    readonly sessionId: FieldRef<"Bid", 'String'>
    readonly agentName: FieldRef<"Bid", 'String'>
    readonly agentType: FieldRef<"Bid", 'String'>
    readonly amount: FieldRef<"Bid", 'Int'>
    readonly comment: FieldRef<"Bid", 'String'>
    readonly confidence: FieldRef<"Bid", 'Float'>
    readonly analysisData: FieldRef<"Bid", 'Json'>
    readonly reasoning: FieldRef<"Bid", 'String'>
    readonly emotionalState: FieldRef<"Bid", 'String'>
    readonly isScripted: FieldRef<"Bid", 'Boolean'>
    readonly aiServiceUsed: FieldRef<"Bid", 'String'>
    readonly generationCost: FieldRef<"Bid", 'Float'>
    readonly responseTimeMs: FieldRef<"Bid", 'Int'>
    readonly qualityScore: FieldRef<"Bid", 'Float'>
    readonly understandingDepth: FieldRef<"Bid", 'Float'>
    readonly contextRichness: FieldRef<"Bid", 'Float'>
    readonly createdAt: FieldRef<"Bid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bid findUnique
   */
  export type BidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findUniqueOrThrow
   */
  export type BidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid findFirst
   */
  export type BidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findFirstOrThrow
   */
  export type BidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bid to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bids.
     */
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid findMany
   */
  export type BidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter, which Bids to fetch.
     */
    where?: BidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bids to fetch.
     */
    orderBy?: BidOrderByWithRelationInput | BidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bids.
     */
    cursor?: BidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bids.
     */
    skip?: number
    distinct?: BidScalarFieldEnum | BidScalarFieldEnum[]
  }

  /**
   * Bid create
   */
  export type BidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to create a Bid.
     */
    data: XOR<BidCreateInput, BidUncheckedCreateInput>
  }

  /**
   * Bid createMany
   */
  export type BidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bid createManyAndReturn
   */
  export type BidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to create many Bids.
     */
    data: BidCreateManyInput | BidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid update
   */
  export type BidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The data needed to update a Bid.
     */
    data: XOR<BidUpdateInput, BidUncheckedUpdateInput>
    /**
     * Choose, which Bid to update.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid updateMany
   */
  export type BidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
  }

  /**
   * Bid updateManyAndReturn
   */
  export type BidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * The data used to update Bids.
     */
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyInput>
    /**
     * Filter which Bids to update
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bid upsert
   */
  export type BidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * The filter to search for the Bid to update in case it exists.
     */
    where: BidWhereUniqueInput
    /**
     * In case the Bid found by the `where` argument doesn't exist, create a new Bid with this data.
     */
    create: XOR<BidCreateInput, BidUncheckedCreateInput>
    /**
     * In case the Bid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BidUpdateInput, BidUncheckedUpdateInput>
  }

  /**
   * Bid delete
   */
  export type BidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
    /**
     * Filter which Bid to delete.
     */
    where: BidWhereUniqueInput
  }

  /**
   * Bid deleteMany
   */
  export type BidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bids to delete
     */
    where?: BidWhereInput
    /**
     * Limit how many Bids to delete.
     */
    limit?: number
  }

  /**
   * Bid without action
   */
  export type BidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bid
     */
    select?: BidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bid
     */
    omit?: BidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BidInclude<ExtArgs> | null
  }


  /**
   * Model PriceGuess
   */

  export type AggregatePriceGuess = {
    _count: PriceGuessCountAggregateOutputType | null
    _avg: PriceGuessAvgAggregateOutputType | null
    _sum: PriceGuessSumAggregateOutputType | null
    _min: PriceGuessMinAggregateOutputType | null
    _max: PriceGuessMaxAggregateOutputType | null
  }

  export type PriceGuessAvgAggregateOutputType = {
    guessedPrice: number | null
    confidence: number | null
    stakeAmount: number | null
    actualPrice: number | null
    accuracy: number | null
    reward: number | null
    predictionConfidenceBonus: number | null
    timeSpentMs: number | null
    adjustmentCount: number | null
  }

  export type PriceGuessSumAggregateOutputType = {
    guessedPrice: number | null
    confidence: number | null
    stakeAmount: number | null
    actualPrice: number | null
    accuracy: number | null
    reward: number | null
    predictionConfidenceBonus: number | null
    timeSpentMs: number | null
    adjustmentCount: number | null
  }

  export type PriceGuessMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    guessedPrice: number | null
    confidence: number | null
    stakeAmount: number | null
    actualPrice: number | null
    accuracy: number | null
    reward: number | null
    basedOnDiscussion: boolean | null
    predictionConfidenceBonus: number | null
    timeSpentMs: number | null
    adjustmentCount: number | null
    createdAt: Date | null
  }

  export type PriceGuessMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    guessedPrice: number | null
    confidence: number | null
    stakeAmount: number | null
    actualPrice: number | null
    accuracy: number | null
    reward: number | null
    basedOnDiscussion: boolean | null
    predictionConfidenceBonus: number | null
    timeSpentMs: number | null
    adjustmentCount: number | null
    createdAt: Date | null
  }

  export type PriceGuessCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    guessedPrice: number
    confidence: number
    stakeAmount: number
    actualPrice: number
    accuracy: number
    reward: number
    basedOnDiscussion: number
    predictionConfidenceBonus: number
    timeSpentMs: number
    adjustmentCount: number
    createdAt: number
    _all: number
  }


  export type PriceGuessAvgAggregateInputType = {
    guessedPrice?: true
    confidence?: true
    stakeAmount?: true
    actualPrice?: true
    accuracy?: true
    reward?: true
    predictionConfidenceBonus?: true
    timeSpentMs?: true
    adjustmentCount?: true
  }

  export type PriceGuessSumAggregateInputType = {
    guessedPrice?: true
    confidence?: true
    stakeAmount?: true
    actualPrice?: true
    accuracy?: true
    reward?: true
    predictionConfidenceBonus?: true
    timeSpentMs?: true
    adjustmentCount?: true
  }

  export type PriceGuessMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    guessedPrice?: true
    confidence?: true
    stakeAmount?: true
    actualPrice?: true
    accuracy?: true
    reward?: true
    basedOnDiscussion?: true
    predictionConfidenceBonus?: true
    timeSpentMs?: true
    adjustmentCount?: true
    createdAt?: true
  }

  export type PriceGuessMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    guessedPrice?: true
    confidence?: true
    stakeAmount?: true
    actualPrice?: true
    accuracy?: true
    reward?: true
    basedOnDiscussion?: true
    predictionConfidenceBonus?: true
    timeSpentMs?: true
    adjustmentCount?: true
    createdAt?: true
  }

  export type PriceGuessCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    guessedPrice?: true
    confidence?: true
    stakeAmount?: true
    actualPrice?: true
    accuracy?: true
    reward?: true
    basedOnDiscussion?: true
    predictionConfidenceBonus?: true
    timeSpentMs?: true
    adjustmentCount?: true
    createdAt?: true
    _all?: true
  }

  export type PriceGuessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceGuess to aggregate.
     */
    where?: PriceGuessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceGuesses to fetch.
     */
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceGuessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceGuesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceGuesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceGuesses
    **/
    _count?: true | PriceGuessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceGuessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceGuessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceGuessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceGuessMaxAggregateInputType
  }

  export type GetPriceGuessAggregateType<T extends PriceGuessAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceGuess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceGuess[P]>
      : GetScalarType<T[P], AggregatePriceGuess[P]>
  }




  export type PriceGuessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceGuessWhereInput
    orderBy?: PriceGuessOrderByWithAggregationInput | PriceGuessOrderByWithAggregationInput[]
    by: PriceGuessScalarFieldEnum[] | PriceGuessScalarFieldEnum
    having?: PriceGuessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceGuessCountAggregateInputType | true
    _avg?: PriceGuessAvgAggregateInputType
    _sum?: PriceGuessSumAggregateInputType
    _min?: PriceGuessMinAggregateInputType
    _max?: PriceGuessMaxAggregateInputType
  }

  export type PriceGuessGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    guessedPrice: number
    confidence: number
    stakeAmount: number
    actualPrice: number | null
    accuracy: number | null
    reward: number | null
    basedOnDiscussion: boolean
    predictionConfidenceBonus: number
    timeSpentMs: number | null
    adjustmentCount: number
    createdAt: Date
    _count: PriceGuessCountAggregateOutputType | null
    _avg: PriceGuessAvgAggregateOutputType | null
    _sum: PriceGuessSumAggregateOutputType | null
    _min: PriceGuessMinAggregateOutputType | null
    _max: PriceGuessMaxAggregateOutputType | null
  }

  type GetPriceGuessGroupByPayload<T extends PriceGuessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceGuessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGuessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGuessGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGuessGroupByOutputType[P]>
        }
      >
    >


  export type PriceGuessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    guessedPrice?: boolean
    confidence?: boolean
    stakeAmount?: boolean
    actualPrice?: boolean
    accuracy?: boolean
    reward?: boolean
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: boolean
    timeSpentMs?: boolean
    adjustmentCount?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceGuess"]>

  export type PriceGuessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    guessedPrice?: boolean
    confidence?: boolean
    stakeAmount?: boolean
    actualPrice?: boolean
    accuracy?: boolean
    reward?: boolean
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: boolean
    timeSpentMs?: boolean
    adjustmentCount?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceGuess"]>

  export type PriceGuessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    guessedPrice?: boolean
    confidence?: boolean
    stakeAmount?: boolean
    actualPrice?: boolean
    accuracy?: boolean
    reward?: boolean
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: boolean
    timeSpentMs?: boolean
    adjustmentCount?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceGuess"]>

  export type PriceGuessSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    guessedPrice?: boolean
    confidence?: boolean
    stakeAmount?: boolean
    actualPrice?: boolean
    accuracy?: boolean
    reward?: boolean
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: boolean
    timeSpentMs?: boolean
    adjustmentCount?: boolean
    createdAt?: boolean
  }

  export type PriceGuessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "guessedPrice" | "confidence" | "stakeAmount" | "actualPrice" | "accuracy" | "reward" | "basedOnDiscussion" | "predictionConfidenceBonus" | "timeSpentMs" | "adjustmentCount" | "createdAt", ExtArgs["result"]["priceGuess"]>
  export type PriceGuessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PriceGuessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PriceGuessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PriceGuessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceGuess"
    objects: {
      session: Prisma.$BiddingSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      guessedPrice: number
      confidence: number
      stakeAmount: number
      actualPrice: number | null
      accuracy: number | null
      reward: number | null
      basedOnDiscussion: boolean
      predictionConfidenceBonus: number
      timeSpentMs: number | null
      adjustmentCount: number
      createdAt: Date
    }, ExtArgs["result"]["priceGuess"]>
    composites: {}
  }

  type PriceGuessGetPayload<S extends boolean | null | undefined | PriceGuessDefaultArgs> = $Result.GetResult<Prisma.$PriceGuessPayload, S>

  type PriceGuessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceGuessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceGuessCountAggregateInputType | true
    }

  export interface PriceGuessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceGuess'], meta: { name: 'PriceGuess' } }
    /**
     * Find zero or one PriceGuess that matches the filter.
     * @param {PriceGuessFindUniqueArgs} args - Arguments to find a PriceGuess
     * @example
     * // Get one PriceGuess
     * const priceGuess = await prisma.priceGuess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceGuessFindUniqueArgs>(args: SelectSubset<T, PriceGuessFindUniqueArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceGuess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceGuessFindUniqueOrThrowArgs} args - Arguments to find a PriceGuess
     * @example
     * // Get one PriceGuess
     * const priceGuess = await prisma.priceGuess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceGuessFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceGuessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceGuess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessFindFirstArgs} args - Arguments to find a PriceGuess
     * @example
     * // Get one PriceGuess
     * const priceGuess = await prisma.priceGuess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceGuessFindFirstArgs>(args?: SelectSubset<T, PriceGuessFindFirstArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceGuess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessFindFirstOrThrowArgs} args - Arguments to find a PriceGuess
     * @example
     * // Get one PriceGuess
     * const priceGuess = await prisma.priceGuess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceGuessFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceGuessFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceGuesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceGuesses
     * const priceGuesses = await prisma.priceGuess.findMany()
     * 
     * // Get first 10 PriceGuesses
     * const priceGuesses = await prisma.priceGuess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceGuessWithIdOnly = await prisma.priceGuess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceGuessFindManyArgs>(args?: SelectSubset<T, PriceGuessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceGuess.
     * @param {PriceGuessCreateArgs} args - Arguments to create a PriceGuess.
     * @example
     * // Create one PriceGuess
     * const PriceGuess = await prisma.priceGuess.create({
     *   data: {
     *     // ... data to create a PriceGuess
     *   }
     * })
     * 
     */
    create<T extends PriceGuessCreateArgs>(args: SelectSubset<T, PriceGuessCreateArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceGuesses.
     * @param {PriceGuessCreateManyArgs} args - Arguments to create many PriceGuesses.
     * @example
     * // Create many PriceGuesses
     * const priceGuess = await prisma.priceGuess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceGuessCreateManyArgs>(args?: SelectSubset<T, PriceGuessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceGuesses and returns the data saved in the database.
     * @param {PriceGuessCreateManyAndReturnArgs} args - Arguments to create many PriceGuesses.
     * @example
     * // Create many PriceGuesses
     * const priceGuess = await prisma.priceGuess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceGuesses and only return the `id`
     * const priceGuessWithIdOnly = await prisma.priceGuess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceGuessCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceGuessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceGuess.
     * @param {PriceGuessDeleteArgs} args - Arguments to delete one PriceGuess.
     * @example
     * // Delete one PriceGuess
     * const PriceGuess = await prisma.priceGuess.delete({
     *   where: {
     *     // ... filter to delete one PriceGuess
     *   }
     * })
     * 
     */
    delete<T extends PriceGuessDeleteArgs>(args: SelectSubset<T, PriceGuessDeleteArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceGuess.
     * @param {PriceGuessUpdateArgs} args - Arguments to update one PriceGuess.
     * @example
     * // Update one PriceGuess
     * const priceGuess = await prisma.priceGuess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceGuessUpdateArgs>(args: SelectSubset<T, PriceGuessUpdateArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceGuesses.
     * @param {PriceGuessDeleteManyArgs} args - Arguments to filter PriceGuesses to delete.
     * @example
     * // Delete a few PriceGuesses
     * const { count } = await prisma.priceGuess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceGuessDeleteManyArgs>(args?: SelectSubset<T, PriceGuessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceGuesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceGuesses
     * const priceGuess = await prisma.priceGuess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceGuessUpdateManyArgs>(args: SelectSubset<T, PriceGuessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceGuesses and returns the data updated in the database.
     * @param {PriceGuessUpdateManyAndReturnArgs} args - Arguments to update many PriceGuesses.
     * @example
     * // Update many PriceGuesses
     * const priceGuess = await prisma.priceGuess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceGuesses and only return the `id`
     * const priceGuessWithIdOnly = await prisma.priceGuess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceGuessUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceGuessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceGuess.
     * @param {PriceGuessUpsertArgs} args - Arguments to update or create a PriceGuess.
     * @example
     * // Update or create a PriceGuess
     * const priceGuess = await prisma.priceGuess.upsert({
     *   create: {
     *     // ... data to create a PriceGuess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceGuess we want to update
     *   }
     * })
     */
    upsert<T extends PriceGuessUpsertArgs>(args: SelectSubset<T, PriceGuessUpsertArgs<ExtArgs>>): Prisma__PriceGuessClient<$Result.GetResult<Prisma.$PriceGuessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceGuesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessCountArgs} args - Arguments to filter PriceGuesses to count.
     * @example
     * // Count the number of PriceGuesses
     * const count = await prisma.priceGuess.count({
     *   where: {
     *     // ... the filter for the PriceGuesses we want to count
     *   }
     * })
    **/
    count<T extends PriceGuessCountArgs>(
      args?: Subset<T, PriceGuessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceGuessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceGuess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceGuessAggregateArgs>(args: Subset<T, PriceGuessAggregateArgs>): Prisma.PrismaPromise<GetPriceGuessAggregateType<T>>

    /**
     * Group by PriceGuess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGuessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGuessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGuessGroupByArgs['orderBy'] }
        : { orderBy?: PriceGuessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGuessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGuessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceGuess model
   */
  readonly fields: PriceGuessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceGuess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceGuessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends BiddingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSessionDefaultArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceGuess model
   */
  interface PriceGuessFieldRefs {
    readonly id: FieldRef<"PriceGuess", 'String'>
    readonly sessionId: FieldRef<"PriceGuess", 'String'>
    readonly userId: FieldRef<"PriceGuess", 'String'>
    readonly guessedPrice: FieldRef<"PriceGuess", 'Int'>
    readonly confidence: FieldRef<"PriceGuess", 'Float'>
    readonly stakeAmount: FieldRef<"PriceGuess", 'Int'>
    readonly actualPrice: FieldRef<"PriceGuess", 'Int'>
    readonly accuracy: FieldRef<"PriceGuess", 'Float'>
    readonly reward: FieldRef<"PriceGuess", 'Int'>
    readonly basedOnDiscussion: FieldRef<"PriceGuess", 'Boolean'>
    readonly predictionConfidenceBonus: FieldRef<"PriceGuess", 'Float'>
    readonly timeSpentMs: FieldRef<"PriceGuess", 'Int'>
    readonly adjustmentCount: FieldRef<"PriceGuess", 'Int'>
    readonly createdAt: FieldRef<"PriceGuess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceGuess findUnique
   */
  export type PriceGuessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter, which PriceGuess to fetch.
     */
    where: PriceGuessWhereUniqueInput
  }

  /**
   * PriceGuess findUniqueOrThrow
   */
  export type PriceGuessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter, which PriceGuess to fetch.
     */
    where: PriceGuessWhereUniqueInput
  }

  /**
   * PriceGuess findFirst
   */
  export type PriceGuessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter, which PriceGuess to fetch.
     */
    where?: PriceGuessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceGuesses to fetch.
     */
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceGuesses.
     */
    cursor?: PriceGuessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceGuesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceGuesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceGuesses.
     */
    distinct?: PriceGuessScalarFieldEnum | PriceGuessScalarFieldEnum[]
  }

  /**
   * PriceGuess findFirstOrThrow
   */
  export type PriceGuessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter, which PriceGuess to fetch.
     */
    where?: PriceGuessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceGuesses to fetch.
     */
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceGuesses.
     */
    cursor?: PriceGuessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceGuesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceGuesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceGuesses.
     */
    distinct?: PriceGuessScalarFieldEnum | PriceGuessScalarFieldEnum[]
  }

  /**
   * PriceGuess findMany
   */
  export type PriceGuessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter, which PriceGuesses to fetch.
     */
    where?: PriceGuessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceGuesses to fetch.
     */
    orderBy?: PriceGuessOrderByWithRelationInput | PriceGuessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceGuesses.
     */
    cursor?: PriceGuessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceGuesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceGuesses.
     */
    skip?: number
    distinct?: PriceGuessScalarFieldEnum | PriceGuessScalarFieldEnum[]
  }

  /**
   * PriceGuess create
   */
  export type PriceGuessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceGuess.
     */
    data: XOR<PriceGuessCreateInput, PriceGuessUncheckedCreateInput>
  }

  /**
   * PriceGuess createMany
   */
  export type PriceGuessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceGuesses.
     */
    data: PriceGuessCreateManyInput | PriceGuessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceGuess createManyAndReturn
   */
  export type PriceGuessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * The data used to create many PriceGuesses.
     */
    data: PriceGuessCreateManyInput | PriceGuessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceGuess update
   */
  export type PriceGuessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceGuess.
     */
    data: XOR<PriceGuessUpdateInput, PriceGuessUncheckedUpdateInput>
    /**
     * Choose, which PriceGuess to update.
     */
    where: PriceGuessWhereUniqueInput
  }

  /**
   * PriceGuess updateMany
   */
  export type PriceGuessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceGuesses.
     */
    data: XOR<PriceGuessUpdateManyMutationInput, PriceGuessUncheckedUpdateManyInput>
    /**
     * Filter which PriceGuesses to update
     */
    where?: PriceGuessWhereInput
    /**
     * Limit how many PriceGuesses to update.
     */
    limit?: number
  }

  /**
   * PriceGuess updateManyAndReturn
   */
  export type PriceGuessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * The data used to update PriceGuesses.
     */
    data: XOR<PriceGuessUpdateManyMutationInput, PriceGuessUncheckedUpdateManyInput>
    /**
     * Filter which PriceGuesses to update
     */
    where?: PriceGuessWhereInput
    /**
     * Limit how many PriceGuesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceGuess upsert
   */
  export type PriceGuessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceGuess to update in case it exists.
     */
    where: PriceGuessWhereUniqueInput
    /**
     * In case the PriceGuess found by the `where` argument doesn't exist, create a new PriceGuess with this data.
     */
    create: XOR<PriceGuessCreateInput, PriceGuessUncheckedCreateInput>
    /**
     * In case the PriceGuess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceGuessUpdateInput, PriceGuessUncheckedUpdateInput>
  }

  /**
   * PriceGuess delete
   */
  export type PriceGuessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
    /**
     * Filter which PriceGuess to delete.
     */
    where: PriceGuessWhereUniqueInput
  }

  /**
   * PriceGuess deleteMany
   */
  export type PriceGuessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceGuesses to delete
     */
    where?: PriceGuessWhereInput
    /**
     * Limit how many PriceGuesses to delete.
     */
    limit?: number
  }

  /**
   * PriceGuess without action
   */
  export type PriceGuessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceGuess
     */
    select?: PriceGuessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceGuess
     */
    omit?: PriceGuessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceGuessInclude<ExtArgs> | null
  }


  /**
   * Model AIInteraction
   */

  export type AggregateAIInteraction = {
    _count: AIInteractionCountAggregateOutputType | null
    _avg: AIInteractionAvgAggregateOutputType | null
    _sum: AIInteractionSumAggregateOutputType | null
    _min: AIInteractionMinAggregateOutputType | null
    _max: AIInteractionMaxAggregateOutputType | null
  }

  export type AIInteractionAvgAggregateOutputType = {
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    engagementScore: number | null
  }

  export type AIInteractionSumAggregateOutputType = {
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    engagementScore: number | null
  }

  export type AIInteractionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    agentType: string | null
    interactionType: $Enums.AIInteractionType | null
    phase: string | null
    content: string | null
    emotion: string | null
    animation: string | null
    isScripted: boolean | null
    aiServiceUsed: string | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    engagementScore: number | null
    isRandomEvent: boolean | null
    eventType: string | null
    createdAt: Date | null
  }

  export type AIInteractionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    agentType: string | null
    interactionType: $Enums.AIInteractionType | null
    phase: string | null
    content: string | null
    emotion: string | null
    animation: string | null
    isScripted: boolean | null
    aiServiceUsed: string | null
    generationCost: number | null
    responseTimeMs: number | null
    qualityScore: number | null
    engagementScore: number | null
    isRandomEvent: boolean | null
    eventType: string | null
    createdAt: Date | null
  }

  export type AIInteractionCountAggregateOutputType = {
    id: number
    sessionId: number
    agentName: number
    agentType: number
    interactionType: number
    phase: number
    content: number
    emotion: number
    animation: number
    isScripted: number
    aiServiceUsed: number
    generationCost: number
    responseTimeMs: number
    qualityScore: number
    userReactions: number
    engagementScore: number
    isRandomEvent: number
    eventType: number
    createdAt: number
    _all: number
  }


  export type AIInteractionAvgAggregateInputType = {
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    engagementScore?: true
  }

  export type AIInteractionSumAggregateInputType = {
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    engagementScore?: true
  }

  export type AIInteractionMinAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    interactionType?: true
    phase?: true
    content?: true
    emotion?: true
    animation?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    engagementScore?: true
    isRandomEvent?: true
    eventType?: true
    createdAt?: true
  }

  export type AIInteractionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    interactionType?: true
    phase?: true
    content?: true
    emotion?: true
    animation?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    engagementScore?: true
    isRandomEvent?: true
    eventType?: true
    createdAt?: true
  }

  export type AIInteractionCountAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    agentType?: true
    interactionType?: true
    phase?: true
    content?: true
    emotion?: true
    animation?: true
    isScripted?: true
    aiServiceUsed?: true
    generationCost?: true
    responseTimeMs?: true
    qualityScore?: true
    userReactions?: true
    engagementScore?: true
    isRandomEvent?: true
    eventType?: true
    createdAt?: true
    _all?: true
  }

  export type AIInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInteraction to aggregate.
     */
    where?: AIInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInteractions to fetch.
     */
    orderBy?: AIInteractionOrderByWithRelationInput | AIInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIInteractions
    **/
    _count?: true | AIInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIInteractionMaxAggregateInputType
  }

  export type GetAIInteractionAggregateType<T extends AIInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateAIInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIInteraction[P]>
      : GetScalarType<T[P], AggregateAIInteraction[P]>
  }




  export type AIInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIInteractionWhereInput
    orderBy?: AIInteractionOrderByWithAggregationInput | AIInteractionOrderByWithAggregationInput[]
    by: AIInteractionScalarFieldEnum[] | AIInteractionScalarFieldEnum
    having?: AIInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIInteractionCountAggregateInputType | true
    _avg?: AIInteractionAvgAggregateInputType
    _sum?: AIInteractionSumAggregateInputType
    _min?: AIInteractionMinAggregateInputType
    _max?: AIInteractionMaxAggregateInputType
  }

  export type AIInteractionGroupByOutputType = {
    id: string
    sessionId: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion: string
    animation: string
    isScripted: boolean
    aiServiceUsed: string | null
    generationCost: number
    responseTimeMs: number
    qualityScore: number
    userReactions: JsonValue
    engagementScore: number
    isRandomEvent: boolean
    eventType: string | null
    createdAt: Date
    _count: AIInteractionCountAggregateOutputType | null
    _avg: AIInteractionAvgAggregateOutputType | null
    _sum: AIInteractionSumAggregateOutputType | null
    _min: AIInteractionMinAggregateOutputType | null
    _max: AIInteractionMaxAggregateOutputType | null
  }

  type GetAIInteractionGroupByPayload<T extends AIInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], AIInteractionGroupByOutputType[P]>
        }
      >
    >


  export type AIInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    interactionType?: boolean
    phase?: boolean
    content?: boolean
    emotion?: boolean
    animation?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    userReactions?: boolean
    engagementScore?: boolean
    isRandomEvent?: boolean
    eventType?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInteraction"]>

  export type AIInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    interactionType?: boolean
    phase?: boolean
    content?: boolean
    emotion?: boolean
    animation?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    userReactions?: boolean
    engagementScore?: boolean
    isRandomEvent?: boolean
    eventType?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInteraction"]>

  export type AIInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    interactionType?: boolean
    phase?: boolean
    content?: boolean
    emotion?: boolean
    animation?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    userReactions?: boolean
    engagementScore?: boolean
    isRandomEvent?: boolean
    eventType?: boolean
    createdAt?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIInteraction"]>

  export type AIInteractionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    agentType?: boolean
    interactionType?: boolean
    phase?: boolean
    content?: boolean
    emotion?: boolean
    animation?: boolean
    isScripted?: boolean
    aiServiceUsed?: boolean
    generationCost?: boolean
    responseTimeMs?: boolean
    qualityScore?: boolean
    userReactions?: boolean
    engagementScore?: boolean
    isRandomEvent?: boolean
    eventType?: boolean
    createdAt?: boolean
  }

  export type AIInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "agentName" | "agentType" | "interactionType" | "phase" | "content" | "emotion" | "animation" | "isScripted" | "aiServiceUsed" | "generationCost" | "responseTimeMs" | "qualityScore" | "userReactions" | "engagementScore" | "isRandomEvent" | "eventType" | "createdAt", ExtArgs["result"]["aIInteraction"]>
  export type AIInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }
  export type AIInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }
  export type AIInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
  }

  export type $AIInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIInteraction"
    objects: {
      session: Prisma.$BiddingSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      agentName: string
      agentType: string
      interactionType: $Enums.AIInteractionType
      phase: string
      content: string
      emotion: string
      animation: string
      isScripted: boolean
      aiServiceUsed: string | null
      generationCost: number
      responseTimeMs: number
      qualityScore: number
      userReactions: Prisma.JsonValue
      engagementScore: number
      isRandomEvent: boolean
      eventType: string | null
      createdAt: Date
    }, ExtArgs["result"]["aIInteraction"]>
    composites: {}
  }

  type AIInteractionGetPayload<S extends boolean | null | undefined | AIInteractionDefaultArgs> = $Result.GetResult<Prisma.$AIInteractionPayload, S>

  type AIInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIInteractionCountAggregateInputType | true
    }

  export interface AIInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIInteraction'], meta: { name: 'AIInteraction' } }
    /**
     * Find zero or one AIInteraction that matches the filter.
     * @param {AIInteractionFindUniqueArgs} args - Arguments to find a AIInteraction
     * @example
     * // Get one AIInteraction
     * const aIInteraction = await prisma.aIInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIInteractionFindUniqueArgs>(args: SelectSubset<T, AIInteractionFindUniqueArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIInteractionFindUniqueOrThrowArgs} args - Arguments to find a AIInteraction
     * @example
     * // Get one AIInteraction
     * const aIInteraction = await prisma.aIInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, AIInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionFindFirstArgs} args - Arguments to find a AIInteraction
     * @example
     * // Get one AIInteraction
     * const aIInteraction = await prisma.aIInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIInteractionFindFirstArgs>(args?: SelectSubset<T, AIInteractionFindFirstArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionFindFirstOrThrowArgs} args - Arguments to find a AIInteraction
     * @example
     * // Get one AIInteraction
     * const aIInteraction = await prisma.aIInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, AIInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIInteractions
     * const aIInteractions = await prisma.aIInteraction.findMany()
     * 
     * // Get first 10 AIInteractions
     * const aIInteractions = await prisma.aIInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIInteractionWithIdOnly = await prisma.aIInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIInteractionFindManyArgs>(args?: SelectSubset<T, AIInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIInteraction.
     * @param {AIInteractionCreateArgs} args - Arguments to create a AIInteraction.
     * @example
     * // Create one AIInteraction
     * const AIInteraction = await prisma.aIInteraction.create({
     *   data: {
     *     // ... data to create a AIInteraction
     *   }
     * })
     * 
     */
    create<T extends AIInteractionCreateArgs>(args: SelectSubset<T, AIInteractionCreateArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIInteractions.
     * @param {AIInteractionCreateManyArgs} args - Arguments to create many AIInteractions.
     * @example
     * // Create many AIInteractions
     * const aIInteraction = await prisma.aIInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIInteractionCreateManyArgs>(args?: SelectSubset<T, AIInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIInteractions and returns the data saved in the database.
     * @param {AIInteractionCreateManyAndReturnArgs} args - Arguments to create many AIInteractions.
     * @example
     * // Create many AIInteractions
     * const aIInteraction = await prisma.aIInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIInteractions and only return the `id`
     * const aIInteractionWithIdOnly = await prisma.aIInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, AIInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIInteraction.
     * @param {AIInteractionDeleteArgs} args - Arguments to delete one AIInteraction.
     * @example
     * // Delete one AIInteraction
     * const AIInteraction = await prisma.aIInteraction.delete({
     *   where: {
     *     // ... filter to delete one AIInteraction
     *   }
     * })
     * 
     */
    delete<T extends AIInteractionDeleteArgs>(args: SelectSubset<T, AIInteractionDeleteArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIInteraction.
     * @param {AIInteractionUpdateArgs} args - Arguments to update one AIInteraction.
     * @example
     * // Update one AIInteraction
     * const aIInteraction = await prisma.aIInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIInteractionUpdateArgs>(args: SelectSubset<T, AIInteractionUpdateArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIInteractions.
     * @param {AIInteractionDeleteManyArgs} args - Arguments to filter AIInteractions to delete.
     * @example
     * // Delete a few AIInteractions
     * const { count } = await prisma.aIInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIInteractionDeleteManyArgs>(args?: SelectSubset<T, AIInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIInteractions
     * const aIInteraction = await prisma.aIInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIInteractionUpdateManyArgs>(args: SelectSubset<T, AIInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIInteractions and returns the data updated in the database.
     * @param {AIInteractionUpdateManyAndReturnArgs} args - Arguments to update many AIInteractions.
     * @example
     * // Update many AIInteractions
     * const aIInteraction = await prisma.aIInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIInteractions and only return the `id`
     * const aIInteractionWithIdOnly = await prisma.aIInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, AIInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIInteraction.
     * @param {AIInteractionUpsertArgs} args - Arguments to update or create a AIInteraction.
     * @example
     * // Update or create a AIInteraction
     * const aIInteraction = await prisma.aIInteraction.upsert({
     *   create: {
     *     // ... data to create a AIInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIInteraction we want to update
     *   }
     * })
     */
    upsert<T extends AIInteractionUpsertArgs>(args: SelectSubset<T, AIInteractionUpsertArgs<ExtArgs>>): Prisma__AIInteractionClient<$Result.GetResult<Prisma.$AIInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionCountArgs} args - Arguments to filter AIInteractions to count.
     * @example
     * // Count the number of AIInteractions
     * const count = await prisma.aIInteraction.count({
     *   where: {
     *     // ... the filter for the AIInteractions we want to count
     *   }
     * })
    **/
    count<T extends AIInteractionCountArgs>(
      args?: Subset<T, AIInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIInteractionAggregateArgs>(args: Subset<T, AIInteractionAggregateArgs>): Prisma.PrismaPromise<GetAIInteractionAggregateType<T>>

    /**
     * Group by AIInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIInteractionGroupByArgs['orderBy'] }
        : { orderBy?: AIInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIInteraction model
   */
  readonly fields: AIInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends BiddingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSessionDefaultArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIInteraction model
   */
  interface AIInteractionFieldRefs {
    readonly id: FieldRef<"AIInteraction", 'String'>
    readonly sessionId: FieldRef<"AIInteraction", 'String'>
    readonly agentName: FieldRef<"AIInteraction", 'String'>
    readonly agentType: FieldRef<"AIInteraction", 'String'>
    readonly interactionType: FieldRef<"AIInteraction", 'AIInteractionType'>
    readonly phase: FieldRef<"AIInteraction", 'String'>
    readonly content: FieldRef<"AIInteraction", 'String'>
    readonly emotion: FieldRef<"AIInteraction", 'String'>
    readonly animation: FieldRef<"AIInteraction", 'String'>
    readonly isScripted: FieldRef<"AIInteraction", 'Boolean'>
    readonly aiServiceUsed: FieldRef<"AIInteraction", 'String'>
    readonly generationCost: FieldRef<"AIInteraction", 'Float'>
    readonly responseTimeMs: FieldRef<"AIInteraction", 'Int'>
    readonly qualityScore: FieldRef<"AIInteraction", 'Float'>
    readonly userReactions: FieldRef<"AIInteraction", 'Json'>
    readonly engagementScore: FieldRef<"AIInteraction", 'Float'>
    readonly isRandomEvent: FieldRef<"AIInteraction", 'Boolean'>
    readonly eventType: FieldRef<"AIInteraction", 'String'>
    readonly createdAt: FieldRef<"AIInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIInteraction findUnique
   */
  export type AIInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AIInteraction to fetch.
     */
    where: AIInteractionWhereUniqueInput
  }

  /**
   * AIInteraction findUniqueOrThrow
   */
  export type AIInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AIInteraction to fetch.
     */
    where: AIInteractionWhereUniqueInput
  }

  /**
   * AIInteraction findFirst
   */
  export type AIInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AIInteraction to fetch.
     */
    where?: AIInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInteractions to fetch.
     */
    orderBy?: AIInteractionOrderByWithRelationInput | AIInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInteractions.
     */
    cursor?: AIInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInteractions.
     */
    distinct?: AIInteractionScalarFieldEnum | AIInteractionScalarFieldEnum[]
  }

  /**
   * AIInteraction findFirstOrThrow
   */
  export type AIInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AIInteraction to fetch.
     */
    where?: AIInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInteractions to fetch.
     */
    orderBy?: AIInteractionOrderByWithRelationInput | AIInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIInteractions.
     */
    cursor?: AIInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIInteractions.
     */
    distinct?: AIInteractionScalarFieldEnum | AIInteractionScalarFieldEnum[]
  }

  /**
   * AIInteraction findMany
   */
  export type AIInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AIInteractions to fetch.
     */
    where?: AIInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIInteractions to fetch.
     */
    orderBy?: AIInteractionOrderByWithRelationInput | AIInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIInteractions.
     */
    cursor?: AIInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIInteractions.
     */
    skip?: number
    distinct?: AIInteractionScalarFieldEnum | AIInteractionScalarFieldEnum[]
  }

  /**
   * AIInteraction create
   */
  export type AIInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a AIInteraction.
     */
    data: XOR<AIInteractionCreateInput, AIInteractionUncheckedCreateInput>
  }

  /**
   * AIInteraction createMany
   */
  export type AIInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIInteractions.
     */
    data: AIInteractionCreateManyInput | AIInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIInteraction createManyAndReturn
   */
  export type AIInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many AIInteractions.
     */
    data: AIInteractionCreateManyInput | AIInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIInteraction update
   */
  export type AIInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a AIInteraction.
     */
    data: XOR<AIInteractionUpdateInput, AIInteractionUncheckedUpdateInput>
    /**
     * Choose, which AIInteraction to update.
     */
    where: AIInteractionWhereUniqueInput
  }

  /**
   * AIInteraction updateMany
   */
  export type AIInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIInteractions.
     */
    data: XOR<AIInteractionUpdateManyMutationInput, AIInteractionUncheckedUpdateManyInput>
    /**
     * Filter which AIInteractions to update
     */
    where?: AIInteractionWhereInput
    /**
     * Limit how many AIInteractions to update.
     */
    limit?: number
  }

  /**
   * AIInteraction updateManyAndReturn
   */
  export type AIInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * The data used to update AIInteractions.
     */
    data: XOR<AIInteractionUpdateManyMutationInput, AIInteractionUncheckedUpdateManyInput>
    /**
     * Filter which AIInteractions to update
     */
    where?: AIInteractionWhereInput
    /**
     * Limit how many AIInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AIInteraction upsert
   */
  export type AIInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the AIInteraction to update in case it exists.
     */
    where: AIInteractionWhereUniqueInput
    /**
     * In case the AIInteraction found by the `where` argument doesn't exist, create a new AIInteraction with this data.
     */
    create: XOR<AIInteractionCreateInput, AIInteractionUncheckedCreateInput>
    /**
     * In case the AIInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIInteractionUpdateInput, AIInteractionUncheckedUpdateInput>
  }

  /**
   * AIInteraction delete
   */
  export type AIInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
    /**
     * Filter which AIInteraction to delete.
     */
    where: AIInteractionWhereUniqueInput
  }

  /**
   * AIInteraction deleteMany
   */
  export type AIInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIInteractions to delete
     */
    where?: AIInteractionWhereInput
    /**
     * Limit how many AIInteractions to delete.
     */
    limit?: number
  }

  /**
   * AIInteraction without action
   */
  export type AIInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIInteraction
     */
    select?: AIInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIInteraction
     */
    omit?: AIInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIInteractionInclude<ExtArgs> | null
  }


  /**
   * Model UserBiddingBehavior
   */

  export type AggregateUserBiddingBehavior = {
    _count: UserBiddingBehaviorCountAggregateOutputType | null
    _min: UserBiddingBehaviorMinAggregateOutputType | null
    _max: UserBiddingBehaviorMaxAggregateOutputType | null
  }

  export type UserBiddingBehaviorMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    actionType: $Enums.UserBiddingAction | null
    timestamp: Date | null
    phase: string | null
    agentName: string | null
  }

  export type UserBiddingBehaviorMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    actionType: $Enums.UserBiddingAction | null
    timestamp: Date | null
    phase: string | null
    agentName: string | null
  }

  export type UserBiddingBehaviorCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    actionType: number
    actionData: number
    timestamp: number
    phase: number
    agentName: number
    _all: number
  }


  export type UserBiddingBehaviorMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    actionType?: true
    timestamp?: true
    phase?: true
    agentName?: true
  }

  export type UserBiddingBehaviorMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    actionType?: true
    timestamp?: true
    phase?: true
    agentName?: true
  }

  export type UserBiddingBehaviorCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    actionType?: true
    actionData?: true
    timestamp?: true
    phase?: true
    agentName?: true
    _all?: true
  }

  export type UserBiddingBehaviorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBiddingBehavior to aggregate.
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBiddingBehaviors to fetch.
     */
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBiddingBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBiddingBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBiddingBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBiddingBehaviors
    **/
    _count?: true | UserBiddingBehaviorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBiddingBehaviorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBiddingBehaviorMaxAggregateInputType
  }

  export type GetUserBiddingBehaviorAggregateType<T extends UserBiddingBehaviorAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBiddingBehavior]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBiddingBehavior[P]>
      : GetScalarType<T[P], AggregateUserBiddingBehavior[P]>
  }




  export type UserBiddingBehaviorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBiddingBehaviorWhereInput
    orderBy?: UserBiddingBehaviorOrderByWithAggregationInput | UserBiddingBehaviorOrderByWithAggregationInput[]
    by: UserBiddingBehaviorScalarFieldEnum[] | UserBiddingBehaviorScalarFieldEnum
    having?: UserBiddingBehaviorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBiddingBehaviorCountAggregateInputType | true
    _min?: UserBiddingBehaviorMinAggregateInputType
    _max?: UserBiddingBehaviorMaxAggregateInputType
  }

  export type UserBiddingBehaviorGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    actionType: $Enums.UserBiddingAction
    actionData: JsonValue | null
    timestamp: Date
    phase: string | null
    agentName: string | null
    _count: UserBiddingBehaviorCountAggregateOutputType | null
    _min: UserBiddingBehaviorMinAggregateOutputType | null
    _max: UserBiddingBehaviorMaxAggregateOutputType | null
  }

  type GetUserBiddingBehaviorGroupByPayload<T extends UserBiddingBehaviorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBiddingBehaviorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBiddingBehaviorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBiddingBehaviorGroupByOutputType[P]>
            : GetScalarType<T[P], UserBiddingBehaviorGroupByOutputType[P]>
        }
      >
    >


  export type UserBiddingBehaviorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    actionType?: boolean
    actionData?: boolean
    timestamp?: boolean
    phase?: boolean
    agentName?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBiddingBehavior"]>

  export type UserBiddingBehaviorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    actionType?: boolean
    actionData?: boolean
    timestamp?: boolean
    phase?: boolean
    agentName?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBiddingBehavior"]>

  export type UserBiddingBehaviorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    actionType?: boolean
    actionData?: boolean
    timestamp?: boolean
    phase?: boolean
    agentName?: boolean
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBiddingBehavior"]>

  export type UserBiddingBehaviorSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    actionType?: boolean
    actionData?: boolean
    timestamp?: boolean
    phase?: boolean
    agentName?: boolean
  }

  export type UserBiddingBehaviorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "actionType" | "actionData" | "timestamp" | "phase" | "agentName", ExtArgs["result"]["userBiddingBehavior"]>
  export type UserBiddingBehaviorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBiddingBehaviorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBiddingBehaviorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | BiddingSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBiddingBehaviorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBiddingBehavior"
    objects: {
      session: Prisma.$BiddingSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      actionType: $Enums.UserBiddingAction
      actionData: Prisma.JsonValue | null
      timestamp: Date
      phase: string | null
      agentName: string | null
    }, ExtArgs["result"]["userBiddingBehavior"]>
    composites: {}
  }

  type UserBiddingBehaviorGetPayload<S extends boolean | null | undefined | UserBiddingBehaviorDefaultArgs> = $Result.GetResult<Prisma.$UserBiddingBehaviorPayload, S>

  type UserBiddingBehaviorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBiddingBehaviorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBiddingBehaviorCountAggregateInputType | true
    }

  export interface UserBiddingBehaviorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBiddingBehavior'], meta: { name: 'UserBiddingBehavior' } }
    /**
     * Find zero or one UserBiddingBehavior that matches the filter.
     * @param {UserBiddingBehaviorFindUniqueArgs} args - Arguments to find a UserBiddingBehavior
     * @example
     * // Get one UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBiddingBehaviorFindUniqueArgs>(args: SelectSubset<T, UserBiddingBehaviorFindUniqueArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBiddingBehavior that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBiddingBehaviorFindUniqueOrThrowArgs} args - Arguments to find a UserBiddingBehavior
     * @example
     * // Get one UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBiddingBehaviorFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBiddingBehaviorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBiddingBehavior that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorFindFirstArgs} args - Arguments to find a UserBiddingBehavior
     * @example
     * // Get one UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBiddingBehaviorFindFirstArgs>(args?: SelectSubset<T, UserBiddingBehaviorFindFirstArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBiddingBehavior that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorFindFirstOrThrowArgs} args - Arguments to find a UserBiddingBehavior
     * @example
     * // Get one UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBiddingBehaviorFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBiddingBehaviorFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBiddingBehaviors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBiddingBehaviors
     * const userBiddingBehaviors = await prisma.userBiddingBehavior.findMany()
     * 
     * // Get first 10 UserBiddingBehaviors
     * const userBiddingBehaviors = await prisma.userBiddingBehavior.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBiddingBehaviorWithIdOnly = await prisma.userBiddingBehavior.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBiddingBehaviorFindManyArgs>(args?: SelectSubset<T, UserBiddingBehaviorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBiddingBehavior.
     * @param {UserBiddingBehaviorCreateArgs} args - Arguments to create a UserBiddingBehavior.
     * @example
     * // Create one UserBiddingBehavior
     * const UserBiddingBehavior = await prisma.userBiddingBehavior.create({
     *   data: {
     *     // ... data to create a UserBiddingBehavior
     *   }
     * })
     * 
     */
    create<T extends UserBiddingBehaviorCreateArgs>(args: SelectSubset<T, UserBiddingBehaviorCreateArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBiddingBehaviors.
     * @param {UserBiddingBehaviorCreateManyArgs} args - Arguments to create many UserBiddingBehaviors.
     * @example
     * // Create many UserBiddingBehaviors
     * const userBiddingBehavior = await prisma.userBiddingBehavior.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBiddingBehaviorCreateManyArgs>(args?: SelectSubset<T, UserBiddingBehaviorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBiddingBehaviors and returns the data saved in the database.
     * @param {UserBiddingBehaviorCreateManyAndReturnArgs} args - Arguments to create many UserBiddingBehaviors.
     * @example
     * // Create many UserBiddingBehaviors
     * const userBiddingBehavior = await prisma.userBiddingBehavior.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBiddingBehaviors and only return the `id`
     * const userBiddingBehaviorWithIdOnly = await prisma.userBiddingBehavior.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBiddingBehaviorCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBiddingBehaviorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBiddingBehavior.
     * @param {UserBiddingBehaviorDeleteArgs} args - Arguments to delete one UserBiddingBehavior.
     * @example
     * // Delete one UserBiddingBehavior
     * const UserBiddingBehavior = await prisma.userBiddingBehavior.delete({
     *   where: {
     *     // ... filter to delete one UserBiddingBehavior
     *   }
     * })
     * 
     */
    delete<T extends UserBiddingBehaviorDeleteArgs>(args: SelectSubset<T, UserBiddingBehaviorDeleteArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBiddingBehavior.
     * @param {UserBiddingBehaviorUpdateArgs} args - Arguments to update one UserBiddingBehavior.
     * @example
     * // Update one UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBiddingBehaviorUpdateArgs>(args: SelectSubset<T, UserBiddingBehaviorUpdateArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBiddingBehaviors.
     * @param {UserBiddingBehaviorDeleteManyArgs} args - Arguments to filter UserBiddingBehaviors to delete.
     * @example
     * // Delete a few UserBiddingBehaviors
     * const { count } = await prisma.userBiddingBehavior.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBiddingBehaviorDeleteManyArgs>(args?: SelectSubset<T, UserBiddingBehaviorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBiddingBehaviors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBiddingBehaviors
     * const userBiddingBehavior = await prisma.userBiddingBehavior.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBiddingBehaviorUpdateManyArgs>(args: SelectSubset<T, UserBiddingBehaviorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBiddingBehaviors and returns the data updated in the database.
     * @param {UserBiddingBehaviorUpdateManyAndReturnArgs} args - Arguments to update many UserBiddingBehaviors.
     * @example
     * // Update many UserBiddingBehaviors
     * const userBiddingBehavior = await prisma.userBiddingBehavior.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBiddingBehaviors and only return the `id`
     * const userBiddingBehaviorWithIdOnly = await prisma.userBiddingBehavior.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBiddingBehaviorUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBiddingBehaviorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBiddingBehavior.
     * @param {UserBiddingBehaviorUpsertArgs} args - Arguments to update or create a UserBiddingBehavior.
     * @example
     * // Update or create a UserBiddingBehavior
     * const userBiddingBehavior = await prisma.userBiddingBehavior.upsert({
     *   create: {
     *     // ... data to create a UserBiddingBehavior
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBiddingBehavior we want to update
     *   }
     * })
     */
    upsert<T extends UserBiddingBehaviorUpsertArgs>(args: SelectSubset<T, UserBiddingBehaviorUpsertArgs<ExtArgs>>): Prisma__UserBiddingBehaviorClient<$Result.GetResult<Prisma.$UserBiddingBehaviorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBiddingBehaviors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorCountArgs} args - Arguments to filter UserBiddingBehaviors to count.
     * @example
     * // Count the number of UserBiddingBehaviors
     * const count = await prisma.userBiddingBehavior.count({
     *   where: {
     *     // ... the filter for the UserBiddingBehaviors we want to count
     *   }
     * })
    **/
    count<T extends UserBiddingBehaviorCountArgs>(
      args?: Subset<T, UserBiddingBehaviorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBiddingBehaviorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBiddingBehavior.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBiddingBehaviorAggregateArgs>(args: Subset<T, UserBiddingBehaviorAggregateArgs>): Prisma.PrismaPromise<GetUserBiddingBehaviorAggregateType<T>>

    /**
     * Group by UserBiddingBehavior.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBiddingBehaviorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBiddingBehaviorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBiddingBehaviorGroupByArgs['orderBy'] }
        : { orderBy?: UserBiddingBehaviorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBiddingBehaviorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBiddingBehaviorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBiddingBehavior model
   */
  readonly fields: UserBiddingBehaviorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBiddingBehavior.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBiddingBehaviorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends BiddingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiddingSessionDefaultArgs<ExtArgs>>): Prisma__BiddingSessionClient<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBiddingBehavior model
   */
  interface UserBiddingBehaviorFieldRefs {
    readonly id: FieldRef<"UserBiddingBehavior", 'String'>
    readonly sessionId: FieldRef<"UserBiddingBehavior", 'String'>
    readonly userId: FieldRef<"UserBiddingBehavior", 'String'>
    readonly actionType: FieldRef<"UserBiddingBehavior", 'UserBiddingAction'>
    readonly actionData: FieldRef<"UserBiddingBehavior", 'Json'>
    readonly timestamp: FieldRef<"UserBiddingBehavior", 'DateTime'>
    readonly phase: FieldRef<"UserBiddingBehavior", 'String'>
    readonly agentName: FieldRef<"UserBiddingBehavior", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserBiddingBehavior findUnique
   */
  export type UserBiddingBehaviorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBiddingBehavior to fetch.
     */
    where: UserBiddingBehaviorWhereUniqueInput
  }

  /**
   * UserBiddingBehavior findUniqueOrThrow
   */
  export type UserBiddingBehaviorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBiddingBehavior to fetch.
     */
    where: UserBiddingBehaviorWhereUniqueInput
  }

  /**
   * UserBiddingBehavior findFirst
   */
  export type UserBiddingBehaviorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBiddingBehavior to fetch.
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBiddingBehaviors to fetch.
     */
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBiddingBehaviors.
     */
    cursor?: UserBiddingBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBiddingBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBiddingBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBiddingBehaviors.
     */
    distinct?: UserBiddingBehaviorScalarFieldEnum | UserBiddingBehaviorScalarFieldEnum[]
  }

  /**
   * UserBiddingBehavior findFirstOrThrow
   */
  export type UserBiddingBehaviorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBiddingBehavior to fetch.
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBiddingBehaviors to fetch.
     */
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBiddingBehaviors.
     */
    cursor?: UserBiddingBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBiddingBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBiddingBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBiddingBehaviors.
     */
    distinct?: UserBiddingBehaviorScalarFieldEnum | UserBiddingBehaviorScalarFieldEnum[]
  }

  /**
   * UserBiddingBehavior findMany
   */
  export type UserBiddingBehaviorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBiddingBehaviors to fetch.
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBiddingBehaviors to fetch.
     */
    orderBy?: UserBiddingBehaviorOrderByWithRelationInput | UserBiddingBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBiddingBehaviors.
     */
    cursor?: UserBiddingBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBiddingBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBiddingBehaviors.
     */
    skip?: number
    distinct?: UserBiddingBehaviorScalarFieldEnum | UserBiddingBehaviorScalarFieldEnum[]
  }

  /**
   * UserBiddingBehavior create
   */
  export type UserBiddingBehaviorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBiddingBehavior.
     */
    data: XOR<UserBiddingBehaviorCreateInput, UserBiddingBehaviorUncheckedCreateInput>
  }

  /**
   * UserBiddingBehavior createMany
   */
  export type UserBiddingBehaviorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBiddingBehaviors.
     */
    data: UserBiddingBehaviorCreateManyInput | UserBiddingBehaviorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBiddingBehavior createManyAndReturn
   */
  export type UserBiddingBehaviorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * The data used to create many UserBiddingBehaviors.
     */
    data: UserBiddingBehaviorCreateManyInput | UserBiddingBehaviorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBiddingBehavior update
   */
  export type UserBiddingBehaviorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBiddingBehavior.
     */
    data: XOR<UserBiddingBehaviorUpdateInput, UserBiddingBehaviorUncheckedUpdateInput>
    /**
     * Choose, which UserBiddingBehavior to update.
     */
    where: UserBiddingBehaviorWhereUniqueInput
  }

  /**
   * UserBiddingBehavior updateMany
   */
  export type UserBiddingBehaviorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBiddingBehaviors.
     */
    data: XOR<UserBiddingBehaviorUpdateManyMutationInput, UserBiddingBehaviorUncheckedUpdateManyInput>
    /**
     * Filter which UserBiddingBehaviors to update
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * Limit how many UserBiddingBehaviors to update.
     */
    limit?: number
  }

  /**
   * UserBiddingBehavior updateManyAndReturn
   */
  export type UserBiddingBehaviorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * The data used to update UserBiddingBehaviors.
     */
    data: XOR<UserBiddingBehaviorUpdateManyMutationInput, UserBiddingBehaviorUncheckedUpdateManyInput>
    /**
     * Filter which UserBiddingBehaviors to update
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * Limit how many UserBiddingBehaviors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBiddingBehavior upsert
   */
  export type UserBiddingBehaviorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBiddingBehavior to update in case it exists.
     */
    where: UserBiddingBehaviorWhereUniqueInput
    /**
     * In case the UserBiddingBehavior found by the `where` argument doesn't exist, create a new UserBiddingBehavior with this data.
     */
    create: XOR<UserBiddingBehaviorCreateInput, UserBiddingBehaviorUncheckedCreateInput>
    /**
     * In case the UserBiddingBehavior was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBiddingBehaviorUpdateInput, UserBiddingBehaviorUncheckedUpdateInput>
  }

  /**
   * UserBiddingBehavior delete
   */
  export type UserBiddingBehaviorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
    /**
     * Filter which UserBiddingBehavior to delete.
     */
    where: UserBiddingBehaviorWhereUniqueInput
  }

  /**
   * UserBiddingBehavior deleteMany
   */
  export type UserBiddingBehaviorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBiddingBehaviors to delete
     */
    where?: UserBiddingBehaviorWhereInput
    /**
     * Limit how many UserBiddingBehaviors to delete.
     */
    limit?: number
  }

  /**
   * UserBiddingBehavior without action
   */
  export type UserBiddingBehaviorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBiddingBehavior
     */
    select?: UserBiddingBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBiddingBehavior
     */
    omit?: UserBiddingBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBiddingBehaviorInclude<ExtArgs> | null
  }


  /**
   * Model AIServiceUsage
   */

  export type AggregateAIServiceUsage = {
    _count: AIServiceUsageCountAggregateOutputType | null
    _avg: AIServiceUsageAvgAggregateOutputType | null
    _sum: AIServiceUsageSumAggregateOutputType | null
    _min: AIServiceUsageMinAggregateOutputType | null
    _max: AIServiceUsageMaxAggregateOutputType | null
  }

  export type AIServiceUsageAvgAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    requestCount: number | null
    totalCost: number | null
    responseTimeMs: number | null
    qualityRating: number | null
    userSatisfaction: number | null
    errorCount: number | null
    retryCount: number | null
  }

  export type AIServiceUsageSumAggregateOutputType = {
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    requestCount: number | null
    totalCost: number | null
    responseTimeMs: number | null
    qualityRating: number | null
    userSatisfaction: number | null
    errorCount: number | null
    retryCount: number | null
  }

  export type AIServiceUsageMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    serviceName: string | null
    modelName: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    requestCount: number | null
    totalCost: number | null
    responseTimeMs: number | null
    qualityRating: number | null
    userSatisfaction: number | null
    errorCount: number | null
    retryCount: number | null
    createdAt: Date | null
    date: Date | null
  }

  export type AIServiceUsageMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    agentName: string | null
    serviceName: string | null
    modelName: string | null
    promptTokens: number | null
    completionTokens: number | null
    totalTokens: number | null
    requestCount: number | null
    totalCost: number | null
    responseTimeMs: number | null
    qualityRating: number | null
    userSatisfaction: number | null
    errorCount: number | null
    retryCount: number | null
    createdAt: Date | null
    date: Date | null
  }

  export type AIServiceUsageCountAggregateOutputType = {
    id: number
    sessionId: number
    agentName: number
    serviceName: number
    modelName: number
    promptTokens: number
    completionTokens: number
    totalTokens: number
    requestCount: number
    totalCost: number
    responseTimeMs: number
    qualityRating: number
    userSatisfaction: number
    errorCount: number
    retryCount: number
    createdAt: number
    date: number
    _all: number
  }


  export type AIServiceUsageAvgAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    requestCount?: true
    totalCost?: true
    responseTimeMs?: true
    qualityRating?: true
    userSatisfaction?: true
    errorCount?: true
    retryCount?: true
  }

  export type AIServiceUsageSumAggregateInputType = {
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    requestCount?: true
    totalCost?: true
    responseTimeMs?: true
    qualityRating?: true
    userSatisfaction?: true
    errorCount?: true
    retryCount?: true
  }

  export type AIServiceUsageMinAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    serviceName?: true
    modelName?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    requestCount?: true
    totalCost?: true
    responseTimeMs?: true
    qualityRating?: true
    userSatisfaction?: true
    errorCount?: true
    retryCount?: true
    createdAt?: true
    date?: true
  }

  export type AIServiceUsageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    serviceName?: true
    modelName?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    requestCount?: true
    totalCost?: true
    responseTimeMs?: true
    qualityRating?: true
    userSatisfaction?: true
    errorCount?: true
    retryCount?: true
    createdAt?: true
    date?: true
  }

  export type AIServiceUsageCountAggregateInputType = {
    id?: true
    sessionId?: true
    agentName?: true
    serviceName?: true
    modelName?: true
    promptTokens?: true
    completionTokens?: true
    totalTokens?: true
    requestCount?: true
    totalCost?: true
    responseTimeMs?: true
    qualityRating?: true
    userSatisfaction?: true
    errorCount?: true
    retryCount?: true
    createdAt?: true
    date?: true
    _all?: true
  }

  export type AIServiceUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIServiceUsage to aggregate.
     */
    where?: AIServiceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIServiceUsages to fetch.
     */
    orderBy?: AIServiceUsageOrderByWithRelationInput | AIServiceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIServiceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIServiceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIServiceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIServiceUsages
    **/
    _count?: true | AIServiceUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIServiceUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIServiceUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIServiceUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIServiceUsageMaxAggregateInputType
  }

  export type GetAIServiceUsageAggregateType<T extends AIServiceUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateAIServiceUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIServiceUsage[P]>
      : GetScalarType<T[P], AggregateAIServiceUsage[P]>
  }




  export type AIServiceUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIServiceUsageWhereInput
    orderBy?: AIServiceUsageOrderByWithAggregationInput | AIServiceUsageOrderByWithAggregationInput[]
    by: AIServiceUsageScalarFieldEnum[] | AIServiceUsageScalarFieldEnum
    having?: AIServiceUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIServiceUsageCountAggregateInputType | true
    _avg?: AIServiceUsageAvgAggregateInputType
    _sum?: AIServiceUsageSumAggregateInputType
    _min?: AIServiceUsageMinAggregateInputType
    _max?: AIServiceUsageMaxAggregateInputType
  }

  export type AIServiceUsageGroupByOutputType = {
    id: string
    sessionId: string | null
    agentName: string | null
    serviceName: string
    modelName: string | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    requestCount: number
    totalCost: number
    responseTimeMs: number
    qualityRating: number | null
    userSatisfaction: number | null
    errorCount: number
    retryCount: number
    createdAt: Date
    date: Date
    _count: AIServiceUsageCountAggregateOutputType | null
    _avg: AIServiceUsageAvgAggregateOutputType | null
    _sum: AIServiceUsageSumAggregateOutputType | null
    _min: AIServiceUsageMinAggregateOutputType | null
    _max: AIServiceUsageMaxAggregateOutputType | null
  }

  type GetAIServiceUsageGroupByPayload<T extends AIServiceUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIServiceUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIServiceUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIServiceUsageGroupByOutputType[P]>
            : GetScalarType<T[P], AIServiceUsageGroupByOutputType[P]>
        }
      >
    >


  export type AIServiceUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    serviceName?: boolean
    modelName?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    requestCount?: boolean
    totalCost?: boolean
    responseTimeMs?: boolean
    qualityRating?: boolean
    userSatisfaction?: boolean
    errorCount?: boolean
    retryCount?: boolean
    createdAt?: boolean
    date?: boolean
  }, ExtArgs["result"]["aIServiceUsage"]>

  export type AIServiceUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    serviceName?: boolean
    modelName?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    requestCount?: boolean
    totalCost?: boolean
    responseTimeMs?: boolean
    qualityRating?: boolean
    userSatisfaction?: boolean
    errorCount?: boolean
    retryCount?: boolean
    createdAt?: boolean
    date?: boolean
  }, ExtArgs["result"]["aIServiceUsage"]>

  export type AIServiceUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    serviceName?: boolean
    modelName?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    requestCount?: boolean
    totalCost?: boolean
    responseTimeMs?: boolean
    qualityRating?: boolean
    userSatisfaction?: boolean
    errorCount?: boolean
    retryCount?: boolean
    createdAt?: boolean
    date?: boolean
  }, ExtArgs["result"]["aIServiceUsage"]>

  export type AIServiceUsageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    agentName?: boolean
    serviceName?: boolean
    modelName?: boolean
    promptTokens?: boolean
    completionTokens?: boolean
    totalTokens?: boolean
    requestCount?: boolean
    totalCost?: boolean
    responseTimeMs?: boolean
    qualityRating?: boolean
    userSatisfaction?: boolean
    errorCount?: boolean
    retryCount?: boolean
    createdAt?: boolean
    date?: boolean
  }

  export type AIServiceUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "agentName" | "serviceName" | "modelName" | "promptTokens" | "completionTokens" | "totalTokens" | "requestCount" | "totalCost" | "responseTimeMs" | "qualityRating" | "userSatisfaction" | "errorCount" | "retryCount" | "createdAt" | "date", ExtArgs["result"]["aIServiceUsage"]>

  export type $AIServiceUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIServiceUsage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string | null
      agentName: string | null
      serviceName: string
      modelName: string | null
      promptTokens: number
      completionTokens: number
      totalTokens: number
      requestCount: number
      totalCost: number
      responseTimeMs: number
      qualityRating: number | null
      userSatisfaction: number | null
      errorCount: number
      retryCount: number
      createdAt: Date
      date: Date
    }, ExtArgs["result"]["aIServiceUsage"]>
    composites: {}
  }

  type AIServiceUsageGetPayload<S extends boolean | null | undefined | AIServiceUsageDefaultArgs> = $Result.GetResult<Prisma.$AIServiceUsagePayload, S>

  type AIServiceUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIServiceUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIServiceUsageCountAggregateInputType | true
    }

  export interface AIServiceUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIServiceUsage'], meta: { name: 'AIServiceUsage' } }
    /**
     * Find zero or one AIServiceUsage that matches the filter.
     * @param {AIServiceUsageFindUniqueArgs} args - Arguments to find a AIServiceUsage
     * @example
     * // Get one AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIServiceUsageFindUniqueArgs>(args: SelectSubset<T, AIServiceUsageFindUniqueArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIServiceUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIServiceUsageFindUniqueOrThrowArgs} args - Arguments to find a AIServiceUsage
     * @example
     * // Get one AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIServiceUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, AIServiceUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIServiceUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageFindFirstArgs} args - Arguments to find a AIServiceUsage
     * @example
     * // Get one AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIServiceUsageFindFirstArgs>(args?: SelectSubset<T, AIServiceUsageFindFirstArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIServiceUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageFindFirstOrThrowArgs} args - Arguments to find a AIServiceUsage
     * @example
     * // Get one AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIServiceUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, AIServiceUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIServiceUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIServiceUsages
     * const aIServiceUsages = await prisma.aIServiceUsage.findMany()
     * 
     * // Get first 10 AIServiceUsages
     * const aIServiceUsages = await prisma.aIServiceUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIServiceUsageWithIdOnly = await prisma.aIServiceUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIServiceUsageFindManyArgs>(args?: SelectSubset<T, AIServiceUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIServiceUsage.
     * @param {AIServiceUsageCreateArgs} args - Arguments to create a AIServiceUsage.
     * @example
     * // Create one AIServiceUsage
     * const AIServiceUsage = await prisma.aIServiceUsage.create({
     *   data: {
     *     // ... data to create a AIServiceUsage
     *   }
     * })
     * 
     */
    create<T extends AIServiceUsageCreateArgs>(args: SelectSubset<T, AIServiceUsageCreateArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIServiceUsages.
     * @param {AIServiceUsageCreateManyArgs} args - Arguments to create many AIServiceUsages.
     * @example
     * // Create many AIServiceUsages
     * const aIServiceUsage = await prisma.aIServiceUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIServiceUsageCreateManyArgs>(args?: SelectSubset<T, AIServiceUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIServiceUsages and returns the data saved in the database.
     * @param {AIServiceUsageCreateManyAndReturnArgs} args - Arguments to create many AIServiceUsages.
     * @example
     * // Create many AIServiceUsages
     * const aIServiceUsage = await prisma.aIServiceUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIServiceUsages and only return the `id`
     * const aIServiceUsageWithIdOnly = await prisma.aIServiceUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIServiceUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, AIServiceUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIServiceUsage.
     * @param {AIServiceUsageDeleteArgs} args - Arguments to delete one AIServiceUsage.
     * @example
     * // Delete one AIServiceUsage
     * const AIServiceUsage = await prisma.aIServiceUsage.delete({
     *   where: {
     *     // ... filter to delete one AIServiceUsage
     *   }
     * })
     * 
     */
    delete<T extends AIServiceUsageDeleteArgs>(args: SelectSubset<T, AIServiceUsageDeleteArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIServiceUsage.
     * @param {AIServiceUsageUpdateArgs} args - Arguments to update one AIServiceUsage.
     * @example
     * // Update one AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIServiceUsageUpdateArgs>(args: SelectSubset<T, AIServiceUsageUpdateArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIServiceUsages.
     * @param {AIServiceUsageDeleteManyArgs} args - Arguments to filter AIServiceUsages to delete.
     * @example
     * // Delete a few AIServiceUsages
     * const { count } = await prisma.aIServiceUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIServiceUsageDeleteManyArgs>(args?: SelectSubset<T, AIServiceUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIServiceUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIServiceUsages
     * const aIServiceUsage = await prisma.aIServiceUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIServiceUsageUpdateManyArgs>(args: SelectSubset<T, AIServiceUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIServiceUsages and returns the data updated in the database.
     * @param {AIServiceUsageUpdateManyAndReturnArgs} args - Arguments to update many AIServiceUsages.
     * @example
     * // Update many AIServiceUsages
     * const aIServiceUsage = await prisma.aIServiceUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIServiceUsages and only return the `id`
     * const aIServiceUsageWithIdOnly = await prisma.aIServiceUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIServiceUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, AIServiceUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIServiceUsage.
     * @param {AIServiceUsageUpsertArgs} args - Arguments to update or create a AIServiceUsage.
     * @example
     * // Update or create a AIServiceUsage
     * const aIServiceUsage = await prisma.aIServiceUsage.upsert({
     *   create: {
     *     // ... data to create a AIServiceUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIServiceUsage we want to update
     *   }
     * })
     */
    upsert<T extends AIServiceUsageUpsertArgs>(args: SelectSubset<T, AIServiceUsageUpsertArgs<ExtArgs>>): Prisma__AIServiceUsageClient<$Result.GetResult<Prisma.$AIServiceUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIServiceUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageCountArgs} args - Arguments to filter AIServiceUsages to count.
     * @example
     * // Count the number of AIServiceUsages
     * const count = await prisma.aIServiceUsage.count({
     *   where: {
     *     // ... the filter for the AIServiceUsages we want to count
     *   }
     * })
    **/
    count<T extends AIServiceUsageCountArgs>(
      args?: Subset<T, AIServiceUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIServiceUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIServiceUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIServiceUsageAggregateArgs>(args: Subset<T, AIServiceUsageAggregateArgs>): Prisma.PrismaPromise<GetAIServiceUsageAggregateType<T>>

    /**
     * Group by AIServiceUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIServiceUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIServiceUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIServiceUsageGroupByArgs['orderBy'] }
        : { orderBy?: AIServiceUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIServiceUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIServiceUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIServiceUsage model
   */
  readonly fields: AIServiceUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIServiceUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIServiceUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIServiceUsage model
   */
  interface AIServiceUsageFieldRefs {
    readonly id: FieldRef<"AIServiceUsage", 'String'>
    readonly sessionId: FieldRef<"AIServiceUsage", 'String'>
    readonly agentName: FieldRef<"AIServiceUsage", 'String'>
    readonly serviceName: FieldRef<"AIServiceUsage", 'String'>
    readonly modelName: FieldRef<"AIServiceUsage", 'String'>
    readonly promptTokens: FieldRef<"AIServiceUsage", 'Int'>
    readonly completionTokens: FieldRef<"AIServiceUsage", 'Int'>
    readonly totalTokens: FieldRef<"AIServiceUsage", 'Int'>
    readonly requestCount: FieldRef<"AIServiceUsage", 'Int'>
    readonly totalCost: FieldRef<"AIServiceUsage", 'Float'>
    readonly responseTimeMs: FieldRef<"AIServiceUsage", 'Int'>
    readonly qualityRating: FieldRef<"AIServiceUsage", 'Float'>
    readonly userSatisfaction: FieldRef<"AIServiceUsage", 'Float'>
    readonly errorCount: FieldRef<"AIServiceUsage", 'Int'>
    readonly retryCount: FieldRef<"AIServiceUsage", 'Int'>
    readonly createdAt: FieldRef<"AIServiceUsage", 'DateTime'>
    readonly date: FieldRef<"AIServiceUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIServiceUsage findUnique
   */
  export type AIServiceUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIServiceUsage to fetch.
     */
    where: AIServiceUsageWhereUniqueInput
  }

  /**
   * AIServiceUsage findUniqueOrThrow
   */
  export type AIServiceUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIServiceUsage to fetch.
     */
    where: AIServiceUsageWhereUniqueInput
  }

  /**
   * AIServiceUsage findFirst
   */
  export type AIServiceUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIServiceUsage to fetch.
     */
    where?: AIServiceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIServiceUsages to fetch.
     */
    orderBy?: AIServiceUsageOrderByWithRelationInput | AIServiceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIServiceUsages.
     */
    cursor?: AIServiceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIServiceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIServiceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIServiceUsages.
     */
    distinct?: AIServiceUsageScalarFieldEnum | AIServiceUsageScalarFieldEnum[]
  }

  /**
   * AIServiceUsage findFirstOrThrow
   */
  export type AIServiceUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIServiceUsage to fetch.
     */
    where?: AIServiceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIServiceUsages to fetch.
     */
    orderBy?: AIServiceUsageOrderByWithRelationInput | AIServiceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIServiceUsages.
     */
    cursor?: AIServiceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIServiceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIServiceUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIServiceUsages.
     */
    distinct?: AIServiceUsageScalarFieldEnum | AIServiceUsageScalarFieldEnum[]
  }

  /**
   * AIServiceUsage findMany
   */
  export type AIServiceUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter, which AIServiceUsages to fetch.
     */
    where?: AIServiceUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIServiceUsages to fetch.
     */
    orderBy?: AIServiceUsageOrderByWithRelationInput | AIServiceUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIServiceUsages.
     */
    cursor?: AIServiceUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIServiceUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIServiceUsages.
     */
    skip?: number
    distinct?: AIServiceUsageScalarFieldEnum | AIServiceUsageScalarFieldEnum[]
  }

  /**
   * AIServiceUsage create
   */
  export type AIServiceUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * The data needed to create a AIServiceUsage.
     */
    data: XOR<AIServiceUsageCreateInput, AIServiceUsageUncheckedCreateInput>
  }

  /**
   * AIServiceUsage createMany
   */
  export type AIServiceUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIServiceUsages.
     */
    data: AIServiceUsageCreateManyInput | AIServiceUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIServiceUsage createManyAndReturn
   */
  export type AIServiceUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * The data used to create many AIServiceUsages.
     */
    data: AIServiceUsageCreateManyInput | AIServiceUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIServiceUsage update
   */
  export type AIServiceUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * The data needed to update a AIServiceUsage.
     */
    data: XOR<AIServiceUsageUpdateInput, AIServiceUsageUncheckedUpdateInput>
    /**
     * Choose, which AIServiceUsage to update.
     */
    where: AIServiceUsageWhereUniqueInput
  }

  /**
   * AIServiceUsage updateMany
   */
  export type AIServiceUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIServiceUsages.
     */
    data: XOR<AIServiceUsageUpdateManyMutationInput, AIServiceUsageUncheckedUpdateManyInput>
    /**
     * Filter which AIServiceUsages to update
     */
    where?: AIServiceUsageWhereInput
    /**
     * Limit how many AIServiceUsages to update.
     */
    limit?: number
  }

  /**
   * AIServiceUsage updateManyAndReturn
   */
  export type AIServiceUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * The data used to update AIServiceUsages.
     */
    data: XOR<AIServiceUsageUpdateManyMutationInput, AIServiceUsageUncheckedUpdateManyInput>
    /**
     * Filter which AIServiceUsages to update
     */
    where?: AIServiceUsageWhereInput
    /**
     * Limit how many AIServiceUsages to update.
     */
    limit?: number
  }

  /**
   * AIServiceUsage upsert
   */
  export type AIServiceUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * The filter to search for the AIServiceUsage to update in case it exists.
     */
    where: AIServiceUsageWhereUniqueInput
    /**
     * In case the AIServiceUsage found by the `where` argument doesn't exist, create a new AIServiceUsage with this data.
     */
    create: XOR<AIServiceUsageCreateInput, AIServiceUsageUncheckedCreateInput>
    /**
     * In case the AIServiceUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIServiceUsageUpdateInput, AIServiceUsageUncheckedUpdateInput>
  }

  /**
   * AIServiceUsage delete
   */
  export type AIServiceUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
    /**
     * Filter which AIServiceUsage to delete.
     */
    where: AIServiceUsageWhereUniqueInput
  }

  /**
   * AIServiceUsage deleteMany
   */
  export type AIServiceUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIServiceUsages to delete
     */
    where?: AIServiceUsageWhereInput
    /**
     * Limit how many AIServiceUsages to delete.
     */
    limit?: number
  }

  /**
   * AIServiceUsage without action
   */
  export type AIServiceUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIServiceUsage
     */
    select?: AIServiceUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIServiceUsage
     */
    omit?: AIServiceUsageOmit<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    bonusPoints: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    bonusPoints: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    achievementName: string | null
    description: string | null
    category: string | null
    bonusPoints: number | null
    earnedAt: Date | null
    isRare: boolean | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    achievementName: string | null
    description: string | null
    category: string | null
    bonusPoints: number | null
    earnedAt: Date | null
    isRare: boolean | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    achievementName: number
    description: number
    category: number
    bonusPoints: number
    earnedAt: number
    progressData: number
    isRare: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    bonusPoints?: true
  }

  export type UserAchievementSumAggregateInputType = {
    bonusPoints?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    achievementName?: true
    description?: true
    category?: true
    bonusPoints?: true
    earnedAt?: true
    isRare?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    achievementName?: true
    description?: true
    category?: true
    bonusPoints?: true
    earnedAt?: true
    isRare?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    achievementName?: true
    description?: true
    category?: true
    bonusPoints?: true
    earnedAt?: true
    progressData?: true
    isRare?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt: Date
    progressData: JsonValue | null
    isRare: boolean
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    achievementName?: boolean
    description?: boolean
    category?: boolean
    bonusPoints?: boolean
    earnedAt?: boolean
    progressData?: boolean
    isRare?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    achievementName?: boolean
    description?: boolean
    category?: boolean
    bonusPoints?: boolean
    earnedAt?: boolean
    progressData?: boolean
    isRare?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    achievementName?: boolean
    description?: boolean
    category?: boolean
    bonusPoints?: boolean
    earnedAt?: boolean
    progressData?: boolean
    isRare?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    achievementName?: boolean
    description?: boolean
    category?: boolean
    bonusPoints?: boolean
    earnedAt?: boolean
    progressData?: boolean
    isRare?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "achievementName" | "description" | "category" | "bonusPoints" | "earnedAt" | "progressData" | "isRare", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      achievementName: string
      description: string
      category: string
      bonusPoints: number
      earnedAt: Date
      progressData: Prisma.JsonValue | null
      isRare: boolean
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly achievementName: FieldRef<"UserAchievement", 'String'>
    readonly description: FieldRef<"UserAchievement", 'String'>
    readonly category: FieldRef<"UserAchievement", 'String'>
    readonly bonusPoints: FieldRef<"UserAchievement", 'Int'>
    readonly earnedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly progressData: FieldRef<"UserAchievement", 'Json'>
    readonly isRare: FieldRef<"UserAchievement", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model ResearchReport
   */

  export type AggregateResearchReport = {
    _count: ResearchReportCountAggregateOutputType | null
    _avg: ResearchReportAvgAggregateOutputType | null
    _sum: ResearchReportSumAggregateOutputType | null
    _min: ResearchReportMinAggregateOutputType | null
    _max: ResearchReportMaxAggregateOutputType | null
  }

  export type ResearchReportAvgAggregateOutputType = {
    progress: number | null
    creditsCost: number | null
  }

  export type ResearchReportSumAggregateOutputType = {
    progress: number | null
    creditsCost: number | null
  }

  export type ResearchReportMinAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    summary: string | null
    status: $Enums.ReportStatus | null
    progress: number | null
    creditsCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ResearchReportMaxAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    summary: string | null
    status: $Enums.ReportStatus | null
    progress: number | null
    creditsCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type ResearchReportCountAggregateOutputType = {
    id: number
    ideaId: number
    userId: number
    reportData: number
    summary: number
    basicAnalysis: number
    researchMethods: number
    dataSources: number
    mvpGuidance: number
    businessModel: number
    status: number
    progress: number
    creditsCost: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type ResearchReportAvgAggregateInputType = {
    progress?: true
    creditsCost?: true
  }

  export type ResearchReportSumAggregateInputType = {
    progress?: true
    creditsCost?: true
  }

  export type ResearchReportMinAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    summary?: true
    status?: true
    progress?: true
    creditsCost?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ResearchReportMaxAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    summary?: true
    status?: true
    progress?: true
    creditsCost?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type ResearchReportCountAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    reportData?: true
    summary?: true
    basicAnalysis?: true
    researchMethods?: true
    dataSources?: true
    mvpGuidance?: true
    businessModel?: true
    status?: true
    progress?: true
    creditsCost?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type ResearchReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchReport to aggregate.
     */
    where?: ResearchReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchReports to fetch.
     */
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchReports
    **/
    _count?: true | ResearchReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchReportMaxAggregateInputType
  }

  export type GetResearchReportAggregateType<T extends ResearchReportAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchReport[P]>
      : GetScalarType<T[P], AggregateResearchReport[P]>
  }




  export type ResearchReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchReportWhereInput
    orderBy?: ResearchReportOrderByWithAggregationInput | ResearchReportOrderByWithAggregationInput[]
    by: ResearchReportScalarFieldEnum[] | ResearchReportScalarFieldEnum
    having?: ResearchReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchReportCountAggregateInputType | true
    _avg?: ResearchReportAvgAggregateInputType
    _sum?: ResearchReportSumAggregateInputType
    _min?: ResearchReportMinAggregateInputType
    _max?: ResearchReportMaxAggregateInputType
  }

  export type ResearchReportGroupByOutputType = {
    id: string
    ideaId: string
    userId: string
    reportData: JsonValue
    summary: string | null
    basicAnalysis: JsonValue | null
    researchMethods: JsonValue | null
    dataSources: JsonValue | null
    mvpGuidance: JsonValue | null
    businessModel: JsonValue | null
    status: $Enums.ReportStatus
    progress: number
    creditsCost: number
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: ResearchReportCountAggregateOutputType | null
    _avg: ResearchReportAvgAggregateOutputType | null
    _sum: ResearchReportSumAggregateOutputType | null
    _min: ResearchReportMinAggregateOutputType | null
    _max: ResearchReportMaxAggregateOutputType | null
  }

  type GetResearchReportGroupByPayload<T extends ResearchReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchReportGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchReportGroupByOutputType[P]>
        }
      >
    >


  export type ResearchReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    reportData?: boolean
    summary?: boolean
    basicAnalysis?: boolean
    researchMethods?: boolean
    dataSources?: boolean
    mvpGuidance?: boolean
    businessModel?: boolean
    status?: boolean
    progress?: boolean
    creditsCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchReport"]>

  export type ResearchReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    reportData?: boolean
    summary?: boolean
    basicAnalysis?: boolean
    researchMethods?: boolean
    dataSources?: boolean
    mvpGuidance?: boolean
    businessModel?: boolean
    status?: boolean
    progress?: boolean
    creditsCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchReport"]>

  export type ResearchReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    reportData?: boolean
    summary?: boolean
    basicAnalysis?: boolean
    researchMethods?: boolean
    dataSources?: boolean
    mvpGuidance?: boolean
    businessModel?: boolean
    status?: boolean
    progress?: boolean
    creditsCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchReport"]>

  export type ResearchReportSelectScalar = {
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    reportData?: boolean
    summary?: boolean
    basicAnalysis?: boolean
    researchMethods?: boolean
    dataSources?: boolean
    mvpGuidance?: boolean
    businessModel?: boolean
    status?: boolean
    progress?: boolean
    creditsCost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type ResearchReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ideaId" | "userId" | "reportData" | "summary" | "basicAnalysis" | "researchMethods" | "dataSources" | "mvpGuidance" | "businessModel" | "status" | "progress" | "creditsCost" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["researchReport"]>
  export type ResearchReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResearchReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResearchReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResearchReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchReport"
    objects: {
      idea: Prisma.$IdeaPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ideaId: string
      userId: string
      reportData: Prisma.JsonValue
      summary: string | null
      basicAnalysis: Prisma.JsonValue | null
      researchMethods: Prisma.JsonValue | null
      dataSources: Prisma.JsonValue | null
      mvpGuidance: Prisma.JsonValue | null
      businessModel: Prisma.JsonValue | null
      status: $Enums.ReportStatus
      progress: number
      creditsCost: number
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["researchReport"]>
    composites: {}
  }

  type ResearchReportGetPayload<S extends boolean | null | undefined | ResearchReportDefaultArgs> = $Result.GetResult<Prisma.$ResearchReportPayload, S>

  type ResearchReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchReportCountAggregateInputType | true
    }

  export interface ResearchReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchReport'], meta: { name: 'ResearchReport' } }
    /**
     * Find zero or one ResearchReport that matches the filter.
     * @param {ResearchReportFindUniqueArgs} args - Arguments to find a ResearchReport
     * @example
     * // Get one ResearchReport
     * const researchReport = await prisma.researchReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchReportFindUniqueArgs>(args: SelectSubset<T, ResearchReportFindUniqueArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResearchReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchReportFindUniqueOrThrowArgs} args - Arguments to find a ResearchReport
     * @example
     * // Get one ResearchReport
     * const researchReport = await prisma.researchReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportFindFirstArgs} args - Arguments to find a ResearchReport
     * @example
     * // Get one ResearchReport
     * const researchReport = await prisma.researchReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchReportFindFirstArgs>(args?: SelectSubset<T, ResearchReportFindFirstArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportFindFirstOrThrowArgs} args - Arguments to find a ResearchReport
     * @example
     * // Get one ResearchReport
     * const researchReport = await prisma.researchReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResearchReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchReports
     * const researchReports = await prisma.researchReport.findMany()
     * 
     * // Get first 10 ResearchReports
     * const researchReports = await prisma.researchReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchReportWithIdOnly = await prisma.researchReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchReportFindManyArgs>(args?: SelectSubset<T, ResearchReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResearchReport.
     * @param {ResearchReportCreateArgs} args - Arguments to create a ResearchReport.
     * @example
     * // Create one ResearchReport
     * const ResearchReport = await prisma.researchReport.create({
     *   data: {
     *     // ... data to create a ResearchReport
     *   }
     * })
     * 
     */
    create<T extends ResearchReportCreateArgs>(args: SelectSubset<T, ResearchReportCreateArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResearchReports.
     * @param {ResearchReportCreateManyArgs} args - Arguments to create many ResearchReports.
     * @example
     * // Create many ResearchReports
     * const researchReport = await prisma.researchReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchReportCreateManyArgs>(args?: SelectSubset<T, ResearchReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchReports and returns the data saved in the database.
     * @param {ResearchReportCreateManyAndReturnArgs} args - Arguments to create many ResearchReports.
     * @example
     * // Create many ResearchReports
     * const researchReport = await prisma.researchReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchReports and only return the `id`
     * const researchReportWithIdOnly = await prisma.researchReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResearchReport.
     * @param {ResearchReportDeleteArgs} args - Arguments to delete one ResearchReport.
     * @example
     * // Delete one ResearchReport
     * const ResearchReport = await prisma.researchReport.delete({
     *   where: {
     *     // ... filter to delete one ResearchReport
     *   }
     * })
     * 
     */
    delete<T extends ResearchReportDeleteArgs>(args: SelectSubset<T, ResearchReportDeleteArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResearchReport.
     * @param {ResearchReportUpdateArgs} args - Arguments to update one ResearchReport.
     * @example
     * // Update one ResearchReport
     * const researchReport = await prisma.researchReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchReportUpdateArgs>(args: SelectSubset<T, ResearchReportUpdateArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResearchReports.
     * @param {ResearchReportDeleteManyArgs} args - Arguments to filter ResearchReports to delete.
     * @example
     * // Delete a few ResearchReports
     * const { count } = await prisma.researchReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchReportDeleteManyArgs>(args?: SelectSubset<T, ResearchReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchReports
     * const researchReport = await prisma.researchReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchReportUpdateManyArgs>(args: SelectSubset<T, ResearchReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchReports and returns the data updated in the database.
     * @param {ResearchReportUpdateManyAndReturnArgs} args - Arguments to update many ResearchReports.
     * @example
     * // Update many ResearchReports
     * const researchReport = await prisma.researchReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResearchReports and only return the `id`
     * const researchReportWithIdOnly = await prisma.researchReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResearchReport.
     * @param {ResearchReportUpsertArgs} args - Arguments to update or create a ResearchReport.
     * @example
     * // Update or create a ResearchReport
     * const researchReport = await prisma.researchReport.upsert({
     *   create: {
     *     // ... data to create a ResearchReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchReport we want to update
     *   }
     * })
     */
    upsert<T extends ResearchReportUpsertArgs>(args: SelectSubset<T, ResearchReportUpsertArgs<ExtArgs>>): Prisma__ResearchReportClient<$Result.GetResult<Prisma.$ResearchReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResearchReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportCountArgs} args - Arguments to filter ResearchReports to count.
     * @example
     * // Count the number of ResearchReports
     * const count = await prisma.researchReport.count({
     *   where: {
     *     // ... the filter for the ResearchReports we want to count
     *   }
     * })
    **/
    count<T extends ResearchReportCountArgs>(
      args?: Subset<T, ResearchReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchReportAggregateArgs>(args: Subset<T, ResearchReportAggregateArgs>): Prisma.PrismaPromise<GetResearchReportAggregateType<T>>

    /**
     * Group by ResearchReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchReportGroupByArgs['orderBy'] }
        : { orderBy?: ResearchReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchReport model
   */
  readonly fields: ResearchReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    idea<T extends IdeaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDefaultArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchReport model
   */
  interface ResearchReportFieldRefs {
    readonly id: FieldRef<"ResearchReport", 'String'>
    readonly ideaId: FieldRef<"ResearchReport", 'String'>
    readonly userId: FieldRef<"ResearchReport", 'String'>
    readonly reportData: FieldRef<"ResearchReport", 'Json'>
    readonly summary: FieldRef<"ResearchReport", 'String'>
    readonly basicAnalysis: FieldRef<"ResearchReport", 'Json'>
    readonly researchMethods: FieldRef<"ResearchReport", 'Json'>
    readonly dataSources: FieldRef<"ResearchReport", 'Json'>
    readonly mvpGuidance: FieldRef<"ResearchReport", 'Json'>
    readonly businessModel: FieldRef<"ResearchReport", 'Json'>
    readonly status: FieldRef<"ResearchReport", 'ReportStatus'>
    readonly progress: FieldRef<"ResearchReport", 'Int'>
    readonly creditsCost: FieldRef<"ResearchReport", 'Int'>
    readonly createdAt: FieldRef<"ResearchReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchReport", 'DateTime'>
    readonly completedAt: FieldRef<"ResearchReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResearchReport findUnique
   */
  export type ResearchReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter, which ResearchReport to fetch.
     */
    where: ResearchReportWhereUniqueInput
  }

  /**
   * ResearchReport findUniqueOrThrow
   */
  export type ResearchReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter, which ResearchReport to fetch.
     */
    where: ResearchReportWhereUniqueInput
  }

  /**
   * ResearchReport findFirst
   */
  export type ResearchReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter, which ResearchReport to fetch.
     */
    where?: ResearchReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchReports to fetch.
     */
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchReports.
     */
    cursor?: ResearchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchReports.
     */
    distinct?: ResearchReportScalarFieldEnum | ResearchReportScalarFieldEnum[]
  }

  /**
   * ResearchReport findFirstOrThrow
   */
  export type ResearchReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter, which ResearchReport to fetch.
     */
    where?: ResearchReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchReports to fetch.
     */
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchReports.
     */
    cursor?: ResearchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchReports.
     */
    distinct?: ResearchReportScalarFieldEnum | ResearchReportScalarFieldEnum[]
  }

  /**
   * ResearchReport findMany
   */
  export type ResearchReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter, which ResearchReports to fetch.
     */
    where?: ResearchReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchReports to fetch.
     */
    orderBy?: ResearchReportOrderByWithRelationInput | ResearchReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchReports.
     */
    cursor?: ResearchReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchReports.
     */
    skip?: number
    distinct?: ResearchReportScalarFieldEnum | ResearchReportScalarFieldEnum[]
  }

  /**
   * ResearchReport create
   */
  export type ResearchReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchReport.
     */
    data: XOR<ResearchReportCreateInput, ResearchReportUncheckedCreateInput>
  }

  /**
   * ResearchReport createMany
   */
  export type ResearchReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchReports.
     */
    data: ResearchReportCreateManyInput | ResearchReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchReport createManyAndReturn
   */
  export type ResearchReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * The data used to create many ResearchReports.
     */
    data: ResearchReportCreateManyInput | ResearchReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchReport update
   */
  export type ResearchReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchReport.
     */
    data: XOR<ResearchReportUpdateInput, ResearchReportUncheckedUpdateInput>
    /**
     * Choose, which ResearchReport to update.
     */
    where: ResearchReportWhereUniqueInput
  }

  /**
   * ResearchReport updateMany
   */
  export type ResearchReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchReports.
     */
    data: XOR<ResearchReportUpdateManyMutationInput, ResearchReportUncheckedUpdateManyInput>
    /**
     * Filter which ResearchReports to update
     */
    where?: ResearchReportWhereInput
    /**
     * Limit how many ResearchReports to update.
     */
    limit?: number
  }

  /**
   * ResearchReport updateManyAndReturn
   */
  export type ResearchReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * The data used to update ResearchReports.
     */
    data: XOR<ResearchReportUpdateManyMutationInput, ResearchReportUncheckedUpdateManyInput>
    /**
     * Filter which ResearchReports to update
     */
    where?: ResearchReportWhereInput
    /**
     * Limit how many ResearchReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchReport upsert
   */
  export type ResearchReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchReport to update in case it exists.
     */
    where: ResearchReportWhereUniqueInput
    /**
     * In case the ResearchReport found by the `where` argument doesn't exist, create a new ResearchReport with this data.
     */
    create: XOR<ResearchReportCreateInput, ResearchReportUncheckedCreateInput>
    /**
     * In case the ResearchReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchReportUpdateInput, ResearchReportUncheckedUpdateInput>
  }

  /**
   * ResearchReport delete
   */
  export type ResearchReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
    /**
     * Filter which ResearchReport to delete.
     */
    where: ResearchReportWhereUniqueInput
  }

  /**
   * ResearchReport deleteMany
   */
  export type ResearchReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchReports to delete
     */
    where?: ResearchReportWhereInput
    /**
     * Limit how many ResearchReports to delete.
     */
    limit?: number
  }

  /**
   * ResearchReport without action
   */
  export type ResearchReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchReport
     */
    select?: ResearchReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchReport
     */
    omit?: ResearchReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchReportInclude<ExtArgs> | null
  }


  /**
   * Model CreditTransaction
   */

  export type AggregateCreditTransaction = {
    _count: CreditTransactionCountAggregateOutputType | null
    _avg: CreditTransactionAvgAggregateOutputType | null
    _sum: CreditTransactionSumAggregateOutputType | null
    _min: CreditTransactionMinAggregateOutputType | null
    _max: CreditTransactionMaxAggregateOutputType | null
  }

  export type CreditTransactionAvgAggregateOutputType = {
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditTransactionSumAggregateOutputType = {
    amount: number | null
    balanceBefore: number | null
    balanceAfter: number | null
  }

  export type CreditTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: $Enums.CreditTransactionType | null
    description: string | null
    relatedId: string | null
    balanceBefore: number | null
    balanceAfter: number | null
    createdAt: Date | null
  }

  export type CreditTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    type: $Enums.CreditTransactionType | null
    description: string | null
    relatedId: string | null
    balanceBefore: number | null
    balanceAfter: number | null
    createdAt: Date | null
  }

  export type CreditTransactionCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    type: number
    description: number
    relatedId: number
    balanceBefore: number
    balanceAfter: number
    createdAt: number
    _all: number
  }


  export type CreditTransactionAvgAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditTransactionSumAggregateInputType = {
    amount?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type CreditTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    relatedId?: true
    balanceBefore?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type CreditTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    relatedId?: true
    balanceBefore?: true
    balanceAfter?: true
    createdAt?: true
  }

  export type CreditTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    type?: true
    description?: true
    relatedId?: true
    balanceBefore?: true
    balanceAfter?: true
    createdAt?: true
    _all?: true
  }

  export type CreditTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTransaction to aggregate.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditTransactions
    **/
    _count?: true | CreditTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditTransactionMaxAggregateInputType
  }

  export type GetCreditTransactionAggregateType<T extends CreditTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditTransaction[P]>
      : GetScalarType<T[P], AggregateCreditTransaction[P]>
  }




  export type CreditTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditTransactionWhereInput
    orderBy?: CreditTransactionOrderByWithAggregationInput | CreditTransactionOrderByWithAggregationInput[]
    by: CreditTransactionScalarFieldEnum[] | CreditTransactionScalarFieldEnum
    having?: CreditTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditTransactionCountAggregateInputType | true
    _avg?: CreditTransactionAvgAggregateInputType
    _sum?: CreditTransactionSumAggregateInputType
    _min?: CreditTransactionMinAggregateInputType
    _max?: CreditTransactionMaxAggregateInputType
  }

  export type CreditTransactionGroupByOutputType = {
    id: string
    userId: string
    amount: number
    type: $Enums.CreditTransactionType
    description: string | null
    relatedId: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt: Date
    _count: CreditTransactionCountAggregateOutputType | null
    _avg: CreditTransactionAvgAggregateOutputType | null
    _sum: CreditTransactionSumAggregateOutputType | null
    _min: CreditTransactionMinAggregateOutputType | null
    _max: CreditTransactionMaxAggregateOutputType | null
  }

  type GetCreditTransactionGroupByPayload<T extends CreditTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CreditTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CreditTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditTransaction"]>

  export type CreditTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    type?: boolean
    description?: boolean
    relatedId?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    createdAt?: boolean
  }

  export type CreditTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "type" | "description" | "relatedId" | "balanceBefore" | "balanceAfter" | "createdAt", ExtArgs["result"]["creditTransaction"]>
  export type CreditTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CreditTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CreditTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      type: $Enums.CreditTransactionType
      description: string | null
      relatedId: string | null
      balanceBefore: number
      balanceAfter: number
      createdAt: Date
    }, ExtArgs["result"]["creditTransaction"]>
    composites: {}
  }

  type CreditTransactionGetPayload<S extends boolean | null | undefined | CreditTransactionDefaultArgs> = $Result.GetResult<Prisma.$CreditTransactionPayload, S>

  type CreditTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditTransactionCountAggregateInputType | true
    }

  export interface CreditTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditTransaction'], meta: { name: 'CreditTransaction' } }
    /**
     * Find zero or one CreditTransaction that matches the filter.
     * @param {CreditTransactionFindUniqueArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditTransactionFindUniqueArgs>(args: SelectSubset<T, CreditTransactionFindUniqueArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditTransactionFindUniqueOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditTransactionFindFirstArgs>(args?: SelectSubset<T, CreditTransactionFindFirstArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindFirstOrThrowArgs} args - Arguments to find a CreditTransaction
     * @example
     * // Get one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany()
     * 
     * // Get first 10 CreditTransactions
     * const creditTransactions = await prisma.creditTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditTransactionFindManyArgs>(args?: SelectSubset<T, CreditTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditTransaction.
     * @param {CreditTransactionCreateArgs} args - Arguments to create a CreditTransaction.
     * @example
     * // Create one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.create({
     *   data: {
     *     // ... data to create a CreditTransaction
     *   }
     * })
     * 
     */
    create<T extends CreditTransactionCreateArgs>(args: SelectSubset<T, CreditTransactionCreateArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditTransactions.
     * @param {CreditTransactionCreateManyArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditTransactionCreateManyArgs>(args?: SelectSubset<T, CreditTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditTransactions and returns the data saved in the database.
     * @param {CreditTransactionCreateManyAndReturnArgs} args - Arguments to create many CreditTransactions.
     * @example
     * // Create many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditTransaction.
     * @param {CreditTransactionDeleteArgs} args - Arguments to delete one CreditTransaction.
     * @example
     * // Delete one CreditTransaction
     * const CreditTransaction = await prisma.creditTransaction.delete({
     *   where: {
     *     // ... filter to delete one CreditTransaction
     *   }
     * })
     * 
     */
    delete<T extends CreditTransactionDeleteArgs>(args: SelectSubset<T, CreditTransactionDeleteArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditTransaction.
     * @param {CreditTransactionUpdateArgs} args - Arguments to update one CreditTransaction.
     * @example
     * // Update one CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditTransactionUpdateArgs>(args: SelectSubset<T, CreditTransactionUpdateArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditTransactions.
     * @param {CreditTransactionDeleteManyArgs} args - Arguments to filter CreditTransactions to delete.
     * @example
     * // Delete a few CreditTransactions
     * const { count } = await prisma.creditTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditTransactionDeleteManyArgs>(args?: SelectSubset<T, CreditTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditTransactionUpdateManyArgs>(args: SelectSubset<T, CreditTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditTransactions and returns the data updated in the database.
     * @param {CreditTransactionUpdateManyAndReturnArgs} args - Arguments to update many CreditTransactions.
     * @example
     * // Update many CreditTransactions
     * const creditTransaction = await prisma.creditTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditTransactions and only return the `id`
     * const creditTransactionWithIdOnly = await prisma.creditTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditTransaction.
     * @param {CreditTransactionUpsertArgs} args - Arguments to update or create a CreditTransaction.
     * @example
     * // Update or create a CreditTransaction
     * const creditTransaction = await prisma.creditTransaction.upsert({
     *   create: {
     *     // ... data to create a CreditTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CreditTransactionUpsertArgs>(args: SelectSubset<T, CreditTransactionUpsertArgs<ExtArgs>>): Prisma__CreditTransactionClient<$Result.GetResult<Prisma.$CreditTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionCountArgs} args - Arguments to filter CreditTransactions to count.
     * @example
     * // Count the number of CreditTransactions
     * const count = await prisma.creditTransaction.count({
     *   where: {
     *     // ... the filter for the CreditTransactions we want to count
     *   }
     * })
    **/
    count<T extends CreditTransactionCountArgs>(
      args?: Subset<T, CreditTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditTransactionAggregateArgs>(args: Subset<T, CreditTransactionAggregateArgs>): Prisma.PrismaPromise<GetCreditTransactionAggregateType<T>>

    /**
     * Group by CreditTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CreditTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditTransaction model
   */
  readonly fields: CreditTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditTransaction model
   */
  interface CreditTransactionFieldRefs {
    readonly id: FieldRef<"CreditTransaction", 'String'>
    readonly userId: FieldRef<"CreditTransaction", 'String'>
    readonly amount: FieldRef<"CreditTransaction", 'Int'>
    readonly type: FieldRef<"CreditTransaction", 'CreditTransactionType'>
    readonly description: FieldRef<"CreditTransaction", 'String'>
    readonly relatedId: FieldRef<"CreditTransaction", 'String'>
    readonly balanceBefore: FieldRef<"CreditTransaction", 'Int'>
    readonly balanceAfter: FieldRef<"CreditTransaction", 'Int'>
    readonly createdAt: FieldRef<"CreditTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CreditTransaction findUnique
   */
  export type CreditTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction findUniqueOrThrow
   */
  export type CreditTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction findFirst
   */
  export type CreditTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction findFirstOrThrow
   */
  export type CreditTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransaction to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditTransactions.
     */
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction findMany
   */
  export type CreditTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CreditTransactions to fetch.
     */
    where?: CreditTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditTransactions to fetch.
     */
    orderBy?: CreditTransactionOrderByWithRelationInput | CreditTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditTransactions.
     */
    cursor?: CreditTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditTransactions.
     */
    skip?: number
    distinct?: CreditTransactionScalarFieldEnum | CreditTransactionScalarFieldEnum[]
  }

  /**
   * CreditTransaction create
   */
  export type CreditTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditTransaction.
     */
    data: XOR<CreditTransactionCreateInput, CreditTransactionUncheckedCreateInput>
  }

  /**
   * CreditTransaction createMany
   */
  export type CreditTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditTransaction createManyAndReturn
   */
  export type CreditTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CreditTransactions.
     */
    data: CreditTransactionCreateManyInput | CreditTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTransaction update
   */
  export type CreditTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditTransaction.
     */
    data: XOR<CreditTransactionUpdateInput, CreditTransactionUncheckedUpdateInput>
    /**
     * Choose, which CreditTransaction to update.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction updateMany
   */
  export type CreditTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number
  }

  /**
   * CreditTransaction updateManyAndReturn
   */
  export type CreditTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CreditTransactions.
     */
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CreditTransactions to update
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditTransaction upsert
   */
  export type CreditTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditTransaction to update in case it exists.
     */
    where: CreditTransactionWhereUniqueInput
    /**
     * In case the CreditTransaction found by the `where` argument doesn't exist, create a new CreditTransaction with this data.
     */
    create: XOR<CreditTransactionCreateInput, CreditTransactionUncheckedCreateInput>
    /**
     * In case the CreditTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditTransactionUpdateInput, CreditTransactionUncheckedUpdateInput>
  }

  /**
   * CreditTransaction delete
   */
  export type CreditTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
    /**
     * Filter which CreditTransaction to delete.
     */
    where: CreditTransactionWhereUniqueInput
  }

  /**
   * CreditTransaction deleteMany
   */
  export type CreditTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditTransactions to delete
     */
    where?: CreditTransactionWhereInput
    /**
     * Limit how many CreditTransactions to delete.
     */
    limit?: number
  }

  /**
   * CreditTransaction without action
   */
  export type CreditTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditTransaction
     */
    select?: CreditTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditTransaction
     */
    omit?: CreditTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    credits: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    credits: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    outTradeNo: string | null
    amount: number | null
    credits: number | null
    description: string | null
    currency: string | null
    provider: string | null
    providerOrderId: string | null
    payUrl: string | null
    qrCodeUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    expiredAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    outTradeNo: string | null
    amount: number | null
    credits: number | null
    description: string | null
    currency: string | null
    provider: string | null
    providerOrderId: string | null
    payUrl: string | null
    qrCodeUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
    expiredAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    outTradeNo: number
    amount: number
    credits: number
    description: number
    currency: number
    provider: number
    providerOrderId: number
    payUrl: number
    qrCodeUrl: number
    status: number
    createdAt: number
    updatedAt: number
    paidAt: number
    expiredAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    credits?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    credits?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    outTradeNo?: true
    amount?: true
    credits?: true
    description?: true
    currency?: true
    provider?: true
    providerOrderId?: true
    payUrl?: true
    qrCodeUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    expiredAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    outTradeNo?: true
    amount?: true
    credits?: true
    description?: true
    currency?: true
    provider?: true
    providerOrderId?: true
    payUrl?: true
    qrCodeUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    expiredAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    outTradeNo?: true
    amount?: true
    credits?: true
    description?: true
    currency?: true
    provider?: true
    providerOrderId?: true
    payUrl?: true
    qrCodeUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    expiredAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency: string
    provider: string
    providerOrderId: string | null
    payUrl: string | null
    qrCodeUrl: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    paidAt: Date | null
    expiredAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    outTradeNo?: boolean
    amount?: boolean
    credits?: boolean
    description?: boolean
    currency?: boolean
    provider?: boolean
    providerOrderId?: boolean
    payUrl?: boolean
    qrCodeUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    expiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    outTradeNo?: boolean
    amount?: boolean
    credits?: boolean
    description?: boolean
    currency?: boolean
    provider?: boolean
    providerOrderId?: boolean
    payUrl?: boolean
    qrCodeUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    expiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    outTradeNo?: boolean
    amount?: boolean
    credits?: boolean
    description?: boolean
    currency?: boolean
    provider?: boolean
    providerOrderId?: boolean
    payUrl?: boolean
    qrCodeUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    expiredAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    outTradeNo?: boolean
    amount?: boolean
    credits?: boolean
    description?: boolean
    currency?: boolean
    provider?: boolean
    providerOrderId?: boolean
    payUrl?: boolean
    qrCodeUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    expiredAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "outTradeNo" | "amount" | "credits" | "description" | "currency" | "provider" | "providerOrderId" | "payUrl" | "qrCodeUrl" | "status" | "createdAt" | "updatedAt" | "paidAt" | "expiredAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      refunds: Prisma.$RefundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      outTradeNo: string
      amount: number
      credits: number
      description: string
      currency: string
      provider: string
      providerOrderId: string | null
      payUrl: string | null
      qrCodeUrl: string | null
      status: string
      createdAt: Date
      updatedAt: Date
      paidAt: Date | null
      expiredAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly outTradeNo: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly credits: FieldRef<"Payment", 'Int'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly providerOrderId: FieldRef<"Payment", 'String'>
    readonly payUrl: FieldRef<"Payment", 'String'>
    readonly qrCodeUrl: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly expiredAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    refundAmount: number | null
  }

  export type RefundSumAggregateOutputType = {
    refundAmount: number | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    outRefundNo: string | null
    refundAmount: number | null
    reason: string | null
    status: string | null
    providerRefundId: string | null
    operatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    refundedAt: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    outRefundNo: string | null
    refundAmount: number | null
    reason: string | null
    status: string | null
    providerRefundId: string | null
    operatorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    refundedAt: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    paymentId: number
    outRefundNo: number
    refundAmount: number
    reason: number
    status: number
    providerRefundId: number
    operatorId: number
    createdAt: number
    updatedAt: number
    refundedAt: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    refundAmount?: true
  }

  export type RefundSumAggregateInputType = {
    refundAmount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    paymentId?: true
    outRefundNo?: true
    refundAmount?: true
    reason?: true
    status?: true
    providerRefundId?: true
    operatorId?: true
    createdAt?: true
    updatedAt?: true
    refundedAt?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    paymentId?: true
    outRefundNo?: true
    refundAmount?: true
    reason?: true
    status?: true
    providerRefundId?: true
    operatorId?: true
    createdAt?: true
    updatedAt?: true
    refundedAt?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    paymentId?: true
    outRefundNo?: true
    refundAmount?: true
    reason?: true
    status?: true
    providerRefundId?: true
    operatorId?: true
    createdAt?: true
    updatedAt?: true
    refundedAt?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    paymentId: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status: string
    providerRefundId: string | null
    operatorId: string
    createdAt: Date
    updatedAt: Date
    refundedAt: Date | null
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    outRefundNo?: boolean
    refundAmount?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    operatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    outRefundNo?: boolean
    refundAmount?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    operatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    outRefundNo?: boolean
    refundAmount?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    operatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    paymentId?: boolean
    outRefundNo?: boolean
    refundAmount?: boolean
    reason?: boolean
    status?: boolean
    providerRefundId?: boolean
    operatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    refundedAt?: boolean
  }

  export type RefundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "outRefundNo" | "refundAmount" | "reason" | "status" | "providerRefundId" | "operatorId" | "createdAt" | "updatedAt" | "refundedAt", ExtArgs["result"]["refund"]>
  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      outRefundNo: string
      refundAmount: number
      reason: string
      status: string
      providerRefundId: string | null
      operatorId: string
      createdAt: Date
      updatedAt: Date
      refundedAt: Date | null
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds and returns the data updated in the database.
     * @param {RefundUpdateManyAndReturnArgs} args - Arguments to update many Refunds.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly paymentId: FieldRef<"Refund", 'String'>
    readonly outRefundNo: FieldRef<"Refund", 'String'>
    readonly refundAmount: FieldRef<"Refund", 'Float'>
    readonly reason: FieldRef<"Refund", 'String'>
    readonly status: FieldRef<"Refund", 'String'>
    readonly providerRefundId: FieldRef<"Refund", 'String'>
    readonly operatorId: FieldRef<"Refund", 'String'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
    readonly updatedAt: FieldRef<"Refund", 'DateTime'>
    readonly refundedAt: FieldRef<"Refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
  }

  /**
   * Refund updateManyAndReturn
   */
  export type RefundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to delete.
     */
    limit?: number
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalName: string | null
    key: string | null
    url: string | null
    size: number | null
    contentType: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalName: string | null
    key: string | null
    url: string | null
    size: number | null
    contentType: string | null
    type: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    userId: number
    filename: number
    originalName: number
    key: number
    url: number
    size: number
    contentType: number
    type: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    key?: true
    url?: true
    size?: true
    contentType?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    key?: true
    url?: true
    size?: true
    contentType?: true
    type?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalName?: true
    key?: true
    url?: true
    size?: true
    contentType?: true
    type?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    userId: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type: string
    status: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    contentType?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    contentType?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    contentType?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalName?: boolean
    key?: boolean
    url?: boolean
    size?: boolean
    contentType?: boolean
    type?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "filename" | "originalName" | "key" | "url" | "size" | "contentType" | "type" | "status" | "metadata" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      filename: string
      originalName: string
      key: string
      url: string
      size: number
      contentType: string
      type: string
      status: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly userId: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly originalName: FieldRef<"File", 'String'>
    readonly key: FieldRef<"File", 'String'>
    readonly url: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly contentType: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'String'>
    readonly status: FieldRef<"File", 'String'>
    readonly metadata: FieldRef<"File", 'Json'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly deletedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model AIUsageStats
   */

  export type AggregateAIUsageStats = {
    _count: AIUsageStatsCountAggregateOutputType | null
    _avg: AIUsageStatsAvgAggregateOutputType | null
    _sum: AIUsageStatsSumAggregateOutputType | null
    _min: AIUsageStatsMinAggregateOutputType | null
    _max: AIUsageStatsMaxAggregateOutputType | null
  }

  export type AIUsageStatsAvgAggregateOutputType = {
    requestCount: number | null
    totalTokens: number | null
    totalCost: number | null
  }

  export type AIUsageStatsSumAggregateOutputType = {
    requestCount: number | null
    totalTokens: number | null
    totalCost: number | null
  }

  export type AIUsageStatsMinAggregateOutputType = {
    id: string | null
    provider: string | null
    model: string | null
    requestCount: number | null
    totalTokens: number | null
    totalCost: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIUsageStatsMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    model: string | null
    requestCount: number | null
    totalTokens: number | null
    totalCost: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIUsageStatsCountAggregateOutputType = {
    id: number
    provider: number
    model: number
    requestCount: number
    totalTokens: number
    totalCost: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIUsageStatsAvgAggregateInputType = {
    requestCount?: true
    totalTokens?: true
    totalCost?: true
  }

  export type AIUsageStatsSumAggregateInputType = {
    requestCount?: true
    totalTokens?: true
    totalCost?: true
  }

  export type AIUsageStatsMinAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    requestCount?: true
    totalTokens?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIUsageStatsMaxAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    requestCount?: true
    totalTokens?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIUsageStatsCountAggregateInputType = {
    id?: true
    provider?: true
    model?: true
    requestCount?: true
    totalTokens?: true
    totalCost?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIUsageStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageStats to aggregate.
     */
    where?: AIUsageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageStats to fetch.
     */
    orderBy?: AIUsageStatsOrderByWithRelationInput | AIUsageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIUsageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIUsageStats
    **/
    _count?: true | AIUsageStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIUsageStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIUsageStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIUsageStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIUsageStatsMaxAggregateInputType
  }

  export type GetAIUsageStatsAggregateType<T extends AIUsageStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateAIUsageStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIUsageStats[P]>
      : GetScalarType<T[P], AggregateAIUsageStats[P]>
  }




  export type AIUsageStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIUsageStatsWhereInput
    orderBy?: AIUsageStatsOrderByWithAggregationInput | AIUsageStatsOrderByWithAggregationInput[]
    by: AIUsageStatsScalarFieldEnum[] | AIUsageStatsScalarFieldEnum
    having?: AIUsageStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIUsageStatsCountAggregateInputType | true
    _avg?: AIUsageStatsAvgAggregateInputType
    _sum?: AIUsageStatsSumAggregateInputType
    _min?: AIUsageStatsMinAggregateInputType
    _max?: AIUsageStatsMaxAggregateInputType
  }

  export type AIUsageStatsGroupByOutputType = {
    id: string
    provider: string
    model: string
    requestCount: number
    totalTokens: number
    totalCost: number
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: AIUsageStatsCountAggregateOutputType | null
    _avg: AIUsageStatsAvgAggregateOutputType | null
    _sum: AIUsageStatsSumAggregateOutputType | null
    _min: AIUsageStatsMinAggregateOutputType | null
    _max: AIUsageStatsMaxAggregateOutputType | null
  }

  type GetAIUsageStatsGroupByPayload<T extends AIUsageStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIUsageStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIUsageStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIUsageStatsGroupByOutputType[P]>
            : GetScalarType<T[P], AIUsageStatsGroupByOutputType[P]>
        }
      >
    >


  export type AIUsageStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    model?: boolean
    requestCount?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIUsageStats"]>

  export type AIUsageStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    model?: boolean
    requestCount?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIUsageStats"]>

  export type AIUsageStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    model?: boolean
    requestCount?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIUsageStats"]>

  export type AIUsageStatsSelectScalar = {
    id?: boolean
    provider?: boolean
    model?: boolean
    requestCount?: boolean
    totalTokens?: boolean
    totalCost?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIUsageStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "model" | "requestCount" | "totalTokens" | "totalCost" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["aIUsageStats"]>

  export type $AIUsageStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIUsageStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      model: string
      requestCount: number
      totalTokens: number
      totalCost: number
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIUsageStats"]>
    composites: {}
  }

  type AIUsageStatsGetPayload<S extends boolean | null | undefined | AIUsageStatsDefaultArgs> = $Result.GetResult<Prisma.$AIUsageStatsPayload, S>

  type AIUsageStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIUsageStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIUsageStatsCountAggregateInputType | true
    }

  export interface AIUsageStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIUsageStats'], meta: { name: 'AIUsageStats' } }
    /**
     * Find zero or one AIUsageStats that matches the filter.
     * @param {AIUsageStatsFindUniqueArgs} args - Arguments to find a AIUsageStats
     * @example
     * // Get one AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIUsageStatsFindUniqueArgs>(args: SelectSubset<T, AIUsageStatsFindUniqueArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIUsageStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIUsageStatsFindUniqueOrThrowArgs} args - Arguments to find a AIUsageStats
     * @example
     * // Get one AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIUsageStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, AIUsageStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsFindFirstArgs} args - Arguments to find a AIUsageStats
     * @example
     * // Get one AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIUsageStatsFindFirstArgs>(args?: SelectSubset<T, AIUsageStatsFindFirstArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIUsageStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsFindFirstOrThrowArgs} args - Arguments to find a AIUsageStats
     * @example
     * // Get one AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIUsageStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, AIUsageStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIUsageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findMany()
     * 
     * // Get first 10 AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIUsageStatsWithIdOnly = await prisma.aIUsageStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIUsageStatsFindManyArgs>(args?: SelectSubset<T, AIUsageStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIUsageStats.
     * @param {AIUsageStatsCreateArgs} args - Arguments to create a AIUsageStats.
     * @example
     * // Create one AIUsageStats
     * const AIUsageStats = await prisma.aIUsageStats.create({
     *   data: {
     *     // ... data to create a AIUsageStats
     *   }
     * })
     * 
     */
    create<T extends AIUsageStatsCreateArgs>(args: SelectSubset<T, AIUsageStatsCreateArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIUsageStats.
     * @param {AIUsageStatsCreateManyArgs} args - Arguments to create many AIUsageStats.
     * @example
     * // Create many AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIUsageStatsCreateManyArgs>(args?: SelectSubset<T, AIUsageStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIUsageStats and returns the data saved in the database.
     * @param {AIUsageStatsCreateManyAndReturnArgs} args - Arguments to create many AIUsageStats.
     * @example
     * // Create many AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIUsageStats and only return the `id`
     * const aIUsageStatsWithIdOnly = await prisma.aIUsageStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIUsageStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, AIUsageStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIUsageStats.
     * @param {AIUsageStatsDeleteArgs} args - Arguments to delete one AIUsageStats.
     * @example
     * // Delete one AIUsageStats
     * const AIUsageStats = await prisma.aIUsageStats.delete({
     *   where: {
     *     // ... filter to delete one AIUsageStats
     *   }
     * })
     * 
     */
    delete<T extends AIUsageStatsDeleteArgs>(args: SelectSubset<T, AIUsageStatsDeleteArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIUsageStats.
     * @param {AIUsageStatsUpdateArgs} args - Arguments to update one AIUsageStats.
     * @example
     * // Update one AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIUsageStatsUpdateArgs>(args: SelectSubset<T, AIUsageStatsUpdateArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIUsageStats.
     * @param {AIUsageStatsDeleteManyArgs} args - Arguments to filter AIUsageStats to delete.
     * @example
     * // Delete a few AIUsageStats
     * const { count } = await prisma.aIUsageStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIUsageStatsDeleteManyArgs>(args?: SelectSubset<T, AIUsageStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIUsageStatsUpdateManyArgs>(args: SelectSubset<T, AIUsageStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIUsageStats and returns the data updated in the database.
     * @param {AIUsageStatsUpdateManyAndReturnArgs} args - Arguments to update many AIUsageStats.
     * @example
     * // Update many AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIUsageStats and only return the `id`
     * const aIUsageStatsWithIdOnly = await prisma.aIUsageStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIUsageStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, AIUsageStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIUsageStats.
     * @param {AIUsageStatsUpsertArgs} args - Arguments to update or create a AIUsageStats.
     * @example
     * // Update or create a AIUsageStats
     * const aIUsageStats = await prisma.aIUsageStats.upsert({
     *   create: {
     *     // ... data to create a AIUsageStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIUsageStats we want to update
     *   }
     * })
     */
    upsert<T extends AIUsageStatsUpsertArgs>(args: SelectSubset<T, AIUsageStatsUpsertArgs<ExtArgs>>): Prisma__AIUsageStatsClient<$Result.GetResult<Prisma.$AIUsageStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIUsageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsCountArgs} args - Arguments to filter AIUsageStats to count.
     * @example
     * // Count the number of AIUsageStats
     * const count = await prisma.aIUsageStats.count({
     *   where: {
     *     // ... the filter for the AIUsageStats we want to count
     *   }
     * })
    **/
    count<T extends AIUsageStatsCountArgs>(
      args?: Subset<T, AIUsageStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIUsageStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIUsageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIUsageStatsAggregateArgs>(args: Subset<T, AIUsageStatsAggregateArgs>): Prisma.PrismaPromise<GetAIUsageStatsAggregateType<T>>

    /**
     * Group by AIUsageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIUsageStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIUsageStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIUsageStatsGroupByArgs['orderBy'] }
        : { orderBy?: AIUsageStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIUsageStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIUsageStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIUsageStats model
   */
  readonly fields: AIUsageStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIUsageStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIUsageStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIUsageStats model
   */
  interface AIUsageStatsFieldRefs {
    readonly id: FieldRef<"AIUsageStats", 'String'>
    readonly provider: FieldRef<"AIUsageStats", 'String'>
    readonly model: FieldRef<"AIUsageStats", 'String'>
    readonly requestCount: FieldRef<"AIUsageStats", 'Int'>
    readonly totalTokens: FieldRef<"AIUsageStats", 'Int'>
    readonly totalCost: FieldRef<"AIUsageStats", 'Float'>
    readonly date: FieldRef<"AIUsageStats", 'DateTime'>
    readonly createdAt: FieldRef<"AIUsageStats", 'DateTime'>
    readonly updatedAt: FieldRef<"AIUsageStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIUsageStats findUnique
   */
  export type AIUsageStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageStats to fetch.
     */
    where: AIUsageStatsWhereUniqueInput
  }

  /**
   * AIUsageStats findUniqueOrThrow
   */
  export type AIUsageStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageStats to fetch.
     */
    where: AIUsageStatsWhereUniqueInput
  }

  /**
   * AIUsageStats findFirst
   */
  export type AIUsageStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageStats to fetch.
     */
    where?: AIUsageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageStats to fetch.
     */
    orderBy?: AIUsageStatsOrderByWithRelationInput | AIUsageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageStats.
     */
    cursor?: AIUsageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageStats.
     */
    distinct?: AIUsageStatsScalarFieldEnum | AIUsageStatsScalarFieldEnum[]
  }

  /**
   * AIUsageStats findFirstOrThrow
   */
  export type AIUsageStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageStats to fetch.
     */
    where?: AIUsageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageStats to fetch.
     */
    orderBy?: AIUsageStatsOrderByWithRelationInput | AIUsageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIUsageStats.
     */
    cursor?: AIUsageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIUsageStats.
     */
    distinct?: AIUsageStatsScalarFieldEnum | AIUsageStatsScalarFieldEnum[]
  }

  /**
   * AIUsageStats findMany
   */
  export type AIUsageStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter, which AIUsageStats to fetch.
     */
    where?: AIUsageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIUsageStats to fetch.
     */
    orderBy?: AIUsageStatsOrderByWithRelationInput | AIUsageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIUsageStats.
     */
    cursor?: AIUsageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIUsageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIUsageStats.
     */
    skip?: number
    distinct?: AIUsageStatsScalarFieldEnum | AIUsageStatsScalarFieldEnum[]
  }

  /**
   * AIUsageStats create
   */
  export type AIUsageStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a AIUsageStats.
     */
    data: XOR<AIUsageStatsCreateInput, AIUsageStatsUncheckedCreateInput>
  }

  /**
   * AIUsageStats createMany
   */
  export type AIUsageStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIUsageStats.
     */
    data: AIUsageStatsCreateManyInput | AIUsageStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageStats createManyAndReturn
   */
  export type AIUsageStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * The data used to create many AIUsageStats.
     */
    data: AIUsageStatsCreateManyInput | AIUsageStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIUsageStats update
   */
  export type AIUsageStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a AIUsageStats.
     */
    data: XOR<AIUsageStatsUpdateInput, AIUsageStatsUncheckedUpdateInput>
    /**
     * Choose, which AIUsageStats to update.
     */
    where: AIUsageStatsWhereUniqueInput
  }

  /**
   * AIUsageStats updateMany
   */
  export type AIUsageStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIUsageStats.
     */
    data: XOR<AIUsageStatsUpdateManyMutationInput, AIUsageStatsUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageStats to update
     */
    where?: AIUsageStatsWhereInput
    /**
     * Limit how many AIUsageStats to update.
     */
    limit?: number
  }

  /**
   * AIUsageStats updateManyAndReturn
   */
  export type AIUsageStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * The data used to update AIUsageStats.
     */
    data: XOR<AIUsageStatsUpdateManyMutationInput, AIUsageStatsUncheckedUpdateManyInput>
    /**
     * Filter which AIUsageStats to update
     */
    where?: AIUsageStatsWhereInput
    /**
     * Limit how many AIUsageStats to update.
     */
    limit?: number
  }

  /**
   * AIUsageStats upsert
   */
  export type AIUsageStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the AIUsageStats to update in case it exists.
     */
    where: AIUsageStatsWhereUniqueInput
    /**
     * In case the AIUsageStats found by the `where` argument doesn't exist, create a new AIUsageStats with this data.
     */
    create: XOR<AIUsageStatsCreateInput, AIUsageStatsUncheckedCreateInput>
    /**
     * In case the AIUsageStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIUsageStatsUpdateInput, AIUsageStatsUncheckedUpdateInput>
  }

  /**
   * AIUsageStats delete
   */
  export type AIUsageStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
    /**
     * Filter which AIUsageStats to delete.
     */
    where: AIUsageStatsWhereUniqueInput
  }

  /**
   * AIUsageStats deleteMany
   */
  export type AIUsageStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIUsageStats to delete
     */
    where?: AIUsageStatsWhereInput
    /**
     * Limit how many AIUsageStats to delete.
     */
    limit?: number
  }

  /**
   * AIUsageStats without action
   */
  export type AIUsageStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIUsageStats
     */
    select?: AIUsageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIUsageStats
     */
    omit?: AIUsageStatsOmit<ExtArgs> | null
  }


  /**
   * Model IdeaDiscussion
   */

  export type AggregateIdeaDiscussion = {
    _count: IdeaDiscussionCountAggregateOutputType | null
    _avg: IdeaDiscussionAvgAggregateOutputType | null
    _sum: IdeaDiscussionSumAggregateOutputType | null
    _min: IdeaDiscussionMinAggregateOutputType | null
    _max: IdeaDiscussionMaxAggregateOutputType | null
  }

  export type IdeaDiscussionAvgAggregateOutputType = {
    currentRound: number | null
    totalRounds: number | null
  }

  export type IdeaDiscussionSumAggregateOutputType = {
    currentRound: number | null
    totalRounds: number | null
  }

  export type IdeaDiscussionMinAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    status: $Enums.DiscussionStatus | null
    currentRound: number | null
    totalRounds: number | null
    aiAgentType: string | null
    aiAgentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type IdeaDiscussionMaxAggregateOutputType = {
    id: string | null
    ideaId: string | null
    userId: string | null
    status: $Enums.DiscussionStatus | null
    currentRound: number | null
    totalRounds: number | null
    aiAgentType: string | null
    aiAgentName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completedAt: Date | null
  }

  export type IdeaDiscussionCountAggregateOutputType = {
    id: number
    ideaId: number
    userId: number
    status: number
    currentRound: number
    totalRounds: number
    aiAgentType: number
    aiAgentName: number
    createdAt: number
    updatedAt: number
    completedAt: number
    _all: number
  }


  export type IdeaDiscussionAvgAggregateInputType = {
    currentRound?: true
    totalRounds?: true
  }

  export type IdeaDiscussionSumAggregateInputType = {
    currentRound?: true
    totalRounds?: true
  }

  export type IdeaDiscussionMinAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    status?: true
    currentRound?: true
    totalRounds?: true
    aiAgentType?: true
    aiAgentName?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type IdeaDiscussionMaxAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    status?: true
    currentRound?: true
    totalRounds?: true
    aiAgentType?: true
    aiAgentName?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
  }

  export type IdeaDiscussionCountAggregateInputType = {
    id?: true
    ideaId?: true
    userId?: true
    status?: true
    currentRound?: true
    totalRounds?: true
    aiAgentType?: true
    aiAgentName?: true
    createdAt?: true
    updatedAt?: true
    completedAt?: true
    _all?: true
  }

  export type IdeaDiscussionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdeaDiscussion to aggregate.
     */
    where?: IdeaDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdeaDiscussions to fetch.
     */
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IdeaDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdeaDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdeaDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IdeaDiscussions
    **/
    _count?: true | IdeaDiscussionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IdeaDiscussionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IdeaDiscussionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IdeaDiscussionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IdeaDiscussionMaxAggregateInputType
  }

  export type GetIdeaDiscussionAggregateType<T extends IdeaDiscussionAggregateArgs> = {
        [P in keyof T & keyof AggregateIdeaDiscussion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIdeaDiscussion[P]>
      : GetScalarType<T[P], AggregateIdeaDiscussion[P]>
  }




  export type IdeaDiscussionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IdeaDiscussionWhereInput
    orderBy?: IdeaDiscussionOrderByWithAggregationInput | IdeaDiscussionOrderByWithAggregationInput[]
    by: IdeaDiscussionScalarFieldEnum[] | IdeaDiscussionScalarFieldEnum
    having?: IdeaDiscussionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IdeaDiscussionCountAggregateInputType | true
    _avg?: IdeaDiscussionAvgAggregateInputType
    _sum?: IdeaDiscussionSumAggregateInputType
    _min?: IdeaDiscussionMinAggregateInputType
    _max?: IdeaDiscussionMaxAggregateInputType
  }

  export type IdeaDiscussionGroupByOutputType = {
    id: string
    ideaId: string
    userId: string
    status: $Enums.DiscussionStatus
    currentRound: number
    totalRounds: number
    aiAgentType: string
    aiAgentName: string
    createdAt: Date
    updatedAt: Date
    completedAt: Date | null
    _count: IdeaDiscussionCountAggregateOutputType | null
    _avg: IdeaDiscussionAvgAggregateOutputType | null
    _sum: IdeaDiscussionSumAggregateOutputType | null
    _min: IdeaDiscussionMinAggregateOutputType | null
    _max: IdeaDiscussionMaxAggregateOutputType | null
  }

  type GetIdeaDiscussionGroupByPayload<T extends IdeaDiscussionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IdeaDiscussionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IdeaDiscussionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IdeaDiscussionGroupByOutputType[P]>
            : GetScalarType<T[P], IdeaDiscussionGroupByOutputType[P]>
        }
      >
    >


  export type IdeaDiscussionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    status?: boolean
    currentRound?: boolean
    totalRounds?: boolean
    aiAgentType?: boolean
    aiAgentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | IdeaDiscussion$sessionsArgs<ExtArgs>
    messages?: boolean | IdeaDiscussion$messagesArgs<ExtArgs>
    _count?: boolean | IdeaDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ideaDiscussion"]>

  export type IdeaDiscussionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    status?: boolean
    currentRound?: boolean
    totalRounds?: boolean
    aiAgentType?: boolean
    aiAgentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ideaDiscussion"]>

  export type IdeaDiscussionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    status?: boolean
    currentRound?: boolean
    totalRounds?: boolean
    aiAgentType?: boolean
    aiAgentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ideaDiscussion"]>

  export type IdeaDiscussionSelectScalar = {
    id?: boolean
    ideaId?: boolean
    userId?: boolean
    status?: boolean
    currentRound?: boolean
    totalRounds?: boolean
    aiAgentType?: boolean
    aiAgentName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completedAt?: boolean
  }

  export type IdeaDiscussionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ideaId" | "userId" | "status" | "currentRound" | "totalRounds" | "aiAgentType" | "aiAgentName" | "createdAt" | "updatedAt" | "completedAt", ExtArgs["result"]["ideaDiscussion"]>
  export type IdeaDiscussionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sessions?: boolean | IdeaDiscussion$sessionsArgs<ExtArgs>
    messages?: boolean | IdeaDiscussion$messagesArgs<ExtArgs>
    _count?: boolean | IdeaDiscussionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IdeaDiscussionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IdeaDiscussionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    idea?: boolean | IdeaDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IdeaDiscussionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IdeaDiscussion"
    objects: {
      idea: Prisma.$IdeaPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      sessions: Prisma.$BiddingSessionPayload<ExtArgs>[]
      messages: Prisma.$DiscussionMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ideaId: string
      userId: string
      status: $Enums.DiscussionStatus
      currentRound: number
      totalRounds: number
      aiAgentType: string
      aiAgentName: string
      createdAt: Date
      updatedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["ideaDiscussion"]>
    composites: {}
  }

  type IdeaDiscussionGetPayload<S extends boolean | null | undefined | IdeaDiscussionDefaultArgs> = $Result.GetResult<Prisma.$IdeaDiscussionPayload, S>

  type IdeaDiscussionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IdeaDiscussionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IdeaDiscussionCountAggregateInputType | true
    }

  export interface IdeaDiscussionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IdeaDiscussion'], meta: { name: 'IdeaDiscussion' } }
    /**
     * Find zero or one IdeaDiscussion that matches the filter.
     * @param {IdeaDiscussionFindUniqueArgs} args - Arguments to find a IdeaDiscussion
     * @example
     * // Get one IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IdeaDiscussionFindUniqueArgs>(args: SelectSubset<T, IdeaDiscussionFindUniqueArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IdeaDiscussion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IdeaDiscussionFindUniqueOrThrowArgs} args - Arguments to find a IdeaDiscussion
     * @example
     * // Get one IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IdeaDiscussionFindUniqueOrThrowArgs>(args: SelectSubset<T, IdeaDiscussionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdeaDiscussion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionFindFirstArgs} args - Arguments to find a IdeaDiscussion
     * @example
     * // Get one IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IdeaDiscussionFindFirstArgs>(args?: SelectSubset<T, IdeaDiscussionFindFirstArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IdeaDiscussion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionFindFirstOrThrowArgs} args - Arguments to find a IdeaDiscussion
     * @example
     * // Get one IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IdeaDiscussionFindFirstOrThrowArgs>(args?: SelectSubset<T, IdeaDiscussionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IdeaDiscussions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IdeaDiscussions
     * const ideaDiscussions = await prisma.ideaDiscussion.findMany()
     * 
     * // Get first 10 IdeaDiscussions
     * const ideaDiscussions = await prisma.ideaDiscussion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ideaDiscussionWithIdOnly = await prisma.ideaDiscussion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IdeaDiscussionFindManyArgs>(args?: SelectSubset<T, IdeaDiscussionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IdeaDiscussion.
     * @param {IdeaDiscussionCreateArgs} args - Arguments to create a IdeaDiscussion.
     * @example
     * // Create one IdeaDiscussion
     * const IdeaDiscussion = await prisma.ideaDiscussion.create({
     *   data: {
     *     // ... data to create a IdeaDiscussion
     *   }
     * })
     * 
     */
    create<T extends IdeaDiscussionCreateArgs>(args: SelectSubset<T, IdeaDiscussionCreateArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IdeaDiscussions.
     * @param {IdeaDiscussionCreateManyArgs} args - Arguments to create many IdeaDiscussions.
     * @example
     * // Create many IdeaDiscussions
     * const ideaDiscussion = await prisma.ideaDiscussion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IdeaDiscussionCreateManyArgs>(args?: SelectSubset<T, IdeaDiscussionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IdeaDiscussions and returns the data saved in the database.
     * @param {IdeaDiscussionCreateManyAndReturnArgs} args - Arguments to create many IdeaDiscussions.
     * @example
     * // Create many IdeaDiscussions
     * const ideaDiscussion = await prisma.ideaDiscussion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IdeaDiscussions and only return the `id`
     * const ideaDiscussionWithIdOnly = await prisma.ideaDiscussion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IdeaDiscussionCreateManyAndReturnArgs>(args?: SelectSubset<T, IdeaDiscussionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IdeaDiscussion.
     * @param {IdeaDiscussionDeleteArgs} args - Arguments to delete one IdeaDiscussion.
     * @example
     * // Delete one IdeaDiscussion
     * const IdeaDiscussion = await prisma.ideaDiscussion.delete({
     *   where: {
     *     // ... filter to delete one IdeaDiscussion
     *   }
     * })
     * 
     */
    delete<T extends IdeaDiscussionDeleteArgs>(args: SelectSubset<T, IdeaDiscussionDeleteArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IdeaDiscussion.
     * @param {IdeaDiscussionUpdateArgs} args - Arguments to update one IdeaDiscussion.
     * @example
     * // Update one IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IdeaDiscussionUpdateArgs>(args: SelectSubset<T, IdeaDiscussionUpdateArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IdeaDiscussions.
     * @param {IdeaDiscussionDeleteManyArgs} args - Arguments to filter IdeaDiscussions to delete.
     * @example
     * // Delete a few IdeaDiscussions
     * const { count } = await prisma.ideaDiscussion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IdeaDiscussionDeleteManyArgs>(args?: SelectSubset<T, IdeaDiscussionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdeaDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IdeaDiscussions
     * const ideaDiscussion = await prisma.ideaDiscussion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IdeaDiscussionUpdateManyArgs>(args: SelectSubset<T, IdeaDiscussionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IdeaDiscussions and returns the data updated in the database.
     * @param {IdeaDiscussionUpdateManyAndReturnArgs} args - Arguments to update many IdeaDiscussions.
     * @example
     * // Update many IdeaDiscussions
     * const ideaDiscussion = await prisma.ideaDiscussion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IdeaDiscussions and only return the `id`
     * const ideaDiscussionWithIdOnly = await prisma.ideaDiscussion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IdeaDiscussionUpdateManyAndReturnArgs>(args: SelectSubset<T, IdeaDiscussionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IdeaDiscussion.
     * @param {IdeaDiscussionUpsertArgs} args - Arguments to update or create a IdeaDiscussion.
     * @example
     * // Update or create a IdeaDiscussion
     * const ideaDiscussion = await prisma.ideaDiscussion.upsert({
     *   create: {
     *     // ... data to create a IdeaDiscussion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IdeaDiscussion we want to update
     *   }
     * })
     */
    upsert<T extends IdeaDiscussionUpsertArgs>(args: SelectSubset<T, IdeaDiscussionUpsertArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IdeaDiscussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionCountArgs} args - Arguments to filter IdeaDiscussions to count.
     * @example
     * // Count the number of IdeaDiscussions
     * const count = await prisma.ideaDiscussion.count({
     *   where: {
     *     // ... the filter for the IdeaDiscussions we want to count
     *   }
     * })
    **/
    count<T extends IdeaDiscussionCountArgs>(
      args?: Subset<T, IdeaDiscussionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IdeaDiscussionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IdeaDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IdeaDiscussionAggregateArgs>(args: Subset<T, IdeaDiscussionAggregateArgs>): Prisma.PrismaPromise<GetIdeaDiscussionAggregateType<T>>

    /**
     * Group by IdeaDiscussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IdeaDiscussionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IdeaDiscussionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IdeaDiscussionGroupByArgs['orderBy'] }
        : { orderBy?: IdeaDiscussionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IdeaDiscussionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIdeaDiscussionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IdeaDiscussion model
   */
  readonly fields: IdeaDiscussionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IdeaDiscussion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IdeaDiscussionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    idea<T extends IdeaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDefaultArgs<ExtArgs>>): Prisma__IdeaClient<$Result.GetResult<Prisma.$IdeaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessions<T extends IdeaDiscussion$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDiscussion$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends IdeaDiscussion$messagesArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDiscussion$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IdeaDiscussion model
   */
  interface IdeaDiscussionFieldRefs {
    readonly id: FieldRef<"IdeaDiscussion", 'String'>
    readonly ideaId: FieldRef<"IdeaDiscussion", 'String'>
    readonly userId: FieldRef<"IdeaDiscussion", 'String'>
    readonly status: FieldRef<"IdeaDiscussion", 'DiscussionStatus'>
    readonly currentRound: FieldRef<"IdeaDiscussion", 'Int'>
    readonly totalRounds: FieldRef<"IdeaDiscussion", 'Int'>
    readonly aiAgentType: FieldRef<"IdeaDiscussion", 'String'>
    readonly aiAgentName: FieldRef<"IdeaDiscussion", 'String'>
    readonly createdAt: FieldRef<"IdeaDiscussion", 'DateTime'>
    readonly updatedAt: FieldRef<"IdeaDiscussion", 'DateTime'>
    readonly completedAt: FieldRef<"IdeaDiscussion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IdeaDiscussion findUnique
   */
  export type IdeaDiscussionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which IdeaDiscussion to fetch.
     */
    where: IdeaDiscussionWhereUniqueInput
  }

  /**
   * IdeaDiscussion findUniqueOrThrow
   */
  export type IdeaDiscussionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which IdeaDiscussion to fetch.
     */
    where: IdeaDiscussionWhereUniqueInput
  }

  /**
   * IdeaDiscussion findFirst
   */
  export type IdeaDiscussionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which IdeaDiscussion to fetch.
     */
    where?: IdeaDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdeaDiscussions to fetch.
     */
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdeaDiscussions.
     */
    cursor?: IdeaDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdeaDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdeaDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdeaDiscussions.
     */
    distinct?: IdeaDiscussionScalarFieldEnum | IdeaDiscussionScalarFieldEnum[]
  }

  /**
   * IdeaDiscussion findFirstOrThrow
   */
  export type IdeaDiscussionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which IdeaDiscussion to fetch.
     */
    where?: IdeaDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdeaDiscussions to fetch.
     */
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IdeaDiscussions.
     */
    cursor?: IdeaDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdeaDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdeaDiscussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IdeaDiscussions.
     */
    distinct?: IdeaDiscussionScalarFieldEnum | IdeaDiscussionScalarFieldEnum[]
  }

  /**
   * IdeaDiscussion findMany
   */
  export type IdeaDiscussionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter, which IdeaDiscussions to fetch.
     */
    where?: IdeaDiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IdeaDiscussions to fetch.
     */
    orderBy?: IdeaDiscussionOrderByWithRelationInput | IdeaDiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IdeaDiscussions.
     */
    cursor?: IdeaDiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IdeaDiscussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IdeaDiscussions.
     */
    skip?: number
    distinct?: IdeaDiscussionScalarFieldEnum | IdeaDiscussionScalarFieldEnum[]
  }

  /**
   * IdeaDiscussion create
   */
  export type IdeaDiscussionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to create a IdeaDiscussion.
     */
    data: XOR<IdeaDiscussionCreateInput, IdeaDiscussionUncheckedCreateInput>
  }

  /**
   * IdeaDiscussion createMany
   */
  export type IdeaDiscussionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IdeaDiscussions.
     */
    data: IdeaDiscussionCreateManyInput | IdeaDiscussionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IdeaDiscussion createManyAndReturn
   */
  export type IdeaDiscussionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * The data used to create many IdeaDiscussions.
     */
    data: IdeaDiscussionCreateManyInput | IdeaDiscussionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdeaDiscussion update
   */
  export type IdeaDiscussionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * The data needed to update a IdeaDiscussion.
     */
    data: XOR<IdeaDiscussionUpdateInput, IdeaDiscussionUncheckedUpdateInput>
    /**
     * Choose, which IdeaDiscussion to update.
     */
    where: IdeaDiscussionWhereUniqueInput
  }

  /**
   * IdeaDiscussion updateMany
   */
  export type IdeaDiscussionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IdeaDiscussions.
     */
    data: XOR<IdeaDiscussionUpdateManyMutationInput, IdeaDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which IdeaDiscussions to update
     */
    where?: IdeaDiscussionWhereInput
    /**
     * Limit how many IdeaDiscussions to update.
     */
    limit?: number
  }

  /**
   * IdeaDiscussion updateManyAndReturn
   */
  export type IdeaDiscussionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * The data used to update IdeaDiscussions.
     */
    data: XOR<IdeaDiscussionUpdateManyMutationInput, IdeaDiscussionUncheckedUpdateManyInput>
    /**
     * Filter which IdeaDiscussions to update
     */
    where?: IdeaDiscussionWhereInput
    /**
     * Limit how many IdeaDiscussions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IdeaDiscussion upsert
   */
  export type IdeaDiscussionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * The filter to search for the IdeaDiscussion to update in case it exists.
     */
    where: IdeaDiscussionWhereUniqueInput
    /**
     * In case the IdeaDiscussion found by the `where` argument doesn't exist, create a new IdeaDiscussion with this data.
     */
    create: XOR<IdeaDiscussionCreateInput, IdeaDiscussionUncheckedCreateInput>
    /**
     * In case the IdeaDiscussion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IdeaDiscussionUpdateInput, IdeaDiscussionUncheckedUpdateInput>
  }

  /**
   * IdeaDiscussion delete
   */
  export type IdeaDiscussionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
    /**
     * Filter which IdeaDiscussion to delete.
     */
    where: IdeaDiscussionWhereUniqueInput
  }

  /**
   * IdeaDiscussion deleteMany
   */
  export type IdeaDiscussionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IdeaDiscussions to delete
     */
    where?: IdeaDiscussionWhereInput
    /**
     * Limit how many IdeaDiscussions to delete.
     */
    limit?: number
  }

  /**
   * IdeaDiscussion.sessions
   */
  export type IdeaDiscussion$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingSession
     */
    select?: BiddingSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BiddingSession
     */
    omit?: BiddingSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiddingSessionInclude<ExtArgs> | null
    where?: BiddingSessionWhereInput
    orderBy?: BiddingSessionOrderByWithRelationInput | BiddingSessionOrderByWithRelationInput[]
    cursor?: BiddingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiddingSessionScalarFieldEnum | BiddingSessionScalarFieldEnum[]
  }

  /**
   * IdeaDiscussion.messages
   */
  export type IdeaDiscussion$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    where?: DiscussionMessageWhereInput
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    cursor?: DiscussionMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * IdeaDiscussion without action
   */
  export type IdeaDiscussionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IdeaDiscussion
     */
    select?: IdeaDiscussionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IdeaDiscussion
     */
    omit?: IdeaDiscussionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IdeaDiscussionInclude<ExtArgs> | null
  }


  /**
   * Model DiscussionMessage
   */

  export type AggregateDiscussionMessage = {
    _count: DiscussionMessageCountAggregateOutputType | null
    _avg: DiscussionMessageAvgAggregateOutputType | null
    _sum: DiscussionMessageSumAggregateOutputType | null
    _min: DiscussionMessageMinAggregateOutputType | null
    _max: DiscussionMessageMaxAggregateOutputType | null
  }

  export type DiscussionMessageAvgAggregateOutputType = {
    roundNumber: number | null
  }

  export type DiscussionMessageSumAggregateOutputType = {
    roundNumber: number | null
  }

  export type DiscussionMessageMinAggregateOutputType = {
    id: string | null
    discussionId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    roundNumber: number | null
    senderType: $Enums.SenderType | null
    senderName: string | null
    createdAt: Date | null
  }

  export type DiscussionMessageMaxAggregateOutputType = {
    id: string | null
    discussionId: string | null
    content: string | null
    messageType: $Enums.MessageType | null
    roundNumber: number | null
    senderType: $Enums.SenderType | null
    senderName: string | null
    createdAt: Date | null
  }

  export type DiscussionMessageCountAggregateOutputType = {
    id: number
    discussionId: number
    content: number
    messageType: number
    roundNumber: number
    senderType: number
    senderName: number
    analysisData: number
    suggestions: number
    createdAt: number
    _all: number
  }


  export type DiscussionMessageAvgAggregateInputType = {
    roundNumber?: true
  }

  export type DiscussionMessageSumAggregateInputType = {
    roundNumber?: true
  }

  export type DiscussionMessageMinAggregateInputType = {
    id?: true
    discussionId?: true
    content?: true
    messageType?: true
    roundNumber?: true
    senderType?: true
    senderName?: true
    createdAt?: true
  }

  export type DiscussionMessageMaxAggregateInputType = {
    id?: true
    discussionId?: true
    content?: true
    messageType?: true
    roundNumber?: true
    senderType?: true
    senderName?: true
    createdAt?: true
  }

  export type DiscussionMessageCountAggregateInputType = {
    id?: true
    discussionId?: true
    content?: true
    messageType?: true
    roundNumber?: true
    senderType?: true
    senderName?: true
    analysisData?: true
    suggestions?: true
    createdAt?: true
    _all?: true
  }

  export type DiscussionMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscussionMessage to aggregate.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscussionMessages
    **/
    _count?: true | DiscussionMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscussionMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscussionMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscussionMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscussionMessageMaxAggregateInputType
  }

  export type GetDiscussionMessageAggregateType<T extends DiscussionMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscussionMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscussionMessage[P]>
      : GetScalarType<T[P], AggregateDiscussionMessage[P]>
  }




  export type DiscussionMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionMessageWhereInput
    orderBy?: DiscussionMessageOrderByWithAggregationInput | DiscussionMessageOrderByWithAggregationInput[]
    by: DiscussionMessageScalarFieldEnum[] | DiscussionMessageScalarFieldEnum
    having?: DiscussionMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscussionMessageCountAggregateInputType | true
    _avg?: DiscussionMessageAvgAggregateInputType
    _sum?: DiscussionMessageSumAggregateInputType
    _min?: DiscussionMessageMinAggregateInputType
    _max?: DiscussionMessageMaxAggregateInputType
  }

  export type DiscussionMessageGroupByOutputType = {
    id: string
    discussionId: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName: string | null
    analysisData: JsonValue | null
    suggestions: JsonValue | null
    createdAt: Date
    _count: DiscussionMessageCountAggregateOutputType | null
    _avg: DiscussionMessageAvgAggregateOutputType | null
    _sum: DiscussionMessageSumAggregateOutputType | null
    _min: DiscussionMessageMinAggregateOutputType | null
    _max: DiscussionMessageMaxAggregateOutputType | null
  }

  type GetDiscussionMessageGroupByPayload<T extends DiscussionMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscussionMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscussionMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscussionMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DiscussionMessageGroupByOutputType[P]>
        }
      >
    >


  export type DiscussionMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    content?: boolean
    messageType?: boolean
    roundNumber?: boolean
    senderType?: boolean
    senderName?: boolean
    analysisData?: boolean
    suggestions?: boolean
    createdAt?: boolean
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    content?: boolean
    messageType?: boolean
    roundNumber?: boolean
    senderType?: boolean
    senderName?: boolean
    analysisData?: boolean
    suggestions?: boolean
    createdAt?: boolean
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discussionId?: boolean
    content?: boolean
    messageType?: boolean
    roundNumber?: boolean
    senderType?: boolean
    senderName?: boolean
    analysisData?: boolean
    suggestions?: boolean
    createdAt?: boolean
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discussionMessage"]>

  export type DiscussionMessageSelectScalar = {
    id?: boolean
    discussionId?: boolean
    content?: boolean
    messageType?: boolean
    roundNumber?: boolean
    senderType?: boolean
    senderName?: boolean
    analysisData?: boolean
    suggestions?: boolean
    createdAt?: boolean
  }

  export type DiscussionMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discussionId" | "content" | "messageType" | "roundNumber" | "senderType" | "senderName" | "analysisData" | "suggestions" | "createdAt", ExtArgs["result"]["discussionMessage"]>
  export type DiscussionMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }
  export type DiscussionMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }
  export type DiscussionMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discussion?: boolean | IdeaDiscussionDefaultArgs<ExtArgs>
  }

  export type $DiscussionMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscussionMessage"
    objects: {
      discussion: Prisma.$IdeaDiscussionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discussionId: string
      content: string
      messageType: $Enums.MessageType
      roundNumber: number
      senderType: $Enums.SenderType
      senderName: string | null
      analysisData: Prisma.JsonValue | null
      suggestions: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["discussionMessage"]>
    composites: {}
  }

  type DiscussionMessageGetPayload<S extends boolean | null | undefined | DiscussionMessageDefaultArgs> = $Result.GetResult<Prisma.$DiscussionMessagePayload, S>

  type DiscussionMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscussionMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscussionMessageCountAggregateInputType | true
    }

  export interface DiscussionMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscussionMessage'], meta: { name: 'DiscussionMessage' } }
    /**
     * Find zero or one DiscussionMessage that matches the filter.
     * @param {DiscussionMessageFindUniqueArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscussionMessageFindUniqueArgs>(args: SelectSubset<T, DiscussionMessageFindUniqueArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscussionMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscussionMessageFindUniqueOrThrowArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscussionMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscussionMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscussionMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindFirstArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscussionMessageFindFirstArgs>(args?: SelectSubset<T, DiscussionMessageFindFirstArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscussionMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindFirstOrThrowArgs} args - Arguments to find a DiscussionMessage
     * @example
     * // Get one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscussionMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscussionMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscussionMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscussionMessages
     * const discussionMessages = await prisma.discussionMessage.findMany()
     * 
     * // Get first 10 DiscussionMessages
     * const discussionMessages = await prisma.discussionMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscussionMessageFindManyArgs>(args?: SelectSubset<T, DiscussionMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscussionMessage.
     * @param {DiscussionMessageCreateArgs} args - Arguments to create a DiscussionMessage.
     * @example
     * // Create one DiscussionMessage
     * const DiscussionMessage = await prisma.discussionMessage.create({
     *   data: {
     *     // ... data to create a DiscussionMessage
     *   }
     * })
     * 
     */
    create<T extends DiscussionMessageCreateArgs>(args: SelectSubset<T, DiscussionMessageCreateArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscussionMessages.
     * @param {DiscussionMessageCreateManyArgs} args - Arguments to create many DiscussionMessages.
     * @example
     * // Create many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscussionMessageCreateManyArgs>(args?: SelectSubset<T, DiscussionMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscussionMessages and returns the data saved in the database.
     * @param {DiscussionMessageCreateManyAndReturnArgs} args - Arguments to create many DiscussionMessages.
     * @example
     * // Create many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscussionMessages and only return the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscussionMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscussionMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscussionMessage.
     * @param {DiscussionMessageDeleteArgs} args - Arguments to delete one DiscussionMessage.
     * @example
     * // Delete one DiscussionMessage
     * const DiscussionMessage = await prisma.discussionMessage.delete({
     *   where: {
     *     // ... filter to delete one DiscussionMessage
     *   }
     * })
     * 
     */
    delete<T extends DiscussionMessageDeleteArgs>(args: SelectSubset<T, DiscussionMessageDeleteArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscussionMessage.
     * @param {DiscussionMessageUpdateArgs} args - Arguments to update one DiscussionMessage.
     * @example
     * // Update one DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscussionMessageUpdateArgs>(args: SelectSubset<T, DiscussionMessageUpdateArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscussionMessages.
     * @param {DiscussionMessageDeleteManyArgs} args - Arguments to filter DiscussionMessages to delete.
     * @example
     * // Delete a few DiscussionMessages
     * const { count } = await prisma.discussionMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscussionMessageDeleteManyArgs>(args?: SelectSubset<T, DiscussionMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscussionMessageUpdateManyArgs>(args: SelectSubset<T, DiscussionMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscussionMessages and returns the data updated in the database.
     * @param {DiscussionMessageUpdateManyAndReturnArgs} args - Arguments to update many DiscussionMessages.
     * @example
     * // Update many DiscussionMessages
     * const discussionMessage = await prisma.discussionMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscussionMessages and only return the `id`
     * const discussionMessageWithIdOnly = await prisma.discussionMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscussionMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscussionMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscussionMessage.
     * @param {DiscussionMessageUpsertArgs} args - Arguments to update or create a DiscussionMessage.
     * @example
     * // Update or create a DiscussionMessage
     * const discussionMessage = await prisma.discussionMessage.upsert({
     *   create: {
     *     // ... data to create a DiscussionMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscussionMessage we want to update
     *   }
     * })
     */
    upsert<T extends DiscussionMessageUpsertArgs>(args: SelectSubset<T, DiscussionMessageUpsertArgs<ExtArgs>>): Prisma__DiscussionMessageClient<$Result.GetResult<Prisma.$DiscussionMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscussionMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageCountArgs} args - Arguments to filter DiscussionMessages to count.
     * @example
     * // Count the number of DiscussionMessages
     * const count = await prisma.discussionMessage.count({
     *   where: {
     *     // ... the filter for the DiscussionMessages we want to count
     *   }
     * })
    **/
    count<T extends DiscussionMessageCountArgs>(
      args?: Subset<T, DiscussionMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscussionMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscussionMessageAggregateArgs>(args: Subset<T, DiscussionMessageAggregateArgs>): Prisma.PrismaPromise<GetDiscussionMessageAggregateType<T>>

    /**
     * Group by DiscussionMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscussionMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscussionMessageGroupByArgs['orderBy'] }
        : { orderBy?: DiscussionMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscussionMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscussionMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscussionMessage model
   */
  readonly fields: DiscussionMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscussionMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscussionMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discussion<T extends IdeaDiscussionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IdeaDiscussionDefaultArgs<ExtArgs>>): Prisma__IdeaDiscussionClient<$Result.GetResult<Prisma.$IdeaDiscussionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscussionMessage model
   */
  interface DiscussionMessageFieldRefs {
    readonly id: FieldRef<"DiscussionMessage", 'String'>
    readonly discussionId: FieldRef<"DiscussionMessage", 'String'>
    readonly content: FieldRef<"DiscussionMessage", 'String'>
    readonly messageType: FieldRef<"DiscussionMessage", 'MessageType'>
    readonly roundNumber: FieldRef<"DiscussionMessage", 'Int'>
    readonly senderType: FieldRef<"DiscussionMessage", 'SenderType'>
    readonly senderName: FieldRef<"DiscussionMessage", 'String'>
    readonly analysisData: FieldRef<"DiscussionMessage", 'Json'>
    readonly suggestions: FieldRef<"DiscussionMessage", 'Json'>
    readonly createdAt: FieldRef<"DiscussionMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscussionMessage findUnique
   */
  export type DiscussionMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage findUniqueOrThrow
   */
  export type DiscussionMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage findFirst
   */
  export type DiscussionMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscussionMessages.
     */
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage findFirstOrThrow
   */
  export type DiscussionMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessage to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscussionMessages.
     */
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage findMany
   */
  export type DiscussionMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter, which DiscussionMessages to fetch.
     */
    where?: DiscussionMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscussionMessages to fetch.
     */
    orderBy?: DiscussionMessageOrderByWithRelationInput | DiscussionMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscussionMessages.
     */
    cursor?: DiscussionMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscussionMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscussionMessages.
     */
    skip?: number
    distinct?: DiscussionMessageScalarFieldEnum | DiscussionMessageScalarFieldEnum[]
  }

  /**
   * DiscussionMessage create
   */
  export type DiscussionMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscussionMessage.
     */
    data: XOR<DiscussionMessageCreateInput, DiscussionMessageUncheckedCreateInput>
  }

  /**
   * DiscussionMessage createMany
   */
  export type DiscussionMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscussionMessages.
     */
    data: DiscussionMessageCreateManyInput | DiscussionMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscussionMessage createManyAndReturn
   */
  export type DiscussionMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * The data used to create many DiscussionMessages.
     */
    data: DiscussionMessageCreateManyInput | DiscussionMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscussionMessage update
   */
  export type DiscussionMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscussionMessage.
     */
    data: XOR<DiscussionMessageUpdateInput, DiscussionMessageUncheckedUpdateInput>
    /**
     * Choose, which DiscussionMessage to update.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage updateMany
   */
  export type DiscussionMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscussionMessages.
     */
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which DiscussionMessages to update
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to update.
     */
    limit?: number
  }

  /**
   * DiscussionMessage updateManyAndReturn
   */
  export type DiscussionMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * The data used to update DiscussionMessages.
     */
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyInput>
    /**
     * Filter which DiscussionMessages to update
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscussionMessage upsert
   */
  export type DiscussionMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscussionMessage to update in case it exists.
     */
    where: DiscussionMessageWhereUniqueInput
    /**
     * In case the DiscussionMessage found by the `where` argument doesn't exist, create a new DiscussionMessage with this data.
     */
    create: XOR<DiscussionMessageCreateInput, DiscussionMessageUncheckedCreateInput>
    /**
     * In case the DiscussionMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscussionMessageUpdateInput, DiscussionMessageUncheckedUpdateInput>
  }

  /**
   * DiscussionMessage delete
   */
  export type DiscussionMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
    /**
     * Filter which DiscussionMessage to delete.
     */
    where: DiscussionMessageWhereUniqueInput
  }

  /**
   * DiscussionMessage deleteMany
   */
  export type DiscussionMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscussionMessages to delete
     */
    where?: DiscussionMessageWhereInput
    /**
     * Limit how many DiscussionMessages to delete.
     */
    limit?: number
  }

  /**
   * DiscussionMessage without action
   */
  export type DiscussionMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscussionMessage
     */
    select?: DiscussionMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscussionMessage
     */
    omit?: DiscussionMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionMessageInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    amount: number | null
  }

  export type OrderSumAggregateOutputType = {
    amount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: $Enums.OrderStatus | null
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    description: string | null
    status: $Enums.OrderStatus | null
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    paidAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    description: number
    status: number
    paymentMethod: number
    paymentId: number
    createdAt: number
    updatedAt: number
    paidAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    amount?: true
  }

  export type OrderSumAggregateInputType = {
    amount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    description?: true
    status?: true
    paymentMethod?: true
    paymentId?: true
    createdAt?: true
    updatedAt?: true
    paidAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    description: string
    status: $Enums.OrderStatus
    paymentMethod: string | null
    paymentId: string | null
    createdAt: Date
    updatedAt: Date
    paidAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    status?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paidAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "currency" | "description" | "status" | "paymentMethod" | "paymentId" | "createdAt" | "updatedAt" | "paidAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      description: string
      status: $Enums.OrderStatus
      paymentMethod: string | null
      paymentId: string | null
      createdAt: Date
      updatedAt: Date
      paidAt: Date | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly amount: FieldRef<"Order", 'Float'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly description: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly paymentId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type CartItemSumAggregateOutputType = {
    price: number | null
    quantity: number | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    price: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    agentId: string | null
    price: number | null
    quantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    userId: number
    agentId: number
    price: number
    quantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type CartItemSumAggregateInputType = {
    price?: true
    quantity?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    price?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    price?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    userId?: true
    agentId?: true
    price?: true
    quantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    userId: string
    agentId: string
    price: number | null
    quantity: number
    createdAt: Date
    updatedAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    agentId?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    userId?: boolean
    agentId?: boolean
    price?: boolean
    quantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "agentId" | "price" | "quantity" | "createdAt" | "updatedAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      agentId: string
      price: number | null
      quantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly userId: FieldRef<"CartItem", 'String'>
    readonly agentId: FieldRef<"CartItem", 'String'>
    readonly price: FieldRef<"CartItem", 'Float'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    price: number | null
    credits: number | null
  }

  export type AgentSumAggregateOutputType = {
    price: number | null
    credits: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.AgentType | null
    status: $Enums.AgentStatus | null
    price: number | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.AgentType | null
    status: $Enums.AgentStatus | null
    price: number | null
    credits: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    status: number
    price: number
    credits: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    price?: true
    credits?: true
  }

  export type AgentSumAggregateInputType = {
    price?: true
    credits?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    price?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    price?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    status?: true
    price?: true
    credits?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.AgentType
    status: $Enums.AgentStatus
    price: number | null
    credits: number | null
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    price?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    price?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    price?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    price?: boolean
    credits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "status" | "price" | "credits" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.AgentType
      status: $Enums.AgentStatus
      price: number | null
      credits: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly type: FieldRef<"Agent", 'AgentType'>
    readonly status: FieldRef<"Agent", 'AgentStatus'>
    readonly price: FieldRef<"Agent", 'Float'>
    readonly credits: FieldRef<"Agent", 'Int'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    avatar: 'avatar',
    bio: 'bio',
    status: 'status',
    role: 'role',
    isEmailVerified: 'isEmailVerified',
    isPhoneVerified: 'isPhoneVerified',
    credits: 'credits',
    level: 'level',
    totalSpent: 'totalSpent',
    totalEarned: 'totalEarned',
    totalGuesses: 'totalGuesses',
    guessAccuracy: 'guessAccuracy',
    guessEarnings: 'guessEarnings',
    guessLevel: 'guessLevel',
    levelProgress: 'levelProgress',
    consecutiveGuesses: 'consecutiveGuesses',
    bestStreak: 'bestStreak',
    favoriteAgent: 'favoriteAgent',
    emailNotifications: 'emailNotifications',
    marketingEmails: 'marketingEmails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const IdeaScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    tags: 'tags',
    userId: 'userId',
    isAnonymous: 'isAnonymous',
    status: 'status',
    visibility: 'visibility',
    viewCount: 'viewCount',
    likeCount: 'likeCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IdeaScalarFieldEnum = (typeof IdeaScalarFieldEnum)[keyof typeof IdeaScalarFieldEnum]


  export const BiddingSessionScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    userId: 'userId',
    startPrice: 'startPrice',
    currentHigh: 'currentHigh',
    winnerAgent: 'winnerAgent',
    winnerAgentType: 'winnerAgentType',
    finalPrice: 'finalPrice',
    status: 'status',
    phase: 'phase',
    enhancedByDiscussion: 'enhancedByDiscussion',
    discussionId: 'discussionId',
    enhancementScore: 'enhancementScore',
    participantCount: 'participantCount',
    viewerCount: 'viewerCount',
    maxViewerCount: 'maxViewerCount',
    totalInteractions: 'totalInteractions',
    durationSeconds: 'durationSeconds',
    discussionDuration: 'discussionDuration',
    biddingDuration: 'biddingDuration',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    discussionStartedAt: 'discussionStartedAt',
    biddingStartedAt: 'biddingStartedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    avgResponseTime: 'avgResponseTime',
    aiServiceCost: 'aiServiceCost',
    userEngagementScore: 'userEngagementScore',
    contentQualityScore: 'contentQualityScore'
  };

  export type BiddingSessionScalarFieldEnum = (typeof BiddingSessionScalarFieldEnum)[keyof typeof BiddingSessionScalarFieldEnum]


  export const BidScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    agentName: 'agentName',
    agentType: 'agentType',
    amount: 'amount',
    comment: 'comment',
    confidence: 'confidence',
    analysisData: 'analysisData',
    reasoning: 'reasoning',
    emotionalState: 'emotionalState',
    isScripted: 'isScripted',
    aiServiceUsed: 'aiServiceUsed',
    generationCost: 'generationCost',
    responseTimeMs: 'responseTimeMs',
    qualityScore: 'qualityScore',
    understandingDepth: 'understandingDepth',
    contextRichness: 'contextRichness',
    createdAt: 'createdAt'
  };

  export type BidScalarFieldEnum = (typeof BidScalarFieldEnum)[keyof typeof BidScalarFieldEnum]


  export const PriceGuessScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    guessedPrice: 'guessedPrice',
    confidence: 'confidence',
    stakeAmount: 'stakeAmount',
    actualPrice: 'actualPrice',
    accuracy: 'accuracy',
    reward: 'reward',
    basedOnDiscussion: 'basedOnDiscussion',
    predictionConfidenceBonus: 'predictionConfidenceBonus',
    timeSpentMs: 'timeSpentMs',
    adjustmentCount: 'adjustmentCount',
    createdAt: 'createdAt'
  };

  export type PriceGuessScalarFieldEnum = (typeof PriceGuessScalarFieldEnum)[keyof typeof PriceGuessScalarFieldEnum]


  export const AIInteractionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    agentName: 'agentName',
    agentType: 'agentType',
    interactionType: 'interactionType',
    phase: 'phase',
    content: 'content',
    emotion: 'emotion',
    animation: 'animation',
    isScripted: 'isScripted',
    aiServiceUsed: 'aiServiceUsed',
    generationCost: 'generationCost',
    responseTimeMs: 'responseTimeMs',
    qualityScore: 'qualityScore',
    userReactions: 'userReactions',
    engagementScore: 'engagementScore',
    isRandomEvent: 'isRandomEvent',
    eventType: 'eventType',
    createdAt: 'createdAt'
  };

  export type AIInteractionScalarFieldEnum = (typeof AIInteractionScalarFieldEnum)[keyof typeof AIInteractionScalarFieldEnum]


  export const UserBiddingBehaviorScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    actionType: 'actionType',
    actionData: 'actionData',
    timestamp: 'timestamp',
    phase: 'phase',
    agentName: 'agentName'
  };

  export type UserBiddingBehaviorScalarFieldEnum = (typeof UserBiddingBehaviorScalarFieldEnum)[keyof typeof UserBiddingBehaviorScalarFieldEnum]


  export const AIServiceUsageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    agentName: 'agentName',
    serviceName: 'serviceName',
    modelName: 'modelName',
    promptTokens: 'promptTokens',
    completionTokens: 'completionTokens',
    totalTokens: 'totalTokens',
    requestCount: 'requestCount',
    totalCost: 'totalCost',
    responseTimeMs: 'responseTimeMs',
    qualityRating: 'qualityRating',
    userSatisfaction: 'userSatisfaction',
    errorCount: 'errorCount',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    date: 'date'
  };

  export type AIServiceUsageScalarFieldEnum = (typeof AIServiceUsageScalarFieldEnum)[keyof typeof AIServiceUsageScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    achievementName: 'achievementName',
    description: 'description',
    category: 'category',
    bonusPoints: 'bonusPoints',
    earnedAt: 'earnedAt',
    progressData: 'progressData',
    isRare: 'isRare'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const ResearchReportScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    userId: 'userId',
    reportData: 'reportData',
    summary: 'summary',
    basicAnalysis: 'basicAnalysis',
    researchMethods: 'researchMethods',
    dataSources: 'dataSources',
    mvpGuidance: 'mvpGuidance',
    businessModel: 'businessModel',
    status: 'status',
    progress: 'progress',
    creditsCost: 'creditsCost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type ResearchReportScalarFieldEnum = (typeof ResearchReportScalarFieldEnum)[keyof typeof ResearchReportScalarFieldEnum]


  export const CreditTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    type: 'type',
    description: 'description',
    relatedId: 'relatedId',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    createdAt: 'createdAt'
  };

  export type CreditTransactionScalarFieldEnum = (typeof CreditTransactionScalarFieldEnum)[keyof typeof CreditTransactionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    outTradeNo: 'outTradeNo',
    amount: 'amount',
    credits: 'credits',
    description: 'description',
    currency: 'currency',
    provider: 'provider',
    providerOrderId: 'providerOrderId',
    payUrl: 'payUrl',
    qrCodeUrl: 'qrCodeUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paidAt: 'paidAt',
    expiredAt: 'expiredAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    outRefundNo: 'outRefundNo',
    refundAmount: 'refundAmount',
    reason: 'reason',
    status: 'status',
    providerRefundId: 'providerRefundId',
    operatorId: 'operatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    refundedAt: 'refundedAt'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    filename: 'filename',
    originalName: 'originalName',
    key: 'key',
    url: 'url',
    size: 'size',
    contentType: 'contentType',
    type: 'type',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const AIUsageStatsScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    model: 'model',
    requestCount: 'requestCount',
    totalTokens: 'totalTokens',
    totalCost: 'totalCost',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIUsageStatsScalarFieldEnum = (typeof AIUsageStatsScalarFieldEnum)[keyof typeof AIUsageStatsScalarFieldEnum]


  export const IdeaDiscussionScalarFieldEnum: {
    id: 'id',
    ideaId: 'ideaId',
    userId: 'userId',
    status: 'status',
    currentRound: 'currentRound',
    totalRounds: 'totalRounds',
    aiAgentType: 'aiAgentType',
    aiAgentName: 'aiAgentName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completedAt: 'completedAt'
  };

  export type IdeaDiscussionScalarFieldEnum = (typeof IdeaDiscussionScalarFieldEnum)[keyof typeof IdeaDiscussionScalarFieldEnum]


  export const DiscussionMessageScalarFieldEnum: {
    id: 'id',
    discussionId: 'discussionId',
    content: 'content',
    messageType: 'messageType',
    roundNumber: 'roundNumber',
    senderType: 'senderType',
    senderName: 'senderName',
    analysisData: 'analysisData',
    suggestions: 'suggestions',
    createdAt: 'createdAt'
  };

  export type DiscussionMessageScalarFieldEnum = (typeof DiscussionMessageScalarFieldEnum)[keyof typeof DiscussionMessageScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    status: 'status',
    paymentMethod: 'paymentMethod',
    paymentId: 'paymentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paidAt: 'paidAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    agentId: 'agentId',
    price: 'price',
    quantity: 'quantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    status: 'status',
    price: 'price',
    credits: 'credits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserLevel'
   */
  export type EnumUserLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLevel'>
    


  /**
   * Reference to a field of type 'UserLevel[]'
   */
  export type ListEnumUserLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'IdeaCategory'
   */
  export type EnumIdeaCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaCategory'>
    


  /**
   * Reference to a field of type 'IdeaCategory[]'
   */
  export type ListEnumIdeaCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaCategory[]'>
    


  /**
   * Reference to a field of type 'IdeaStatus'
   */
  export type EnumIdeaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaStatus'>
    


  /**
   * Reference to a field of type 'IdeaStatus[]'
   */
  export type ListEnumIdeaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaStatus[]'>
    


  /**
   * Reference to a field of type 'IdeaVisibility'
   */
  export type EnumIdeaVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaVisibility'>
    


  /**
   * Reference to a field of type 'IdeaVisibility[]'
   */
  export type ListEnumIdeaVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdeaVisibility[]'>
    


  /**
   * Reference to a field of type 'BiddingStatus'
   */
  export type EnumBiddingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiddingStatus'>
    


  /**
   * Reference to a field of type 'BiddingStatus[]'
   */
  export type ListEnumBiddingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiddingStatus[]'>
    


  /**
   * Reference to a field of type 'BiddingPhase'
   */
  export type EnumBiddingPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiddingPhase'>
    


  /**
   * Reference to a field of type 'BiddingPhase[]'
   */
  export type ListEnumBiddingPhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiddingPhase[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AIInteractionType'
   */
  export type EnumAIInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIInteractionType'>
    


  /**
   * Reference to a field of type 'AIInteractionType[]'
   */
  export type ListEnumAIInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AIInteractionType[]'>
    


  /**
   * Reference to a field of type 'UserBiddingAction'
   */
  export type EnumUserBiddingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserBiddingAction'>
    


  /**
   * Reference to a field of type 'UserBiddingAction[]'
   */
  export type ListEnumUserBiddingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserBiddingAction[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'CreditTransactionType'
   */
  export type EnumCreditTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditTransactionType'>
    


  /**
   * Reference to a field of type 'CreditTransactionType[]'
   */
  export type ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditTransactionType[]'>
    


  /**
   * Reference to a field of type 'DiscussionStatus'
   */
  export type EnumDiscussionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscussionStatus'>
    


  /**
   * Reference to a field of type 'DiscussionStatus[]'
   */
  export type ListEnumDiscussionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscussionStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'AgentType'
   */
  export type EnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType'>
    


  /**
   * Reference to a field of type 'AgentType[]'
   */
  export type ListEnumAgentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentType[]'>
    


  /**
   * Reference to a field of type 'AgentStatus'
   */
  export type EnumAgentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentStatus'>
    


  /**
   * Reference to a field of type 'AgentStatus[]'
   */
  export type ListEnumAgentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgentStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    credits?: IntFilter<"User"> | number
    level?: EnumUserLevelFilter<"User"> | $Enums.UserLevel
    totalSpent?: IntFilter<"User"> | number
    totalEarned?: IntFilter<"User"> | number
    totalGuesses?: IntFilter<"User"> | number
    guessAccuracy?: FloatFilter<"User"> | number
    guessEarnings?: IntFilter<"User"> | number
    guessLevel?: IntFilter<"User"> | number
    levelProgress?: FloatFilter<"User"> | number
    consecutiveGuesses?: IntFilter<"User"> | number
    bestStreak?: IntFilter<"User"> | number
    favoriteAgent?: StringNullableFilter<"User"> | string | null
    emailNotifications?: BoolFilter<"User"> | boolean
    marketingEmails?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ideas?: IdeaListRelationFilter
    researchReports?: ResearchReportListRelationFilter
    creditTransactions?: CreditTransactionListRelationFilter
    payments?: PaymentListRelationFilter
    sessions?: UserSessionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    files?: FileListRelationFilter
    discussions?: IdeaDiscussionListRelationFilter
    orders?: OrderListRelationFilter
    cartItems?: CartItemListRelationFilter
    biddingSessions?: BiddingSessionListRelationFilter
    priceGuesses?: PriceGuessListRelationFilter
    biddingBehaviors?: UserBiddingBehaviorListRelationFilter
    achievements?: UserAchievementListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    credits?: SortOrder
    level?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
    favoriteAgent?: SortOrderInput | SortOrder
    emailNotifications?: SortOrder
    marketingEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    ideas?: IdeaOrderByRelationAggregateInput
    researchReports?: ResearchReportOrderByRelationAggregateInput
    creditTransactions?: CreditTransactionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    discussions?: IdeaDiscussionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    biddingSessions?: BiddingSessionOrderByRelationAggregateInput
    priceGuesses?: PriceGuessOrderByRelationAggregateInput
    biddingBehaviors?: UserBiddingBehaviorOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    credits?: IntFilter<"User"> | number
    level?: EnumUserLevelFilter<"User"> | $Enums.UserLevel
    totalSpent?: IntFilter<"User"> | number
    totalEarned?: IntFilter<"User"> | number
    totalGuesses?: IntFilter<"User"> | number
    guessAccuracy?: FloatFilter<"User"> | number
    guessEarnings?: IntFilter<"User"> | number
    guessLevel?: IntFilter<"User"> | number
    levelProgress?: FloatFilter<"User"> | number
    consecutiveGuesses?: IntFilter<"User"> | number
    bestStreak?: IntFilter<"User"> | number
    favoriteAgent?: StringNullableFilter<"User"> | string | null
    emailNotifications?: BoolFilter<"User"> | boolean
    marketingEmails?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ideas?: IdeaListRelationFilter
    researchReports?: ResearchReportListRelationFilter
    creditTransactions?: CreditTransactionListRelationFilter
    payments?: PaymentListRelationFilter
    sessions?: UserSessionListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    files?: FileListRelationFilter
    discussions?: IdeaDiscussionListRelationFilter
    orders?: OrderListRelationFilter
    cartItems?: CartItemListRelationFilter
    biddingSessions?: BiddingSessionListRelationFilter
    priceGuesses?: PriceGuessListRelationFilter
    biddingBehaviors?: UserBiddingBehaviorListRelationFilter
    achievements?: UserAchievementListRelationFilter
  }, "id" | "email" | "username" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    status?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    credits?: SortOrder
    level?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
    favoriteAgent?: SortOrderInput | SortOrder
    emailNotifications?: SortOrder
    marketingEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isPhoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    credits?: IntWithAggregatesFilter<"User"> | number
    level?: EnumUserLevelWithAggregatesFilter<"User"> | $Enums.UserLevel
    totalSpent?: IntWithAggregatesFilter<"User"> | number
    totalEarned?: IntWithAggregatesFilter<"User"> | number
    totalGuesses?: IntWithAggregatesFilter<"User"> | number
    guessAccuracy?: FloatWithAggregatesFilter<"User"> | number
    guessEarnings?: IntWithAggregatesFilter<"User"> | number
    guessLevel?: IntWithAggregatesFilter<"User"> | number
    levelProgress?: FloatWithAggregatesFilter<"User"> | number
    consecutiveGuesses?: IntWithAggregatesFilter<"User"> | number
    bestStreak?: IntWithAggregatesFilter<"User"> | number
    favoriteAgent?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailNotifications?: BoolWithAggregatesFilter<"User"> | boolean
    marketingEmails?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type IdeaWhereInput = {
    AND?: IdeaWhereInput | IdeaWhereInput[]
    OR?: IdeaWhereInput[]
    NOT?: IdeaWhereInput | IdeaWhereInput[]
    id?: StringFilter<"Idea"> | string
    title?: StringFilter<"Idea"> | string
    description?: StringFilter<"Idea"> | string
    category?: EnumIdeaCategoryFilter<"Idea"> | $Enums.IdeaCategory
    tags?: StringFilter<"Idea"> | string
    userId?: StringFilter<"Idea"> | string
    isAnonymous?: BoolFilter<"Idea"> | boolean
    status?: EnumIdeaStatusFilter<"Idea"> | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFilter<"Idea"> | $Enums.IdeaVisibility
    viewCount?: IntFilter<"Idea"> | number
    likeCount?: IntFilter<"Idea"> | number
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    researchReports?: ResearchReportListRelationFilter
    discussions?: IdeaDiscussionListRelationFilter
    biddingSessions?: BiddingSessionListRelationFilter
  }

  export type IdeaOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    researchReports?: ResearchReportOrderByRelationAggregateInput
    discussions?: IdeaDiscussionOrderByRelationAggregateInput
    biddingSessions?: BiddingSessionOrderByRelationAggregateInput
  }

  export type IdeaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IdeaWhereInput | IdeaWhereInput[]
    OR?: IdeaWhereInput[]
    NOT?: IdeaWhereInput | IdeaWhereInput[]
    title?: StringFilter<"Idea"> | string
    description?: StringFilter<"Idea"> | string
    category?: EnumIdeaCategoryFilter<"Idea"> | $Enums.IdeaCategory
    tags?: StringFilter<"Idea"> | string
    userId?: StringFilter<"Idea"> | string
    isAnonymous?: BoolFilter<"Idea"> | boolean
    status?: EnumIdeaStatusFilter<"Idea"> | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFilter<"Idea"> | $Enums.IdeaVisibility
    viewCount?: IntFilter<"Idea"> | number
    likeCount?: IntFilter<"Idea"> | number
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    researchReports?: ResearchReportListRelationFilter
    discussions?: IdeaDiscussionListRelationFilter
    biddingSessions?: BiddingSessionListRelationFilter
  }, "id">

  export type IdeaOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IdeaCountOrderByAggregateInput
    _avg?: IdeaAvgOrderByAggregateInput
    _max?: IdeaMaxOrderByAggregateInput
    _min?: IdeaMinOrderByAggregateInput
    _sum?: IdeaSumOrderByAggregateInput
  }

  export type IdeaScalarWhereWithAggregatesInput = {
    AND?: IdeaScalarWhereWithAggregatesInput | IdeaScalarWhereWithAggregatesInput[]
    OR?: IdeaScalarWhereWithAggregatesInput[]
    NOT?: IdeaScalarWhereWithAggregatesInput | IdeaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Idea"> | string
    title?: StringWithAggregatesFilter<"Idea"> | string
    description?: StringWithAggregatesFilter<"Idea"> | string
    category?: EnumIdeaCategoryWithAggregatesFilter<"Idea"> | $Enums.IdeaCategory
    tags?: StringWithAggregatesFilter<"Idea"> | string
    userId?: StringWithAggregatesFilter<"Idea"> | string
    isAnonymous?: BoolWithAggregatesFilter<"Idea"> | boolean
    status?: EnumIdeaStatusWithAggregatesFilter<"Idea"> | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityWithAggregatesFilter<"Idea"> | $Enums.IdeaVisibility
    viewCount?: IntWithAggregatesFilter<"Idea"> | number
    likeCount?: IntWithAggregatesFilter<"Idea"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Idea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Idea"> | Date | string
  }

  export type BiddingSessionWhereInput = {
    AND?: BiddingSessionWhereInput | BiddingSessionWhereInput[]
    OR?: BiddingSessionWhereInput[]
    NOT?: BiddingSessionWhereInput | BiddingSessionWhereInput[]
    id?: StringFilter<"BiddingSession"> | string
    ideaId?: StringFilter<"BiddingSession"> | string
    userId?: StringNullableFilter<"BiddingSession"> | string | null
    startPrice?: IntFilter<"BiddingSession"> | number
    currentHigh?: IntFilter<"BiddingSession"> | number
    winnerAgent?: StringNullableFilter<"BiddingSession"> | string | null
    winnerAgentType?: StringNullableFilter<"BiddingSession"> | string | null
    finalPrice?: IntNullableFilter<"BiddingSession"> | number | null
    status?: EnumBiddingStatusFilter<"BiddingSession"> | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFilter<"BiddingSession"> | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFilter<"BiddingSession"> | boolean
    discussionId?: StringNullableFilter<"BiddingSession"> | string | null
    enhancementScore?: FloatFilter<"BiddingSession"> | number
    participantCount?: IntFilter<"BiddingSession"> | number
    viewerCount?: IntFilter<"BiddingSession"> | number
    maxViewerCount?: IntFilter<"BiddingSession"> | number
    totalInteractions?: IntFilter<"BiddingSession"> | number
    durationSeconds?: IntFilter<"BiddingSession"> | number
    discussionDuration?: IntFilter<"BiddingSession"> | number
    biddingDuration?: IntFilter<"BiddingSession"> | number
    startedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    discussionStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    biddingStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    createdAt?: DateTimeFilter<"BiddingSession"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingSession"> | Date | string
    avgResponseTime?: FloatFilter<"BiddingSession"> | number
    aiServiceCost?: FloatFilter<"BiddingSession"> | number
    userEngagementScore?: FloatFilter<"BiddingSession"> | number
    contentQualityScore?: FloatFilter<"BiddingSession"> | number
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    discussion?: XOR<IdeaDiscussionNullableScalarRelationFilter, IdeaDiscussionWhereInput> | null
    bids?: BidListRelationFilter
    priceGuesses?: PriceGuessListRelationFilter
    interactions?: AIInteractionListRelationFilter
    behaviors?: UserBiddingBehaviorListRelationFilter
  }

  export type BiddingSessionOrderByWithRelationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrderInput | SortOrder
    startPrice?: SortOrder
    currentHigh?: SortOrder
    winnerAgent?: SortOrderInput | SortOrder
    winnerAgentType?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    phase?: SortOrder
    enhancedByDiscussion?: SortOrder
    discussionId?: SortOrderInput | SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    discussionStartedAt?: SortOrderInput | SortOrder
    biddingStartedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
    idea?: IdeaOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    discussion?: IdeaDiscussionOrderByWithRelationInput
    bids?: BidOrderByRelationAggregateInput
    priceGuesses?: PriceGuessOrderByRelationAggregateInput
    interactions?: AIInteractionOrderByRelationAggregateInput
    behaviors?: UserBiddingBehaviorOrderByRelationAggregateInput
  }

  export type BiddingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiddingSessionWhereInput | BiddingSessionWhereInput[]
    OR?: BiddingSessionWhereInput[]
    NOT?: BiddingSessionWhereInput | BiddingSessionWhereInput[]
    ideaId?: StringFilter<"BiddingSession"> | string
    userId?: StringNullableFilter<"BiddingSession"> | string | null
    startPrice?: IntFilter<"BiddingSession"> | number
    currentHigh?: IntFilter<"BiddingSession"> | number
    winnerAgent?: StringNullableFilter<"BiddingSession"> | string | null
    winnerAgentType?: StringNullableFilter<"BiddingSession"> | string | null
    finalPrice?: IntNullableFilter<"BiddingSession"> | number | null
    status?: EnumBiddingStatusFilter<"BiddingSession"> | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFilter<"BiddingSession"> | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFilter<"BiddingSession"> | boolean
    discussionId?: StringNullableFilter<"BiddingSession"> | string | null
    enhancementScore?: FloatFilter<"BiddingSession"> | number
    participantCount?: IntFilter<"BiddingSession"> | number
    viewerCount?: IntFilter<"BiddingSession"> | number
    maxViewerCount?: IntFilter<"BiddingSession"> | number
    totalInteractions?: IntFilter<"BiddingSession"> | number
    durationSeconds?: IntFilter<"BiddingSession"> | number
    discussionDuration?: IntFilter<"BiddingSession"> | number
    biddingDuration?: IntFilter<"BiddingSession"> | number
    startedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    discussionStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    biddingStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    createdAt?: DateTimeFilter<"BiddingSession"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingSession"> | Date | string
    avgResponseTime?: FloatFilter<"BiddingSession"> | number
    aiServiceCost?: FloatFilter<"BiddingSession"> | number
    userEngagementScore?: FloatFilter<"BiddingSession"> | number
    contentQualityScore?: FloatFilter<"BiddingSession"> | number
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    discussion?: XOR<IdeaDiscussionNullableScalarRelationFilter, IdeaDiscussionWhereInput> | null
    bids?: BidListRelationFilter
    priceGuesses?: PriceGuessListRelationFilter
    interactions?: AIInteractionListRelationFilter
    behaviors?: UserBiddingBehaviorListRelationFilter
  }, "id">

  export type BiddingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrderInput | SortOrder
    startPrice?: SortOrder
    currentHigh?: SortOrder
    winnerAgent?: SortOrderInput | SortOrder
    winnerAgentType?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    status?: SortOrder
    phase?: SortOrder
    enhancedByDiscussion?: SortOrder
    discussionId?: SortOrderInput | SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    discussionStartedAt?: SortOrderInput | SortOrder
    biddingStartedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
    _count?: BiddingSessionCountOrderByAggregateInput
    _avg?: BiddingSessionAvgOrderByAggregateInput
    _max?: BiddingSessionMaxOrderByAggregateInput
    _min?: BiddingSessionMinOrderByAggregateInput
    _sum?: BiddingSessionSumOrderByAggregateInput
  }

  export type BiddingSessionScalarWhereWithAggregatesInput = {
    AND?: BiddingSessionScalarWhereWithAggregatesInput | BiddingSessionScalarWhereWithAggregatesInput[]
    OR?: BiddingSessionScalarWhereWithAggregatesInput[]
    NOT?: BiddingSessionScalarWhereWithAggregatesInput | BiddingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiddingSession"> | string
    ideaId?: StringWithAggregatesFilter<"BiddingSession"> | string
    userId?: StringNullableWithAggregatesFilter<"BiddingSession"> | string | null
    startPrice?: IntWithAggregatesFilter<"BiddingSession"> | number
    currentHigh?: IntWithAggregatesFilter<"BiddingSession"> | number
    winnerAgent?: StringNullableWithAggregatesFilter<"BiddingSession"> | string | null
    winnerAgentType?: StringNullableWithAggregatesFilter<"BiddingSession"> | string | null
    finalPrice?: IntNullableWithAggregatesFilter<"BiddingSession"> | number | null
    status?: EnumBiddingStatusWithAggregatesFilter<"BiddingSession"> | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseWithAggregatesFilter<"BiddingSession"> | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolWithAggregatesFilter<"BiddingSession"> | boolean
    discussionId?: StringNullableWithAggregatesFilter<"BiddingSession"> | string | null
    enhancementScore?: FloatWithAggregatesFilter<"BiddingSession"> | number
    participantCount?: IntWithAggregatesFilter<"BiddingSession"> | number
    viewerCount?: IntWithAggregatesFilter<"BiddingSession"> | number
    maxViewerCount?: IntWithAggregatesFilter<"BiddingSession"> | number
    totalInteractions?: IntWithAggregatesFilter<"BiddingSession"> | number
    durationSeconds?: IntWithAggregatesFilter<"BiddingSession"> | number
    discussionDuration?: IntWithAggregatesFilter<"BiddingSession"> | number
    biddingDuration?: IntWithAggregatesFilter<"BiddingSession"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"BiddingSession"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"BiddingSession"> | Date | string | null
    discussionStartedAt?: DateTimeNullableWithAggregatesFilter<"BiddingSession"> | Date | string | null
    biddingStartedAt?: DateTimeNullableWithAggregatesFilter<"BiddingSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BiddingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiddingSession"> | Date | string
    avgResponseTime?: FloatWithAggregatesFilter<"BiddingSession"> | number
    aiServiceCost?: FloatWithAggregatesFilter<"BiddingSession"> | number
    userEngagementScore?: FloatWithAggregatesFilter<"BiddingSession"> | number
    contentQualityScore?: FloatWithAggregatesFilter<"BiddingSession"> | number
  }

  export type BidWhereInput = {
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    id?: StringFilter<"Bid"> | string
    sessionId?: StringFilter<"Bid"> | string
    agentName?: StringFilter<"Bid"> | string
    agentType?: StringFilter<"Bid"> | string
    amount?: IntFilter<"Bid"> | number
    comment?: StringNullableFilter<"Bid"> | string | null
    confidence?: FloatNullableFilter<"Bid"> | number | null
    analysisData?: JsonNullableFilter<"Bid">
    reasoning?: StringNullableFilter<"Bid"> | string | null
    emotionalState?: StringFilter<"Bid"> | string
    isScripted?: BoolFilter<"Bid"> | boolean
    aiServiceUsed?: StringNullableFilter<"Bid"> | string | null
    generationCost?: FloatFilter<"Bid"> | number
    responseTimeMs?: IntFilter<"Bid"> | number
    qualityScore?: FloatFilter<"Bid"> | number
    understandingDepth?: FloatFilter<"Bid"> | number
    contextRichness?: FloatFilter<"Bid"> | number
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
  }

  export type BidOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    amount?: SortOrder
    comment?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    emotionalState?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrderInput | SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
    createdAt?: SortOrder
    session?: BiddingSessionOrderByWithRelationInput
  }

  export type BidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BidWhereInput | BidWhereInput[]
    OR?: BidWhereInput[]
    NOT?: BidWhereInput | BidWhereInput[]
    sessionId?: StringFilter<"Bid"> | string
    agentName?: StringFilter<"Bid"> | string
    agentType?: StringFilter<"Bid"> | string
    amount?: IntFilter<"Bid"> | number
    comment?: StringNullableFilter<"Bid"> | string | null
    confidence?: FloatNullableFilter<"Bid"> | number | null
    analysisData?: JsonNullableFilter<"Bid">
    reasoning?: StringNullableFilter<"Bid"> | string | null
    emotionalState?: StringFilter<"Bid"> | string
    isScripted?: BoolFilter<"Bid"> | boolean
    aiServiceUsed?: StringNullableFilter<"Bid"> | string | null
    generationCost?: FloatFilter<"Bid"> | number
    responseTimeMs?: IntFilter<"Bid"> | number
    qualityScore?: FloatFilter<"Bid"> | number
    understandingDepth?: FloatFilter<"Bid"> | number
    contextRichness?: FloatFilter<"Bid"> | number
    createdAt?: DateTimeFilter<"Bid"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
  }, "id">

  export type BidOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    amount?: SortOrder
    comment?: SortOrderInput | SortOrder
    confidence?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    reasoning?: SortOrderInput | SortOrder
    emotionalState?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrderInput | SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
    createdAt?: SortOrder
    _count?: BidCountOrderByAggregateInput
    _avg?: BidAvgOrderByAggregateInput
    _max?: BidMaxOrderByAggregateInput
    _min?: BidMinOrderByAggregateInput
    _sum?: BidSumOrderByAggregateInput
  }

  export type BidScalarWhereWithAggregatesInput = {
    AND?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    OR?: BidScalarWhereWithAggregatesInput[]
    NOT?: BidScalarWhereWithAggregatesInput | BidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bid"> | string
    sessionId?: StringWithAggregatesFilter<"Bid"> | string
    agentName?: StringWithAggregatesFilter<"Bid"> | string
    agentType?: StringWithAggregatesFilter<"Bid"> | string
    amount?: IntWithAggregatesFilter<"Bid"> | number
    comment?: StringNullableWithAggregatesFilter<"Bid"> | string | null
    confidence?: FloatNullableWithAggregatesFilter<"Bid"> | number | null
    analysisData?: JsonNullableWithAggregatesFilter<"Bid">
    reasoning?: StringNullableWithAggregatesFilter<"Bid"> | string | null
    emotionalState?: StringWithAggregatesFilter<"Bid"> | string
    isScripted?: BoolWithAggregatesFilter<"Bid"> | boolean
    aiServiceUsed?: StringNullableWithAggregatesFilter<"Bid"> | string | null
    generationCost?: FloatWithAggregatesFilter<"Bid"> | number
    responseTimeMs?: IntWithAggregatesFilter<"Bid"> | number
    qualityScore?: FloatWithAggregatesFilter<"Bid"> | number
    understandingDepth?: FloatWithAggregatesFilter<"Bid"> | number
    contextRichness?: FloatWithAggregatesFilter<"Bid"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Bid"> | Date | string
  }

  export type PriceGuessWhereInput = {
    AND?: PriceGuessWhereInput | PriceGuessWhereInput[]
    OR?: PriceGuessWhereInput[]
    NOT?: PriceGuessWhereInput | PriceGuessWhereInput[]
    id?: StringFilter<"PriceGuess"> | string
    sessionId?: StringFilter<"PriceGuess"> | string
    userId?: StringFilter<"PriceGuess"> | string
    guessedPrice?: IntFilter<"PriceGuess"> | number
    confidence?: FloatFilter<"PriceGuess"> | number
    stakeAmount?: IntFilter<"PriceGuess"> | number
    actualPrice?: IntNullableFilter<"PriceGuess"> | number | null
    accuracy?: FloatNullableFilter<"PriceGuess"> | number | null
    reward?: IntNullableFilter<"PriceGuess"> | number | null
    basedOnDiscussion?: BoolFilter<"PriceGuess"> | boolean
    predictionConfidenceBonus?: FloatFilter<"PriceGuess"> | number
    timeSpentMs?: IntNullableFilter<"PriceGuess"> | number | null
    adjustmentCount?: IntFilter<"PriceGuess"> | number
    createdAt?: DateTimeFilter<"PriceGuess"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PriceGuessOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    reward?: SortOrderInput | SortOrder
    basedOnDiscussion?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrderInput | SortOrder
    adjustmentCount?: SortOrder
    createdAt?: SortOrder
    session?: BiddingSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PriceGuessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_userId?: PriceGuessSessionIdUserIdCompoundUniqueInput
    AND?: PriceGuessWhereInput | PriceGuessWhereInput[]
    OR?: PriceGuessWhereInput[]
    NOT?: PriceGuessWhereInput | PriceGuessWhereInput[]
    sessionId?: StringFilter<"PriceGuess"> | string
    userId?: StringFilter<"PriceGuess"> | string
    guessedPrice?: IntFilter<"PriceGuess"> | number
    confidence?: FloatFilter<"PriceGuess"> | number
    stakeAmount?: IntFilter<"PriceGuess"> | number
    actualPrice?: IntNullableFilter<"PriceGuess"> | number | null
    accuracy?: FloatNullableFilter<"PriceGuess"> | number | null
    reward?: IntNullableFilter<"PriceGuess"> | number | null
    basedOnDiscussion?: BoolFilter<"PriceGuess"> | boolean
    predictionConfidenceBonus?: FloatFilter<"PriceGuess"> | number
    timeSpentMs?: IntNullableFilter<"PriceGuess"> | number | null
    adjustmentCount?: IntFilter<"PriceGuess"> | number
    createdAt?: DateTimeFilter<"PriceGuess"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionId_userId">

  export type PriceGuessOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    reward?: SortOrderInput | SortOrder
    basedOnDiscussion?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrderInput | SortOrder
    adjustmentCount?: SortOrder
    createdAt?: SortOrder
    _count?: PriceGuessCountOrderByAggregateInput
    _avg?: PriceGuessAvgOrderByAggregateInput
    _max?: PriceGuessMaxOrderByAggregateInput
    _min?: PriceGuessMinOrderByAggregateInput
    _sum?: PriceGuessSumOrderByAggregateInput
  }

  export type PriceGuessScalarWhereWithAggregatesInput = {
    AND?: PriceGuessScalarWhereWithAggregatesInput | PriceGuessScalarWhereWithAggregatesInput[]
    OR?: PriceGuessScalarWhereWithAggregatesInput[]
    NOT?: PriceGuessScalarWhereWithAggregatesInput | PriceGuessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceGuess"> | string
    sessionId?: StringWithAggregatesFilter<"PriceGuess"> | string
    userId?: StringWithAggregatesFilter<"PriceGuess"> | string
    guessedPrice?: IntWithAggregatesFilter<"PriceGuess"> | number
    confidence?: FloatWithAggregatesFilter<"PriceGuess"> | number
    stakeAmount?: IntWithAggregatesFilter<"PriceGuess"> | number
    actualPrice?: IntNullableWithAggregatesFilter<"PriceGuess"> | number | null
    accuracy?: FloatNullableWithAggregatesFilter<"PriceGuess"> | number | null
    reward?: IntNullableWithAggregatesFilter<"PriceGuess"> | number | null
    basedOnDiscussion?: BoolWithAggregatesFilter<"PriceGuess"> | boolean
    predictionConfidenceBonus?: FloatWithAggregatesFilter<"PriceGuess"> | number
    timeSpentMs?: IntNullableWithAggregatesFilter<"PriceGuess"> | number | null
    adjustmentCount?: IntWithAggregatesFilter<"PriceGuess"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PriceGuess"> | Date | string
  }

  export type AIInteractionWhereInput = {
    AND?: AIInteractionWhereInput | AIInteractionWhereInput[]
    OR?: AIInteractionWhereInput[]
    NOT?: AIInteractionWhereInput | AIInteractionWhereInput[]
    id?: StringFilter<"AIInteraction"> | string
    sessionId?: StringFilter<"AIInteraction"> | string
    agentName?: StringFilter<"AIInteraction"> | string
    agentType?: StringFilter<"AIInteraction"> | string
    interactionType?: EnumAIInteractionTypeFilter<"AIInteraction"> | $Enums.AIInteractionType
    phase?: StringFilter<"AIInteraction"> | string
    content?: StringFilter<"AIInteraction"> | string
    emotion?: StringFilter<"AIInteraction"> | string
    animation?: StringFilter<"AIInteraction"> | string
    isScripted?: BoolFilter<"AIInteraction"> | boolean
    aiServiceUsed?: StringNullableFilter<"AIInteraction"> | string | null
    generationCost?: FloatFilter<"AIInteraction"> | number
    responseTimeMs?: IntFilter<"AIInteraction"> | number
    qualityScore?: FloatFilter<"AIInteraction"> | number
    userReactions?: JsonFilter<"AIInteraction">
    engagementScore?: FloatFilter<"AIInteraction"> | number
    isRandomEvent?: BoolFilter<"AIInteraction"> | boolean
    eventType?: StringNullableFilter<"AIInteraction"> | string | null
    createdAt?: DateTimeFilter<"AIInteraction"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
  }

  export type AIInteractionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    interactionType?: SortOrder
    phase?: SortOrder
    content?: SortOrder
    emotion?: SortOrder
    animation?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrderInput | SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    userReactions?: SortOrder
    engagementScore?: SortOrder
    isRandomEvent?: SortOrder
    eventType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: BiddingSessionOrderByWithRelationInput
  }

  export type AIInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIInteractionWhereInput | AIInteractionWhereInput[]
    OR?: AIInteractionWhereInput[]
    NOT?: AIInteractionWhereInput | AIInteractionWhereInput[]
    sessionId?: StringFilter<"AIInteraction"> | string
    agentName?: StringFilter<"AIInteraction"> | string
    agentType?: StringFilter<"AIInteraction"> | string
    interactionType?: EnumAIInteractionTypeFilter<"AIInteraction"> | $Enums.AIInteractionType
    phase?: StringFilter<"AIInteraction"> | string
    content?: StringFilter<"AIInteraction"> | string
    emotion?: StringFilter<"AIInteraction"> | string
    animation?: StringFilter<"AIInteraction"> | string
    isScripted?: BoolFilter<"AIInteraction"> | boolean
    aiServiceUsed?: StringNullableFilter<"AIInteraction"> | string | null
    generationCost?: FloatFilter<"AIInteraction"> | number
    responseTimeMs?: IntFilter<"AIInteraction"> | number
    qualityScore?: FloatFilter<"AIInteraction"> | number
    userReactions?: JsonFilter<"AIInteraction">
    engagementScore?: FloatFilter<"AIInteraction"> | number
    isRandomEvent?: BoolFilter<"AIInteraction"> | boolean
    eventType?: StringNullableFilter<"AIInteraction"> | string | null
    createdAt?: DateTimeFilter<"AIInteraction"> | Date | string
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
  }, "id">

  export type AIInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    interactionType?: SortOrder
    phase?: SortOrder
    content?: SortOrder
    emotion?: SortOrder
    animation?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrderInput | SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    userReactions?: SortOrder
    engagementScore?: SortOrder
    isRandomEvent?: SortOrder
    eventType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AIInteractionCountOrderByAggregateInput
    _avg?: AIInteractionAvgOrderByAggregateInput
    _max?: AIInteractionMaxOrderByAggregateInput
    _min?: AIInteractionMinOrderByAggregateInput
    _sum?: AIInteractionSumOrderByAggregateInput
  }

  export type AIInteractionScalarWhereWithAggregatesInput = {
    AND?: AIInteractionScalarWhereWithAggregatesInput | AIInteractionScalarWhereWithAggregatesInput[]
    OR?: AIInteractionScalarWhereWithAggregatesInput[]
    NOT?: AIInteractionScalarWhereWithAggregatesInput | AIInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIInteraction"> | string
    sessionId?: StringWithAggregatesFilter<"AIInteraction"> | string
    agentName?: StringWithAggregatesFilter<"AIInteraction"> | string
    agentType?: StringWithAggregatesFilter<"AIInteraction"> | string
    interactionType?: EnumAIInteractionTypeWithAggregatesFilter<"AIInteraction"> | $Enums.AIInteractionType
    phase?: StringWithAggregatesFilter<"AIInteraction"> | string
    content?: StringWithAggregatesFilter<"AIInteraction"> | string
    emotion?: StringWithAggregatesFilter<"AIInteraction"> | string
    animation?: StringWithAggregatesFilter<"AIInteraction"> | string
    isScripted?: BoolWithAggregatesFilter<"AIInteraction"> | boolean
    aiServiceUsed?: StringNullableWithAggregatesFilter<"AIInteraction"> | string | null
    generationCost?: FloatWithAggregatesFilter<"AIInteraction"> | number
    responseTimeMs?: IntWithAggregatesFilter<"AIInteraction"> | number
    qualityScore?: FloatWithAggregatesFilter<"AIInteraction"> | number
    userReactions?: JsonWithAggregatesFilter<"AIInteraction">
    engagementScore?: FloatWithAggregatesFilter<"AIInteraction"> | number
    isRandomEvent?: BoolWithAggregatesFilter<"AIInteraction"> | boolean
    eventType?: StringNullableWithAggregatesFilter<"AIInteraction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AIInteraction"> | Date | string
  }

  export type UserBiddingBehaviorWhereInput = {
    AND?: UserBiddingBehaviorWhereInput | UserBiddingBehaviorWhereInput[]
    OR?: UserBiddingBehaviorWhereInput[]
    NOT?: UserBiddingBehaviorWhereInput | UserBiddingBehaviorWhereInput[]
    id?: StringFilter<"UserBiddingBehavior"> | string
    sessionId?: StringFilter<"UserBiddingBehavior"> | string
    userId?: StringFilter<"UserBiddingBehavior"> | string
    actionType?: EnumUserBiddingActionFilter<"UserBiddingBehavior"> | $Enums.UserBiddingAction
    actionData?: JsonNullableFilter<"UserBiddingBehavior">
    timestamp?: DateTimeFilter<"UserBiddingBehavior"> | Date | string
    phase?: StringNullableFilter<"UserBiddingBehavior"> | string | null
    agentName?: StringNullableFilter<"UserBiddingBehavior"> | string | null
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserBiddingBehaviorOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    phase?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    session?: BiddingSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserBiddingBehaviorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBiddingBehaviorWhereInput | UserBiddingBehaviorWhereInput[]
    OR?: UserBiddingBehaviorWhereInput[]
    NOT?: UserBiddingBehaviorWhereInput | UserBiddingBehaviorWhereInput[]
    sessionId?: StringFilter<"UserBiddingBehavior"> | string
    userId?: StringFilter<"UserBiddingBehavior"> | string
    actionType?: EnumUserBiddingActionFilter<"UserBiddingBehavior"> | $Enums.UserBiddingAction
    actionData?: JsonNullableFilter<"UserBiddingBehavior">
    timestamp?: DateTimeFilter<"UserBiddingBehavior"> | Date | string
    phase?: StringNullableFilter<"UserBiddingBehavior"> | string | null
    agentName?: StringNullableFilter<"UserBiddingBehavior"> | string | null
    session?: XOR<BiddingSessionScalarRelationFilter, BiddingSessionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserBiddingBehaviorOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    phase?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    _count?: UserBiddingBehaviorCountOrderByAggregateInput
    _max?: UserBiddingBehaviorMaxOrderByAggregateInput
    _min?: UserBiddingBehaviorMinOrderByAggregateInput
  }

  export type UserBiddingBehaviorScalarWhereWithAggregatesInput = {
    AND?: UserBiddingBehaviorScalarWhereWithAggregatesInput | UserBiddingBehaviorScalarWhereWithAggregatesInput[]
    OR?: UserBiddingBehaviorScalarWhereWithAggregatesInput[]
    NOT?: UserBiddingBehaviorScalarWhereWithAggregatesInput | UserBiddingBehaviorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBiddingBehavior"> | string
    sessionId?: StringWithAggregatesFilter<"UserBiddingBehavior"> | string
    userId?: StringWithAggregatesFilter<"UserBiddingBehavior"> | string
    actionType?: EnumUserBiddingActionWithAggregatesFilter<"UserBiddingBehavior"> | $Enums.UserBiddingAction
    actionData?: JsonNullableWithAggregatesFilter<"UserBiddingBehavior">
    timestamp?: DateTimeWithAggregatesFilter<"UserBiddingBehavior"> | Date | string
    phase?: StringNullableWithAggregatesFilter<"UserBiddingBehavior"> | string | null
    agentName?: StringNullableWithAggregatesFilter<"UserBiddingBehavior"> | string | null
  }

  export type AIServiceUsageWhereInput = {
    AND?: AIServiceUsageWhereInput | AIServiceUsageWhereInput[]
    OR?: AIServiceUsageWhereInput[]
    NOT?: AIServiceUsageWhereInput | AIServiceUsageWhereInput[]
    id?: StringFilter<"AIServiceUsage"> | string
    sessionId?: StringNullableFilter<"AIServiceUsage"> | string | null
    agentName?: StringNullableFilter<"AIServiceUsage"> | string | null
    serviceName?: StringFilter<"AIServiceUsage"> | string
    modelName?: StringNullableFilter<"AIServiceUsage"> | string | null
    promptTokens?: IntFilter<"AIServiceUsage"> | number
    completionTokens?: IntFilter<"AIServiceUsage"> | number
    totalTokens?: IntFilter<"AIServiceUsage"> | number
    requestCount?: IntFilter<"AIServiceUsage"> | number
    totalCost?: FloatFilter<"AIServiceUsage"> | number
    responseTimeMs?: IntFilter<"AIServiceUsage"> | number
    qualityRating?: FloatNullableFilter<"AIServiceUsage"> | number | null
    userSatisfaction?: FloatNullableFilter<"AIServiceUsage"> | number | null
    errorCount?: IntFilter<"AIServiceUsage"> | number
    retryCount?: IntFilter<"AIServiceUsage"> | number
    createdAt?: DateTimeFilter<"AIServiceUsage"> | Date | string
    date?: DateTimeFilter<"AIServiceUsage"> | Date | string
  }

  export type AIServiceUsageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    serviceName?: SortOrder
    modelName?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
  }

  export type AIServiceUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIServiceUsageWhereInput | AIServiceUsageWhereInput[]
    OR?: AIServiceUsageWhereInput[]
    NOT?: AIServiceUsageWhereInput | AIServiceUsageWhereInput[]
    sessionId?: StringNullableFilter<"AIServiceUsage"> | string | null
    agentName?: StringNullableFilter<"AIServiceUsage"> | string | null
    serviceName?: StringFilter<"AIServiceUsage"> | string
    modelName?: StringNullableFilter<"AIServiceUsage"> | string | null
    promptTokens?: IntFilter<"AIServiceUsage"> | number
    completionTokens?: IntFilter<"AIServiceUsage"> | number
    totalTokens?: IntFilter<"AIServiceUsage"> | number
    requestCount?: IntFilter<"AIServiceUsage"> | number
    totalCost?: FloatFilter<"AIServiceUsage"> | number
    responseTimeMs?: IntFilter<"AIServiceUsage"> | number
    qualityRating?: FloatNullableFilter<"AIServiceUsage"> | number | null
    userSatisfaction?: FloatNullableFilter<"AIServiceUsage"> | number | null
    errorCount?: IntFilter<"AIServiceUsage"> | number
    retryCount?: IntFilter<"AIServiceUsage"> | number
    createdAt?: DateTimeFilter<"AIServiceUsage"> | Date | string
    date?: DateTimeFilter<"AIServiceUsage"> | Date | string
  }, "id">

  export type AIServiceUsageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    agentName?: SortOrderInput | SortOrder
    serviceName?: SortOrder
    modelName?: SortOrderInput | SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrderInput | SortOrder
    userSatisfaction?: SortOrderInput | SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
    _count?: AIServiceUsageCountOrderByAggregateInput
    _avg?: AIServiceUsageAvgOrderByAggregateInput
    _max?: AIServiceUsageMaxOrderByAggregateInput
    _min?: AIServiceUsageMinOrderByAggregateInput
    _sum?: AIServiceUsageSumOrderByAggregateInput
  }

  export type AIServiceUsageScalarWhereWithAggregatesInput = {
    AND?: AIServiceUsageScalarWhereWithAggregatesInput | AIServiceUsageScalarWhereWithAggregatesInput[]
    OR?: AIServiceUsageScalarWhereWithAggregatesInput[]
    NOT?: AIServiceUsageScalarWhereWithAggregatesInput | AIServiceUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIServiceUsage"> | string
    sessionId?: StringNullableWithAggregatesFilter<"AIServiceUsage"> | string | null
    agentName?: StringNullableWithAggregatesFilter<"AIServiceUsage"> | string | null
    serviceName?: StringWithAggregatesFilter<"AIServiceUsage"> | string
    modelName?: StringNullableWithAggregatesFilter<"AIServiceUsage"> | string | null
    promptTokens?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    completionTokens?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    totalTokens?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    requestCount?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    totalCost?: FloatWithAggregatesFilter<"AIServiceUsage"> | number
    responseTimeMs?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    qualityRating?: FloatNullableWithAggregatesFilter<"AIServiceUsage"> | number | null
    userSatisfaction?: FloatNullableWithAggregatesFilter<"AIServiceUsage"> | number | null
    errorCount?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    retryCount?: IntWithAggregatesFilter<"AIServiceUsage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AIServiceUsage"> | Date | string
    date?: DateTimeWithAggregatesFilter<"AIServiceUsage"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringFilter<"UserAchievement"> | string
    category?: StringFilter<"UserAchievement"> | string
    bonusPoints?: IntFilter<"UserAchievement"> | number
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progressData?: JsonNullableFilter<"UserAchievement">
    isRare?: BoolFilter<"UserAchievement"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    bonusPoints?: SortOrder
    earnedAt?: SortOrder
    progressData?: SortOrderInput | SortOrder
    isRare?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringFilter<"UserAchievement"> | string
    category?: StringFilter<"UserAchievement"> | string
    bonusPoints?: IntFilter<"UserAchievement"> | number
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progressData?: JsonNullableFilter<"UserAchievement">
    isRare?: BoolFilter<"UserAchievement"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    bonusPoints?: SortOrder
    earnedAt?: SortOrder
    progressData?: SortOrderInput | SortOrder
    isRare?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementName?: StringWithAggregatesFilter<"UserAchievement"> | string
    description?: StringWithAggregatesFilter<"UserAchievement"> | string
    category?: StringWithAggregatesFilter<"UserAchievement"> | string
    bonusPoints?: IntWithAggregatesFilter<"UserAchievement"> | number
    earnedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    progressData?: JsonNullableWithAggregatesFilter<"UserAchievement">
    isRare?: BoolWithAggregatesFilter<"UserAchievement"> | boolean
  }

  export type ResearchReportWhereInput = {
    AND?: ResearchReportWhereInput | ResearchReportWhereInput[]
    OR?: ResearchReportWhereInput[]
    NOT?: ResearchReportWhereInput | ResearchReportWhereInput[]
    id?: StringFilter<"ResearchReport"> | string
    ideaId?: StringFilter<"ResearchReport"> | string
    userId?: StringFilter<"ResearchReport"> | string
    reportData?: JsonFilter<"ResearchReport">
    summary?: StringNullableFilter<"ResearchReport"> | string | null
    basicAnalysis?: JsonNullableFilter<"ResearchReport">
    researchMethods?: JsonNullableFilter<"ResearchReport">
    dataSources?: JsonNullableFilter<"ResearchReport">
    mvpGuidance?: JsonNullableFilter<"ResearchReport">
    businessModel?: JsonNullableFilter<"ResearchReport">
    status?: EnumReportStatusFilter<"ResearchReport"> | $Enums.ReportStatus
    progress?: IntFilter<"ResearchReport"> | number
    creditsCost?: IntFilter<"ResearchReport"> | number
    createdAt?: DateTimeFilter<"ResearchReport"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ResearchReport"> | Date | string | null
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ResearchReportOrderByWithRelationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    reportData?: SortOrder
    summary?: SortOrderInput | SortOrder
    basicAnalysis?: SortOrderInput | SortOrder
    researchMethods?: SortOrderInput | SortOrder
    dataSources?: SortOrderInput | SortOrder
    mvpGuidance?: SortOrderInput | SortOrder
    businessModel?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    creditsCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    idea?: IdeaOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResearchReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ResearchReportWhereInput | ResearchReportWhereInput[]
    OR?: ResearchReportWhereInput[]
    NOT?: ResearchReportWhereInput | ResearchReportWhereInput[]
    ideaId?: StringFilter<"ResearchReport"> | string
    userId?: StringFilter<"ResearchReport"> | string
    reportData?: JsonFilter<"ResearchReport">
    summary?: StringNullableFilter<"ResearchReport"> | string | null
    basicAnalysis?: JsonNullableFilter<"ResearchReport">
    researchMethods?: JsonNullableFilter<"ResearchReport">
    dataSources?: JsonNullableFilter<"ResearchReport">
    mvpGuidance?: JsonNullableFilter<"ResearchReport">
    businessModel?: JsonNullableFilter<"ResearchReport">
    status?: EnumReportStatusFilter<"ResearchReport"> | $Enums.ReportStatus
    progress?: IntFilter<"ResearchReport"> | number
    creditsCost?: IntFilter<"ResearchReport"> | number
    createdAt?: DateTimeFilter<"ResearchReport"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ResearchReport"> | Date | string | null
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ResearchReportOrderByWithAggregationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    reportData?: SortOrder
    summary?: SortOrderInput | SortOrder
    basicAnalysis?: SortOrderInput | SortOrder
    researchMethods?: SortOrderInput | SortOrder
    dataSources?: SortOrderInput | SortOrder
    mvpGuidance?: SortOrderInput | SortOrder
    businessModel?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    creditsCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ResearchReportCountOrderByAggregateInput
    _avg?: ResearchReportAvgOrderByAggregateInput
    _max?: ResearchReportMaxOrderByAggregateInput
    _min?: ResearchReportMinOrderByAggregateInput
    _sum?: ResearchReportSumOrderByAggregateInput
  }

  export type ResearchReportScalarWhereWithAggregatesInput = {
    AND?: ResearchReportScalarWhereWithAggregatesInput | ResearchReportScalarWhereWithAggregatesInput[]
    OR?: ResearchReportScalarWhereWithAggregatesInput[]
    NOT?: ResearchReportScalarWhereWithAggregatesInput | ResearchReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResearchReport"> | string
    ideaId?: StringWithAggregatesFilter<"ResearchReport"> | string
    userId?: StringWithAggregatesFilter<"ResearchReport"> | string
    reportData?: JsonWithAggregatesFilter<"ResearchReport">
    summary?: StringNullableWithAggregatesFilter<"ResearchReport"> | string | null
    basicAnalysis?: JsonNullableWithAggregatesFilter<"ResearchReport">
    researchMethods?: JsonNullableWithAggregatesFilter<"ResearchReport">
    dataSources?: JsonNullableWithAggregatesFilter<"ResearchReport">
    mvpGuidance?: JsonNullableWithAggregatesFilter<"ResearchReport">
    businessModel?: JsonNullableWithAggregatesFilter<"ResearchReport">
    status?: EnumReportStatusWithAggregatesFilter<"ResearchReport"> | $Enums.ReportStatus
    progress?: IntWithAggregatesFilter<"ResearchReport"> | number
    creditsCost?: IntWithAggregatesFilter<"ResearchReport"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ResearchReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchReport"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ResearchReport"> | Date | string | null
  }

  export type CreditTransactionWhereInput = {
    AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    OR?: CreditTransactionWhereInput[]
    NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    id?: StringFilter<"CreditTransaction"> | string
    userId?: StringFilter<"CreditTransaction"> | string
    amount?: IntFilter<"CreditTransaction"> | number
    type?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    description?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedId?: StringNullableFilter<"CreditTransaction"> | string | null
    balanceBefore?: IntFilter<"CreditTransaction"> | number
    balanceAfter?: IntFilter<"CreditTransaction"> | number
    createdAt?: DateTimeFilter<"CreditTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CreditTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CreditTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    OR?: CreditTransactionWhereInput[]
    NOT?: CreditTransactionWhereInput | CreditTransactionWhereInput[]
    userId?: StringFilter<"CreditTransaction"> | string
    amount?: IntFilter<"CreditTransaction"> | number
    type?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    description?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedId?: StringNullableFilter<"CreditTransaction"> | string | null
    balanceBefore?: IntFilter<"CreditTransaction"> | number
    balanceAfter?: IntFilter<"CreditTransaction"> | number
    createdAt?: DateTimeFilter<"CreditTransaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CreditTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
    _count?: CreditTransactionCountOrderByAggregateInput
    _avg?: CreditTransactionAvgOrderByAggregateInput
    _max?: CreditTransactionMaxOrderByAggregateInput
    _min?: CreditTransactionMinOrderByAggregateInput
    _sum?: CreditTransactionSumOrderByAggregateInput
  }

  export type CreditTransactionScalarWhereWithAggregatesInput = {
    AND?: CreditTransactionScalarWhereWithAggregatesInput | CreditTransactionScalarWhereWithAggregatesInput[]
    OR?: CreditTransactionScalarWhereWithAggregatesInput[]
    NOT?: CreditTransactionScalarWhereWithAggregatesInput | CreditTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreditTransaction"> | string
    userId?: StringWithAggregatesFilter<"CreditTransaction"> | string
    amount?: IntWithAggregatesFilter<"CreditTransaction"> | number
    type?: EnumCreditTransactionTypeWithAggregatesFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    description?: StringNullableWithAggregatesFilter<"CreditTransaction"> | string | null
    relatedId?: StringNullableWithAggregatesFilter<"CreditTransaction"> | string | null
    balanceBefore?: IntWithAggregatesFilter<"CreditTransaction"> | number
    balanceAfter?: IntWithAggregatesFilter<"CreditTransaction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CreditTransaction"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    outTradeNo?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    credits?: IntFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    currency?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerOrderId?: StringNullableFilter<"Payment"> | string | null
    payUrl?: StringNullableFilter<"Payment"> | string | null
    qrCodeUrl?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiredAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    refunds?: RefundListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    outTradeNo?: SortOrder
    amount?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrderInput | SortOrder
    payUrl?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrder
    user?: UserOrderByWithRelationInput
    refunds?: RefundOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    outTradeNo?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    credits?: IntFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    currency?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerOrderId?: StringNullableFilter<"Payment"> | string | null
    payUrl?: StringNullableFilter<"Payment"> | string | null
    qrCodeUrl?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiredAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    refunds?: RefundListRelationFilter
  }, "id" | "outTradeNo">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    outTradeNo?: SortOrder
    amount?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrderInput | SortOrder
    payUrl?: SortOrderInput | SortOrder
    qrCodeUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    expiredAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    outTradeNo?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    credits?: IntWithAggregatesFilter<"Payment"> | number
    description?: StringWithAggregatesFilter<"Payment"> | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringWithAggregatesFilter<"Payment"> | string
    providerOrderId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    payUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    qrCodeUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    expiredAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    outRefundNo?: StringFilter<"Refund"> | string
    refundAmount?: FloatFilter<"Refund"> | number
    reason?: StringFilter<"Refund"> | string
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    operatorId?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    refundedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    outRefundNo?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundedAt?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    outRefundNo?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    paymentId?: StringFilter<"Refund"> | string
    refundAmount?: FloatFilter<"Refund"> | number
    reason?: StringFilter<"Refund"> | string
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    operatorId?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    refundedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id" | "outRefundNo">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    outRefundNo?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrderInput | SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundedAt?: SortOrderInput | SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refund"> | string
    paymentId?: StringWithAggregatesFilter<"Refund"> | string
    outRefundNo?: StringWithAggregatesFilter<"Refund"> | string
    refundAmount?: FloatWithAggregatesFilter<"Refund"> | number
    reason?: StringWithAggregatesFilter<"Refund"> | string
    status?: StringWithAggregatesFilter<"Refund"> | string
    providerRefundId?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    operatorId?: StringWithAggregatesFilter<"Refund"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    refundedAt?: DateTimeNullableWithAggregatesFilter<"Refund"> | Date | string | null
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    userId?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    key?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    contentType?: StringFilter<"File"> | string
    type?: StringFilter<"File"> | string
    status?: StringFilter<"File"> | string
    metadata?: JsonNullableFilter<"File">
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    userId?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    contentType?: StringFilter<"File"> | string
    type?: StringFilter<"File"> | string
    status?: StringFilter<"File"> | string
    metadata?: JsonNullableFilter<"File">
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    userId?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    originalName?: StringWithAggregatesFilter<"File"> | string
    key?: StringWithAggregatesFilter<"File"> | string
    url?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    contentType?: StringWithAggregatesFilter<"File"> | string
    type?: StringWithAggregatesFilter<"File"> | string
    status?: StringWithAggregatesFilter<"File"> | string
    metadata?: JsonNullableWithAggregatesFilter<"File">
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"File"> | Date | string | null
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type AIUsageStatsWhereInput = {
    AND?: AIUsageStatsWhereInput | AIUsageStatsWhereInput[]
    OR?: AIUsageStatsWhereInput[]
    NOT?: AIUsageStatsWhereInput | AIUsageStatsWhereInput[]
    id?: StringFilter<"AIUsageStats"> | string
    provider?: StringFilter<"AIUsageStats"> | string
    model?: StringFilter<"AIUsageStats"> | string
    requestCount?: IntFilter<"AIUsageStats"> | number
    totalTokens?: IntFilter<"AIUsageStats"> | number
    totalCost?: FloatFilter<"AIUsageStats"> | number
    date?: DateTimeFilter<"AIUsageStats"> | Date | string
    createdAt?: DateTimeFilter<"AIUsageStats"> | Date | string
    updatedAt?: DateTimeFilter<"AIUsageStats"> | Date | string
  }

  export type AIUsageStatsOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_model_date?: AIUsageStatsProviderModelDateCompoundUniqueInput
    AND?: AIUsageStatsWhereInput | AIUsageStatsWhereInput[]
    OR?: AIUsageStatsWhereInput[]
    NOT?: AIUsageStatsWhereInput | AIUsageStatsWhereInput[]
    provider?: StringFilter<"AIUsageStats"> | string
    model?: StringFilter<"AIUsageStats"> | string
    requestCount?: IntFilter<"AIUsageStats"> | number
    totalTokens?: IntFilter<"AIUsageStats"> | number
    totalCost?: FloatFilter<"AIUsageStats"> | number
    date?: DateTimeFilter<"AIUsageStats"> | Date | string
    createdAt?: DateTimeFilter<"AIUsageStats"> | Date | string
    updatedAt?: DateTimeFilter<"AIUsageStats"> | Date | string
  }, "id" | "provider_model_date">

  export type AIUsageStatsOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIUsageStatsCountOrderByAggregateInput
    _avg?: AIUsageStatsAvgOrderByAggregateInput
    _max?: AIUsageStatsMaxOrderByAggregateInput
    _min?: AIUsageStatsMinOrderByAggregateInput
    _sum?: AIUsageStatsSumOrderByAggregateInput
  }

  export type AIUsageStatsScalarWhereWithAggregatesInput = {
    AND?: AIUsageStatsScalarWhereWithAggregatesInput | AIUsageStatsScalarWhereWithAggregatesInput[]
    OR?: AIUsageStatsScalarWhereWithAggregatesInput[]
    NOT?: AIUsageStatsScalarWhereWithAggregatesInput | AIUsageStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIUsageStats"> | string
    provider?: StringWithAggregatesFilter<"AIUsageStats"> | string
    model?: StringWithAggregatesFilter<"AIUsageStats"> | string
    requestCount?: IntWithAggregatesFilter<"AIUsageStats"> | number
    totalTokens?: IntWithAggregatesFilter<"AIUsageStats"> | number
    totalCost?: FloatWithAggregatesFilter<"AIUsageStats"> | number
    date?: DateTimeWithAggregatesFilter<"AIUsageStats"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AIUsageStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIUsageStats"> | Date | string
  }

  export type IdeaDiscussionWhereInput = {
    AND?: IdeaDiscussionWhereInput | IdeaDiscussionWhereInput[]
    OR?: IdeaDiscussionWhereInput[]
    NOT?: IdeaDiscussionWhereInput | IdeaDiscussionWhereInput[]
    id?: StringFilter<"IdeaDiscussion"> | string
    ideaId?: StringFilter<"IdeaDiscussion"> | string
    userId?: StringFilter<"IdeaDiscussion"> | string
    status?: EnumDiscussionStatusFilter<"IdeaDiscussion"> | $Enums.DiscussionStatus
    currentRound?: IntFilter<"IdeaDiscussion"> | number
    totalRounds?: IntFilter<"IdeaDiscussion"> | number
    aiAgentType?: StringFilter<"IdeaDiscussion"> | string
    aiAgentName?: StringFilter<"IdeaDiscussion"> | string
    createdAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    completedAt?: DateTimeNullableFilter<"IdeaDiscussion"> | Date | string | null
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: BiddingSessionListRelationFilter
    messages?: DiscussionMessageListRelationFilter
  }

  export type IdeaDiscussionOrderByWithRelationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    totalRounds?: SortOrder
    aiAgentType?: SortOrder
    aiAgentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    idea?: IdeaOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sessions?: BiddingSessionOrderByRelationAggregateInput
    messages?: DiscussionMessageOrderByRelationAggregateInput
  }

  export type IdeaDiscussionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IdeaDiscussionWhereInput | IdeaDiscussionWhereInput[]
    OR?: IdeaDiscussionWhereInput[]
    NOT?: IdeaDiscussionWhereInput | IdeaDiscussionWhereInput[]
    ideaId?: StringFilter<"IdeaDiscussion"> | string
    userId?: StringFilter<"IdeaDiscussion"> | string
    status?: EnumDiscussionStatusFilter<"IdeaDiscussion"> | $Enums.DiscussionStatus
    currentRound?: IntFilter<"IdeaDiscussion"> | number
    totalRounds?: IntFilter<"IdeaDiscussion"> | number
    aiAgentType?: StringFilter<"IdeaDiscussion"> | string
    aiAgentName?: StringFilter<"IdeaDiscussion"> | string
    createdAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    completedAt?: DateTimeNullableFilter<"IdeaDiscussion"> | Date | string | null
    idea?: XOR<IdeaScalarRelationFilter, IdeaWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    sessions?: BiddingSessionListRelationFilter
    messages?: DiscussionMessageListRelationFilter
  }, "id">

  export type IdeaDiscussionOrderByWithAggregationInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    totalRounds?: SortOrder
    aiAgentType?: SortOrder
    aiAgentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: IdeaDiscussionCountOrderByAggregateInput
    _avg?: IdeaDiscussionAvgOrderByAggregateInput
    _max?: IdeaDiscussionMaxOrderByAggregateInput
    _min?: IdeaDiscussionMinOrderByAggregateInput
    _sum?: IdeaDiscussionSumOrderByAggregateInput
  }

  export type IdeaDiscussionScalarWhereWithAggregatesInput = {
    AND?: IdeaDiscussionScalarWhereWithAggregatesInput | IdeaDiscussionScalarWhereWithAggregatesInput[]
    OR?: IdeaDiscussionScalarWhereWithAggregatesInput[]
    NOT?: IdeaDiscussionScalarWhereWithAggregatesInput | IdeaDiscussionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IdeaDiscussion"> | string
    ideaId?: StringWithAggregatesFilter<"IdeaDiscussion"> | string
    userId?: StringWithAggregatesFilter<"IdeaDiscussion"> | string
    status?: EnumDiscussionStatusWithAggregatesFilter<"IdeaDiscussion"> | $Enums.DiscussionStatus
    currentRound?: IntWithAggregatesFilter<"IdeaDiscussion"> | number
    totalRounds?: IntWithAggregatesFilter<"IdeaDiscussion"> | number
    aiAgentType?: StringWithAggregatesFilter<"IdeaDiscussion"> | string
    aiAgentName?: StringWithAggregatesFilter<"IdeaDiscussion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IdeaDiscussion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IdeaDiscussion"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"IdeaDiscussion"> | Date | string | null
  }

  export type DiscussionMessageWhereInput = {
    AND?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    OR?: DiscussionMessageWhereInput[]
    NOT?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    id?: StringFilter<"DiscussionMessage"> | string
    discussionId?: StringFilter<"DiscussionMessage"> | string
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: EnumMessageTypeFilter<"DiscussionMessage"> | $Enums.MessageType
    roundNumber?: IntFilter<"DiscussionMessage"> | number
    senderType?: EnumSenderTypeFilter<"DiscussionMessage"> | $Enums.SenderType
    senderName?: StringNullableFilter<"DiscussionMessage"> | string | null
    analysisData?: JsonNullableFilter<"DiscussionMessage">
    suggestions?: JsonNullableFilter<"DiscussionMessage">
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    discussion?: XOR<IdeaDiscussionScalarRelationFilter, IdeaDiscussionWhereInput>
  }

  export type DiscussionMessageOrderByWithRelationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    roundNumber?: SortOrder
    senderType?: SortOrder
    senderName?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    discussion?: IdeaDiscussionOrderByWithRelationInput
  }

  export type DiscussionMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    OR?: DiscussionMessageWhereInput[]
    NOT?: DiscussionMessageWhereInput | DiscussionMessageWhereInput[]
    discussionId?: StringFilter<"DiscussionMessage"> | string
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: EnumMessageTypeFilter<"DiscussionMessage"> | $Enums.MessageType
    roundNumber?: IntFilter<"DiscussionMessage"> | number
    senderType?: EnumSenderTypeFilter<"DiscussionMessage"> | $Enums.SenderType
    senderName?: StringNullableFilter<"DiscussionMessage"> | string | null
    analysisData?: JsonNullableFilter<"DiscussionMessage">
    suggestions?: JsonNullableFilter<"DiscussionMessage">
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
    discussion?: XOR<IdeaDiscussionScalarRelationFilter, IdeaDiscussionWhereInput>
  }, "id">

  export type DiscussionMessageOrderByWithAggregationInput = {
    id?: SortOrder
    discussionId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    roundNumber?: SortOrder
    senderType?: SortOrder
    senderName?: SortOrderInput | SortOrder
    analysisData?: SortOrderInput | SortOrder
    suggestions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DiscussionMessageCountOrderByAggregateInput
    _avg?: DiscussionMessageAvgOrderByAggregateInput
    _max?: DiscussionMessageMaxOrderByAggregateInput
    _min?: DiscussionMessageMinOrderByAggregateInput
    _sum?: DiscussionMessageSumOrderByAggregateInput
  }

  export type DiscussionMessageScalarWhereWithAggregatesInput = {
    AND?: DiscussionMessageScalarWhereWithAggregatesInput | DiscussionMessageScalarWhereWithAggregatesInput[]
    OR?: DiscussionMessageScalarWhereWithAggregatesInput[]
    NOT?: DiscussionMessageScalarWhereWithAggregatesInput | DiscussionMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscussionMessage"> | string
    discussionId?: StringWithAggregatesFilter<"DiscussionMessage"> | string
    content?: StringWithAggregatesFilter<"DiscussionMessage"> | string
    messageType?: EnumMessageTypeWithAggregatesFilter<"DiscussionMessage"> | $Enums.MessageType
    roundNumber?: IntWithAggregatesFilter<"DiscussionMessage"> | number
    senderType?: EnumSenderTypeWithAggregatesFilter<"DiscussionMessage"> | $Enums.SenderType
    senderName?: StringNullableWithAggregatesFilter<"DiscussionMessage"> | string | null
    analysisData?: JsonNullableWithAggregatesFilter<"DiscussionMessage">
    suggestions?: JsonNullableWithAggregatesFilter<"DiscussionMessage">
    createdAt?: DateTimeWithAggregatesFilter<"DiscussionMessage"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    amount?: FloatWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    description?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    userId?: StringFilter<"CartItem"> | string
    agentId?: StringFilter<"CartItem"> | string
    price?: FloatNullableFilter<"CartItem"> | number | null
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    price?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    userId?: StringFilter<"CartItem"> | string
    agentId?: StringFilter<"CartItem"> | string
    price?: FloatNullableFilter<"CartItem"> | number | null
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    price?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    userId?: StringWithAggregatesFilter<"CartItem"> | string
    agentId?: StringWithAggregatesFilter<"CartItem"> | string
    price?: FloatNullableWithAggregatesFilter<"CartItem"> | number | null
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringFilter<"Agent"> | string
    type?: EnumAgentTypeFilter<"Agent"> | $Enums.AgentType
    status?: EnumAgentStatusFilter<"Agent"> | $Enums.AgentStatus
    price?: FloatNullableFilter<"Agent"> | number | null
    credits?: IntNullableFilter<"Agent"> | number | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    name?: StringFilter<"Agent"> | string
    description?: StringFilter<"Agent"> | string
    type?: EnumAgentTypeFilter<"Agent"> | $Enums.AgentType
    status?: EnumAgentStatusFilter<"Agent"> | $Enums.AgentStatus
    price?: FloatNullableFilter<"Agent"> | number | null
    credits?: IntNullableFilter<"Agent"> | number | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    price?: SortOrderInput | SortOrder
    credits?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringWithAggregatesFilter<"Agent"> | string
    type?: EnumAgentTypeWithAggregatesFilter<"Agent"> | $Enums.AgentType
    status?: EnumAgentStatusWithAggregatesFilter<"Agent"> | $Enums.AgentStatus
    price?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    credits?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdeasInput
    researchReports?: ResearchReportCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    userId: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdeasNestedInput
    researchReports?: ResearchReportUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    researchReports?: ResearchReportUncheckedUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaCreateManyInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    userId: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IdeaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingSessionCreateInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionCreateManyInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
  }

  export type BiddingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type BiddingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type BidCreateInput = {
    id?: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
    session: BiddingSessionCreateNestedOneWithoutBidsInput
  }

  export type BidUncheckedCreateInput = {
    id?: string
    sessionId: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
  }

  export type BidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: BiddingSessionUpdateOneRequiredWithoutBidsNestedInput
  }

  export type BidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidCreateManyInput = {
    id?: string
    sessionId: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
  }

  export type BidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessCreateInput = {
    id?: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
    session: BiddingSessionCreateNestedOneWithoutPriceGuessesInput
    user: UserCreateNestedOneWithoutPriceGuessesInput
  }

  export type PriceGuessUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type PriceGuessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: BiddingSessionUpdateOneRequiredWithoutPriceGuessesNestedInput
    user?: UserUpdateOneRequiredWithoutPriceGuessesNestedInput
  }

  export type PriceGuessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type PriceGuessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionCreateInput = {
    id?: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
    session: BiddingSessionCreateNestedOneWithoutInteractionsInput
  }

  export type AIInteractionUncheckedCreateInput = {
    id?: string
    sessionId: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
  }

  export type AIInteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: BiddingSessionUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type AIInteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionCreateManyInput = {
    id?: string
    sessionId: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
  }

  export type AIInteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBiddingBehaviorCreateInput = {
    id?: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
    session: BiddingSessionCreateNestedOneWithoutBehaviorsInput
    user: UserCreateNestedOneWithoutBiddingBehaviorsInput
  }

  export type UserBiddingBehaviorUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type UserBiddingBehaviorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    session?: BiddingSessionUpdateOneRequiredWithoutBehaviorsNestedInput
    user?: UserUpdateOneRequiredWithoutBiddingBehaviorsNestedInput
  }

  export type UserBiddingBehaviorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBiddingBehaviorCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type UserBiddingBehaviorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBiddingBehaviorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AIServiceUsageCreateInput = {
    id?: string
    sessionId?: string | null
    agentName?: string | null
    serviceName: string
    modelName?: string | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    requestCount?: number
    totalCost: number
    responseTimeMs: number
    qualityRating?: number | null
    userSatisfaction?: number | null
    errorCount?: number
    retryCount?: number
    createdAt?: Date | string
    date?: Date | string
  }

  export type AIServiceUsageUncheckedCreateInput = {
    id?: string
    sessionId?: string | null
    agentName?: string | null
    serviceName: string
    modelName?: string | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    requestCount?: number
    totalCost: number
    responseTimeMs: number
    qualityRating?: number | null
    userSatisfaction?: number | null
    errorCount?: number
    retryCount?: number
    createdAt?: Date | string
    date?: Date | string
  }

  export type AIServiceUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableFloatFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIServiceUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableFloatFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIServiceUsageCreateManyInput = {
    id?: string
    sessionId?: string | null
    agentName?: string | null
    serviceName: string
    modelName?: string | null
    promptTokens: number
    completionTokens: number
    totalTokens: number
    requestCount?: number
    totalCost: number
    responseTimeMs: number
    qualityRating?: number | null
    userSatisfaction?: number | null
    errorCount?: number
    retryCount?: number
    createdAt?: Date | string
    date?: Date | string
  }

  export type AIServiceUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableFloatFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIServiceUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    serviceName?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    promptTokens?: IntFieldUpdateOperationsInput | number
    completionTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    requestCount?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityRating?: NullableFloatFieldUpdateOperationsInput | number | null
    userSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    errorCount?: IntFieldUpdateOperationsInput | number
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResearchReportCreateInput = {
    id?: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutResearchReportsInput
    user: UserCreateNestedOneWithoutResearchReportsInput
  }

  export type ResearchReportUncheckedCreateInput = {
    id?: string
    ideaId: string
    userId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResearchReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutResearchReportsNestedInput
    user?: UserUpdateOneRequiredWithoutResearchReportsNestedInput
  }

  export type ResearchReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchReportCreateManyInput = {
    id?: string
    ideaId: string
    userId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResearchReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreditTransactionCreateInput = {
    id?: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCreditTransactionsInput
  }

  export type CreditTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
  }

  export type CreditTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreditTransactionsNestedInput
  }

  export type CreditTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionCreateManyInput = {
    id?: string
    userId: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
  }

  export type CreditTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateInput = {
    id?: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    paymentId: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundCreateManyInput = {
    id?: string
    paymentId: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateInput = {
    id?: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileCreateManyInput = {
    id?: string
    userId: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageStatsCreateInput = {
    id?: string
    provider: string
    model: string
    requestCount?: number
    totalTokens?: number
    totalCost?: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIUsageStatsUncheckedCreateInput = {
    id?: string
    provider: string
    model: string
    requestCount?: number
    totalTokens?: number
    totalCost?: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIUsageStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    requestCount?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    requestCount?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageStatsCreateManyInput = {
    id?: string
    provider: string
    model: string
    requestCount?: number
    totalTokens?: number
    totalCost?: number
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIUsageStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    requestCount?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIUsageStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    requestCount?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCost?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IdeaDiscussionCreateInput = {
    id?: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutDiscussionsInput
    user: UserCreateNestedOneWithoutDiscussionsInput
    sessions?: BiddingSessionCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUncheckedCreateInput = {
    id?: string
    ideaId: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sessions?: BiddingSessionUncheckedCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutDiscussionsNestedInput
    user?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    sessions?: BiddingSessionUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: BiddingSessionUncheckedUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionCreateManyInput = {
    id?: string
    ideaId: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type IdeaDiscussionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IdeaDiscussionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscussionMessageCreateInput = {
    id?: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    discussion: IdeaDiscussionCreateNestedOneWithoutMessagesInput
  }

  export type DiscussionMessageUncheckedCreateInput = {
    id?: string
    discussionId: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DiscussionMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discussion?: IdeaDiscussionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type DiscussionMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageCreateManyInput = {
    id?: string
    discussionId: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DiscussionMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discussionId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartItemCreateInput = {
    id?: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    userId: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    userId: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgentType
    status?: $Enums.AgentStatus
    price?: number | null
    credits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgentType
    status?: $Enums.AgentStatus
    price?: number | null
    credits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.AgentType
    status?: $Enums.AgentStatus
    price?: number | null
    credits?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumAgentTypeFieldUpdateOperationsInput | $Enums.AgentType
    status?: EnumAgentStatusFieldUpdateOperationsInput | $Enums.AgentStatus
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    credits?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumUserLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUserLevelFilter<$PrismaModel> | $Enums.UserLevel
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IdeaListRelationFilter = {
    every?: IdeaWhereInput
    some?: IdeaWhereInput
    none?: IdeaWhereInput
  }

  export type ResearchReportListRelationFilter = {
    every?: ResearchReportWhereInput
    some?: ResearchReportWhereInput
    none?: ResearchReportWhereInput
  }

  export type CreditTransactionListRelationFilter = {
    every?: CreditTransactionWhereInput
    some?: CreditTransactionWhereInput
    none?: CreditTransactionWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type IdeaDiscussionListRelationFilter = {
    every?: IdeaDiscussionWhereInput
    some?: IdeaDiscussionWhereInput
    none?: IdeaDiscussionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type BiddingSessionListRelationFilter = {
    every?: BiddingSessionWhereInput
    some?: BiddingSessionWhereInput
    none?: BiddingSessionWhereInput
  }

  export type PriceGuessListRelationFilter = {
    every?: PriceGuessWhereInput
    some?: PriceGuessWhereInput
    none?: PriceGuessWhereInput
  }

  export type UserBiddingBehaviorListRelationFilter = {
    every?: UserBiddingBehaviorWhereInput
    some?: UserBiddingBehaviorWhereInput
    none?: UserBiddingBehaviorWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IdeaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdeaDiscussionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiddingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceGuessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBiddingBehaviorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    status?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    credits?: SortOrder
    level?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
    favoriteAgent?: SortOrder
    emailNotifications?: SortOrder
    marketingEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    credits?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    status?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    credits?: SortOrder
    level?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
    favoriteAgent?: SortOrder
    emailNotifications?: SortOrder
    marketingEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    status?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    credits?: SortOrder
    level?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
    favoriteAgent?: SortOrder
    emailNotifications?: SortOrder
    marketingEmails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    credits?: SortOrder
    totalSpent?: SortOrder
    totalEarned?: SortOrder
    totalGuesses?: SortOrder
    guessAccuracy?: SortOrder
    guessEarnings?: SortOrder
    guessLevel?: SortOrder
    levelProgress?: SortOrder
    consecutiveGuesses?: SortOrder
    bestStreak?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumUserLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUserLevelWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLevelFilter<$PrismaModel>
    _max?: NestedEnumUserLevelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumIdeaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaCategory | EnumIdeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaCategoryFilter<$PrismaModel> | $Enums.IdeaCategory
  }

  export type EnumIdeaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaStatus | EnumIdeaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaStatusFilter<$PrismaModel> | $Enums.IdeaStatus
  }

  export type EnumIdeaVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaVisibility | EnumIdeaVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaVisibilityFilter<$PrismaModel> | $Enums.IdeaVisibility
  }

  export type IdeaCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
  }

  export type IdeaMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    userId?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IdeaSumOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
  }

  export type EnumIdeaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaCategory | EnumIdeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IdeaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaCategoryFilter<$PrismaModel>
    _max?: NestedEnumIdeaCategoryFilter<$PrismaModel>
  }

  export type EnumIdeaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaStatus | EnumIdeaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdeaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaStatusFilter<$PrismaModel>
    _max?: NestedEnumIdeaStatusFilter<$PrismaModel>
  }

  export type EnumIdeaVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaVisibility | EnumIdeaVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.IdeaVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaVisibilityFilter<$PrismaModel>
    _max?: NestedEnumIdeaVisibilityFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumBiddingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingStatus | EnumBiddingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingStatusFilter<$PrismaModel> | $Enums.BiddingStatus
  }

  export type EnumBiddingPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingPhase | EnumBiddingPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingPhaseFilter<$PrismaModel> | $Enums.BiddingPhase
  }

  export type IdeaScalarRelationFilter = {
    is?: IdeaWhereInput
    isNot?: IdeaWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type IdeaDiscussionNullableScalarRelationFilter = {
    is?: IdeaDiscussionWhereInput | null
    isNot?: IdeaDiscussionWhereInput | null
  }

  export type BidListRelationFilter = {
    every?: BidWhereInput
    some?: BidWhereInput
    none?: BidWhereInput
  }

  export type AIInteractionListRelationFilter = {
    every?: AIInteractionWhereInput
    some?: AIInteractionWhereInput
    none?: AIInteractionWhereInput
  }

  export type BidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AIInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiddingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    startPrice?: SortOrder
    currentHigh?: SortOrder
    winnerAgent?: SortOrder
    winnerAgentType?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    enhancedByDiscussion?: SortOrder
    discussionId?: SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    discussionStartedAt?: SortOrder
    biddingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
  }

  export type BiddingSessionAvgOrderByAggregateInput = {
    startPrice?: SortOrder
    currentHigh?: SortOrder
    finalPrice?: SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
  }

  export type BiddingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    startPrice?: SortOrder
    currentHigh?: SortOrder
    winnerAgent?: SortOrder
    winnerAgentType?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    enhancedByDiscussion?: SortOrder
    discussionId?: SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    discussionStartedAt?: SortOrder
    biddingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
  }

  export type BiddingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    startPrice?: SortOrder
    currentHigh?: SortOrder
    winnerAgent?: SortOrder
    winnerAgentType?: SortOrder
    finalPrice?: SortOrder
    status?: SortOrder
    phase?: SortOrder
    enhancedByDiscussion?: SortOrder
    discussionId?: SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    discussionStartedAt?: SortOrder
    biddingStartedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
  }

  export type BiddingSessionSumOrderByAggregateInput = {
    startPrice?: SortOrder
    currentHigh?: SortOrder
    finalPrice?: SortOrder
    enhancementScore?: SortOrder
    participantCount?: SortOrder
    viewerCount?: SortOrder
    maxViewerCount?: SortOrder
    totalInteractions?: SortOrder
    durationSeconds?: SortOrder
    discussionDuration?: SortOrder
    biddingDuration?: SortOrder
    avgResponseTime?: SortOrder
    aiServiceCost?: SortOrder
    userEngagementScore?: SortOrder
    contentQualityScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBiddingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingStatus | EnumBiddingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BiddingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiddingStatusFilter<$PrismaModel>
    _max?: NestedEnumBiddingStatusFilter<$PrismaModel>
  }

  export type EnumBiddingPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingPhase | EnumBiddingPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingPhaseWithAggregatesFilter<$PrismaModel> | $Enums.BiddingPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiddingPhaseFilter<$PrismaModel>
    _max?: NestedEnumBiddingPhaseFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BiddingSessionScalarRelationFilter = {
    is?: BiddingSessionWhereInput
    isNot?: BiddingSessionWhereInput
  }

  export type BidCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    confidence?: SortOrder
    analysisData?: SortOrder
    reasoning?: SortOrder
    emotionalState?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
    createdAt?: SortOrder
  }

  export type BidAvgOrderByAggregateInput = {
    amount?: SortOrder
    confidence?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
  }

  export type BidMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    emotionalState?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
    createdAt?: SortOrder
  }

  export type BidMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    amount?: SortOrder
    comment?: SortOrder
    confidence?: SortOrder
    reasoning?: SortOrder
    emotionalState?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
    createdAt?: SortOrder
  }

  export type BidSumOrderByAggregateInput = {
    amount?: SortOrder
    confidence?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    understandingDepth?: SortOrder
    contextRichness?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PriceGuessSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type PriceGuessCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrder
    accuracy?: SortOrder
    reward?: SortOrder
    basedOnDiscussion?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrder
    adjustmentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceGuessAvgOrderByAggregateInput = {
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrder
    accuracy?: SortOrder
    reward?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrder
    adjustmentCount?: SortOrder
  }

  export type PriceGuessMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrder
    accuracy?: SortOrder
    reward?: SortOrder
    basedOnDiscussion?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrder
    adjustmentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceGuessMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrder
    accuracy?: SortOrder
    reward?: SortOrder
    basedOnDiscussion?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrder
    adjustmentCount?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceGuessSumOrderByAggregateInput = {
    guessedPrice?: SortOrder
    confidence?: SortOrder
    stakeAmount?: SortOrder
    actualPrice?: SortOrder
    accuracy?: SortOrder
    reward?: SortOrder
    predictionConfidenceBonus?: SortOrder
    timeSpentMs?: SortOrder
    adjustmentCount?: SortOrder
  }

  export type EnumAIInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInteractionType | EnumAIInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIInteractionTypeFilter<$PrismaModel> | $Enums.AIInteractionType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AIInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    interactionType?: SortOrder
    phase?: SortOrder
    content?: SortOrder
    emotion?: SortOrder
    animation?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    userReactions?: SortOrder
    engagementScore?: SortOrder
    isRandomEvent?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInteractionAvgOrderByAggregateInput = {
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    engagementScore?: SortOrder
  }

  export type AIInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    interactionType?: SortOrder
    phase?: SortOrder
    content?: SortOrder
    emotion?: SortOrder
    animation?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    engagementScore?: SortOrder
    isRandomEvent?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    agentType?: SortOrder
    interactionType?: SortOrder
    phase?: SortOrder
    content?: SortOrder
    emotion?: SortOrder
    animation?: SortOrder
    isScripted?: SortOrder
    aiServiceUsed?: SortOrder
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    engagementScore?: SortOrder
    isRandomEvent?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type AIInteractionSumOrderByAggregateInput = {
    generationCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityScore?: SortOrder
    engagementScore?: SortOrder
  }

  export type EnumAIInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInteractionType | EnumAIInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIInteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumAIInteractionTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumUserBiddingActionFilter<$PrismaModel = never> = {
    equals?: $Enums.UserBiddingAction | EnumUserBiddingActionFieldRefInput<$PrismaModel>
    in?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumUserBiddingActionFilter<$PrismaModel> | $Enums.UserBiddingAction
  }

  export type UserBiddingBehaviorCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    actionData?: SortOrder
    timestamp?: SortOrder
    phase?: SortOrder
    agentName?: SortOrder
  }

  export type UserBiddingBehaviorMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    timestamp?: SortOrder
    phase?: SortOrder
    agentName?: SortOrder
  }

  export type UserBiddingBehaviorMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    timestamp?: SortOrder
    phase?: SortOrder
    agentName?: SortOrder
  }

  export type EnumUserBiddingActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserBiddingAction | EnumUserBiddingActionFieldRefInput<$PrismaModel>
    in?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumUserBiddingActionWithAggregatesFilter<$PrismaModel> | $Enums.UserBiddingAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserBiddingActionFilter<$PrismaModel>
    _max?: NestedEnumUserBiddingActionFilter<$PrismaModel>
  }

  export type AIServiceUsageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    serviceName?: SortOrder
    modelName?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrder
    userSatisfaction?: SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
  }

  export type AIServiceUsageAvgOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrder
    userSatisfaction?: SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
  }

  export type AIServiceUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    serviceName?: SortOrder
    modelName?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrder
    userSatisfaction?: SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
  }

  export type AIServiceUsageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    agentName?: SortOrder
    serviceName?: SortOrder
    modelName?: SortOrder
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrder
    userSatisfaction?: SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    date?: SortOrder
  }

  export type AIServiceUsageSumOrderByAggregateInput = {
    promptTokens?: SortOrder
    completionTokens?: SortOrder
    totalTokens?: SortOrder
    requestCount?: SortOrder
    totalCost?: SortOrder
    responseTimeMs?: SortOrder
    qualityRating?: SortOrder
    userSatisfaction?: SortOrder
    errorCount?: SortOrder
    retryCount?: SortOrder
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    bonusPoints?: SortOrder
    earnedAt?: SortOrder
    progressData?: SortOrder
    isRare?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    bonusPoints?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    bonusPoints?: SortOrder
    earnedAt?: SortOrder
    isRare?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    category?: SortOrder
    bonusPoints?: SortOrder
    earnedAt?: SortOrder
    isRare?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    bonusPoints?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ResearchReportCountOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    reportData?: SortOrder
    summary?: SortOrder
    basicAnalysis?: SortOrder
    researchMethods?: SortOrder
    dataSources?: SortOrder
    mvpGuidance?: SortOrder
    businessModel?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    creditsCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchReportAvgOrderByAggregateInput = {
    progress?: SortOrder
    creditsCost?: SortOrder
  }

  export type ResearchReportMaxOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    creditsCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchReportMinOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    creditsCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ResearchReportSumOrderByAggregateInput = {
    progress?: SortOrder
    creditsCost?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumCreditTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeFilter<$PrismaModel> | $Enums.CreditTransactionType
  }

  export type CreditTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type CreditTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    description?: SortOrder
    relatedId?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type EnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreditTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outTradeNo?: SortOrder
    amount?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    payUrl?: SortOrder
    qrCodeUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    credits?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outTradeNo?: SortOrder
    amount?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    payUrl?: SortOrder
    qrCodeUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    outTradeNo?: SortOrder
    amount?: SortOrder
    credits?: SortOrder
    description?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    providerOrderId?: SortOrder
    payUrl?: SortOrder
    qrCodeUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
    expiredAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    credits?: SortOrder
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    outRefundNo?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    refundAmount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    outRefundNo?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    outRefundNo?: SortOrder
    refundAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    providerRefundId?: SortOrder
    operatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    refundedAt?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    refundAmount?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    key?: SortOrder
    url?: SortOrder
    size?: SortOrder
    contentType?: SortOrder
    type?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageStatsProviderModelDateCompoundUniqueInput = {
    provider: string
    model: string
    date: Date | string
  }

  export type AIUsageStatsCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageStatsAvgOrderByAggregateInput = {
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type AIUsageStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageStatsMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIUsageStatsSumOrderByAggregateInput = {
    requestCount?: SortOrder
    totalTokens?: SortOrder
    totalCost?: SortOrder
  }

  export type EnumDiscussionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionStatus | EnumDiscussionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionStatusFilter<$PrismaModel> | $Enums.DiscussionStatus
  }

  export type DiscussionMessageListRelationFilter = {
    every?: DiscussionMessageWhereInput
    some?: DiscussionMessageWhereInput
    none?: DiscussionMessageWhereInput
  }

  export type DiscussionMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IdeaDiscussionCountOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    totalRounds?: SortOrder
    aiAgentType?: SortOrder
    aiAgentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IdeaDiscussionAvgOrderByAggregateInput = {
    currentRound?: SortOrder
    totalRounds?: SortOrder
  }

  export type IdeaDiscussionMaxOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    totalRounds?: SortOrder
    aiAgentType?: SortOrder
    aiAgentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IdeaDiscussionMinOrderByAggregateInput = {
    id?: SortOrder
    ideaId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    currentRound?: SortOrder
    totalRounds?: SortOrder
    aiAgentType?: SortOrder
    aiAgentName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type IdeaDiscussionSumOrderByAggregateInput = {
    currentRound?: SortOrder
    totalRounds?: SortOrder
  }

  export type EnumDiscussionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionStatus | EnumDiscussionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DiscussionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscussionStatusFilter<$PrismaModel>
    _max?: NestedEnumDiscussionStatusFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type IdeaDiscussionScalarRelationFilter = {
    is?: IdeaDiscussionWhereInput
    isNot?: IdeaDiscussionWhereInput
  }

  export type DiscussionMessageCountOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    roundNumber?: SortOrder
    senderType?: SortOrder
    senderName?: SortOrder
    analysisData?: SortOrder
    suggestions?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscussionMessageAvgOrderByAggregateInput = {
    roundNumber?: SortOrder
  }

  export type DiscussionMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    roundNumber?: SortOrder
    senderType?: SortOrder
    senderName?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscussionMessageMinOrderByAggregateInput = {
    id?: SortOrder
    discussionId?: SortOrder
    content?: SortOrder
    messageType?: SortOrder
    roundNumber?: SortOrder
    senderType?: SortOrder
    senderName?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscussionMessageSumOrderByAggregateInput = {
    roundNumber?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    agentId?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    price?: SortOrder
    quantity?: SortOrder
  }

  export type EnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type EnumAgentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusFilter<$PrismaModel> | $Enums.AgentStatus
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    price?: SortOrder
    credits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    price?: SortOrder
    credits?: SortOrder
  }

  export type EnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type EnumAgentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentStatusFilter<$PrismaModel>
    _max?: NestedEnumAgentStatusFilter<$PrismaModel>
  }

  export type IdeaCreateNestedManyWithoutUserInput = {
    create?: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput> | IdeaCreateWithoutUserInput[] | IdeaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutUserInput | IdeaCreateOrConnectWithoutUserInput[]
    createMany?: IdeaCreateManyUserInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type ResearchReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput> | ResearchReportCreateWithoutUserInput[] | ResearchReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutUserInput | ResearchReportCreateOrConnectWithoutUserInput[]
    createMany?: ResearchReportCreateManyUserInputEnvelope
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
  }

  export type CreditTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type IdeaDiscussionCreateNestedManyWithoutUserInput = {
    create?: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput> | IdeaDiscussionCreateWithoutUserInput[] | IdeaDiscussionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutUserInput | IdeaDiscussionCreateOrConnectWithoutUserInput[]
    createMany?: IdeaDiscussionCreateManyUserInputEnvelope
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutUserInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type BiddingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput> | BiddingSessionCreateWithoutUserInput[] | BiddingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutUserInput | BiddingSessionCreateOrConnectWithoutUserInput[]
    createMany?: BiddingSessionCreateManyUserInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type PriceGuessCreateNestedManyWithoutUserInput = {
    create?: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput> | PriceGuessCreateWithoutUserInput[] | PriceGuessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutUserInput | PriceGuessCreateOrConnectWithoutUserInput[]
    createMany?: PriceGuessCreateManyUserInputEnvelope
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
  }

  export type UserBiddingBehaviorCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput> | UserBiddingBehaviorCreateWithoutUserInput[] | UserBiddingBehaviorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutUserInput | UserBiddingBehaviorCreateOrConnectWithoutUserInput[]
    createMany?: UserBiddingBehaviorCreateManyUserInputEnvelope
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type IdeaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput> | IdeaCreateWithoutUserInput[] | IdeaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutUserInput | IdeaCreateOrConnectWithoutUserInput[]
    createMany?: IdeaCreateManyUserInputEnvelope
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
  }

  export type ResearchReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput> | ResearchReportCreateWithoutUserInput[] | ResearchReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutUserInput | ResearchReportCreateOrConnectWithoutUserInput[]
    createMany?: ResearchReportCreateManyUserInputEnvelope
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
  }

  export type CreditTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput> | IdeaDiscussionCreateWithoutUserInput[] | IdeaDiscussionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutUserInput | IdeaDiscussionCreateOrConnectWithoutUserInput[]
    createMany?: IdeaDiscussionCreateManyUserInputEnvelope
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type BiddingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput> | BiddingSessionCreateWithoutUserInput[] | BiddingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutUserInput | BiddingSessionCreateOrConnectWithoutUserInput[]
    createMany?: BiddingSessionCreateManyUserInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type PriceGuessUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput> | PriceGuessCreateWithoutUserInput[] | PriceGuessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutUserInput | PriceGuessCreateOrConnectWithoutUserInput[]
    createMany?: PriceGuessCreateManyUserInputEnvelope
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
  }

  export type UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput> | UserBiddingBehaviorCreateWithoutUserInput[] | UserBiddingBehaviorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutUserInput | UserBiddingBehaviorCreateOrConnectWithoutUserInput[]
    createMany?: UserBiddingBehaviorCreateManyUserInputEnvelope
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUserLevelFieldUpdateOperationsInput = {
    set?: $Enums.UserLevel
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IdeaUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput> | IdeaCreateWithoutUserInput[] | IdeaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutUserInput | IdeaCreateOrConnectWithoutUserInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutUserInput | IdeaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdeaCreateManyUserInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutUserInput | IdeaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutUserInput | IdeaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type ResearchReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput> | ResearchReportCreateWithoutUserInput[] | ResearchReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutUserInput | ResearchReportCreateOrConnectWithoutUserInput[]
    upsert?: ResearchReportUpsertWithWhereUniqueWithoutUserInput | ResearchReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResearchReportCreateManyUserInputEnvelope
    set?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    disconnect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    delete?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    update?: ResearchReportUpdateWithWhereUniqueWithoutUserInput | ResearchReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResearchReportUpdateManyWithWhereWithoutUserInput | ResearchReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
  }

  export type CreditTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CreditTransactionUpsertWithWhereUniqueWithoutUserInput | CreditTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    set?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    disconnect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    delete?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    update?: CreditTransactionUpdateWithWhereUniqueWithoutUserInput | CreditTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditTransactionUpdateManyWithWhereWithoutUserInput | CreditTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FileUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type IdeaDiscussionUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput> | IdeaDiscussionCreateWithoutUserInput[] | IdeaDiscussionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutUserInput | IdeaDiscussionCreateOrConnectWithoutUserInput[]
    upsert?: IdeaDiscussionUpsertWithWhereUniqueWithoutUserInput | IdeaDiscussionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdeaDiscussionCreateManyUserInputEnvelope
    set?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    disconnect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    delete?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    update?: IdeaDiscussionUpdateWithWhereUniqueWithoutUserInput | IdeaDiscussionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdeaDiscussionUpdateManyWithWhereWithoutUserInput | IdeaDiscussionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUserInput | CartItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUserInput | CartItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUserInput | CartItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type BiddingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput> | BiddingSessionCreateWithoutUserInput[] | BiddingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutUserInput | BiddingSessionCreateOrConnectWithoutUserInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutUserInput | BiddingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiddingSessionCreateManyUserInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutUserInput | BiddingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutUserInput | BiddingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type PriceGuessUpdateManyWithoutUserNestedInput = {
    create?: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput> | PriceGuessCreateWithoutUserInput[] | PriceGuessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutUserInput | PriceGuessCreateOrConnectWithoutUserInput[]
    upsert?: PriceGuessUpsertWithWhereUniqueWithoutUserInput | PriceGuessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PriceGuessCreateManyUserInputEnvelope
    set?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    disconnect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    delete?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    update?: PriceGuessUpdateWithWhereUniqueWithoutUserInput | PriceGuessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PriceGuessUpdateManyWithWhereWithoutUserInput | PriceGuessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
  }

  export type UserBiddingBehaviorUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput> | UserBiddingBehaviorCreateWithoutUserInput[] | UserBiddingBehaviorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutUserInput | UserBiddingBehaviorCreateOrConnectWithoutUserInput[]
    upsert?: UserBiddingBehaviorUpsertWithWhereUniqueWithoutUserInput | UserBiddingBehaviorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBiddingBehaviorCreateManyUserInputEnvelope
    set?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    disconnect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    delete?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    update?: UserBiddingBehaviorUpdateWithWhereUniqueWithoutUserInput | UserBiddingBehaviorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBiddingBehaviorUpdateManyWithWhereWithoutUserInput | UserBiddingBehaviorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type IdeaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput> | IdeaCreateWithoutUserInput[] | IdeaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaCreateOrConnectWithoutUserInput | IdeaCreateOrConnectWithoutUserInput[]
    upsert?: IdeaUpsertWithWhereUniqueWithoutUserInput | IdeaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdeaCreateManyUserInputEnvelope
    set?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    disconnect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    delete?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    connect?: IdeaWhereUniqueInput | IdeaWhereUniqueInput[]
    update?: IdeaUpdateWithWhereUniqueWithoutUserInput | IdeaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdeaUpdateManyWithWhereWithoutUserInput | IdeaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
  }

  export type ResearchReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput> | ResearchReportCreateWithoutUserInput[] | ResearchReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutUserInput | ResearchReportCreateOrConnectWithoutUserInput[]
    upsert?: ResearchReportUpsertWithWhereUniqueWithoutUserInput | ResearchReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResearchReportCreateManyUserInputEnvelope
    set?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    disconnect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    delete?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    update?: ResearchReportUpdateWithWhereUniqueWithoutUserInput | ResearchReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResearchReportUpdateManyWithWhereWithoutUserInput | ResearchReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
  }

  export type CreditTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput> | CreditTransactionCreateWithoutUserInput[] | CreditTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CreditTransactionCreateOrConnectWithoutUserInput | CreditTransactionCreateOrConnectWithoutUserInput[]
    upsert?: CreditTransactionUpsertWithWhereUniqueWithoutUserInput | CreditTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CreditTransactionCreateManyUserInputEnvelope
    set?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    disconnect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    delete?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    connect?: CreditTransactionWhereUniqueInput | CreditTransactionWhereUniqueInput[]
    update?: CreditTransactionUpdateWithWhereUniqueWithoutUserInput | CreditTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CreditTransactionUpdateManyWithWhereWithoutUserInput | CreditTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput> | FileCreateWithoutUserInput[] | FileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FileCreateOrConnectWithoutUserInput | FileCreateOrConnectWithoutUserInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutUserInput | FileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FileCreateManyUserInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutUserInput | FileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FileUpdateManyWithWhereWithoutUserInput | FileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput> | IdeaDiscussionCreateWithoutUserInput[] | IdeaDiscussionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutUserInput | IdeaDiscussionCreateOrConnectWithoutUserInput[]
    upsert?: IdeaDiscussionUpsertWithWhereUniqueWithoutUserInput | IdeaDiscussionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IdeaDiscussionCreateManyUserInputEnvelope
    set?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    disconnect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    delete?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    update?: IdeaDiscussionUpdateWithWhereUniqueWithoutUserInput | IdeaDiscussionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IdeaDiscussionUpdateManyWithWhereWithoutUserInput | IdeaDiscussionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput> | CartItemCreateWithoutUserInput[] | CartItemUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutUserInput | CartItemCreateOrConnectWithoutUserInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutUserInput | CartItemUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartItemCreateManyUserInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutUserInput | CartItemUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutUserInput | CartItemUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type BiddingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput> | BiddingSessionCreateWithoutUserInput[] | BiddingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutUserInput | BiddingSessionCreateOrConnectWithoutUserInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutUserInput | BiddingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiddingSessionCreateManyUserInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutUserInput | BiddingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutUserInput | BiddingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type PriceGuessUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput> | PriceGuessCreateWithoutUserInput[] | PriceGuessUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutUserInput | PriceGuessCreateOrConnectWithoutUserInput[]
    upsert?: PriceGuessUpsertWithWhereUniqueWithoutUserInput | PriceGuessUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PriceGuessCreateManyUserInputEnvelope
    set?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    disconnect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    delete?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    update?: PriceGuessUpdateWithWhereUniqueWithoutUserInput | PriceGuessUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PriceGuessUpdateManyWithWhereWithoutUserInput | PriceGuessUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
  }

  export type UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput> | UserBiddingBehaviorCreateWithoutUserInput[] | UserBiddingBehaviorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutUserInput | UserBiddingBehaviorCreateOrConnectWithoutUserInput[]
    upsert?: UserBiddingBehaviorUpsertWithWhereUniqueWithoutUserInput | UserBiddingBehaviorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBiddingBehaviorCreateManyUserInputEnvelope
    set?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    disconnect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    delete?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    update?: UserBiddingBehaviorUpdateWithWhereUniqueWithoutUserInput | UserBiddingBehaviorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBiddingBehaviorUpdateManyWithWhereWithoutUserInput | UserBiddingBehaviorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutIdeasInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    connect?: UserWhereUniqueInput
  }

  export type ResearchReportCreateNestedManyWithoutIdeaInput = {
    create?: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput> | ResearchReportCreateWithoutIdeaInput[] | ResearchReportUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutIdeaInput | ResearchReportCreateOrConnectWithoutIdeaInput[]
    createMany?: ResearchReportCreateManyIdeaInputEnvelope
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
  }

  export type IdeaDiscussionCreateNestedManyWithoutIdeaInput = {
    create?: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput> | IdeaDiscussionCreateWithoutIdeaInput[] | IdeaDiscussionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutIdeaInput | IdeaDiscussionCreateOrConnectWithoutIdeaInput[]
    createMany?: IdeaDiscussionCreateManyIdeaInputEnvelope
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
  }

  export type BiddingSessionCreateNestedManyWithoutIdeaInput = {
    create?: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput> | BiddingSessionCreateWithoutIdeaInput[] | BiddingSessionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutIdeaInput | BiddingSessionCreateOrConnectWithoutIdeaInput[]
    createMany?: BiddingSessionCreateManyIdeaInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type ResearchReportUncheckedCreateNestedManyWithoutIdeaInput = {
    create?: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput> | ResearchReportCreateWithoutIdeaInput[] | ResearchReportUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutIdeaInput | ResearchReportCreateOrConnectWithoutIdeaInput[]
    createMany?: ResearchReportCreateManyIdeaInputEnvelope
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
  }

  export type IdeaDiscussionUncheckedCreateNestedManyWithoutIdeaInput = {
    create?: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput> | IdeaDiscussionCreateWithoutIdeaInput[] | IdeaDiscussionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutIdeaInput | IdeaDiscussionCreateOrConnectWithoutIdeaInput[]
    createMany?: IdeaDiscussionCreateManyIdeaInputEnvelope
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
  }

  export type BiddingSessionUncheckedCreateNestedManyWithoutIdeaInput = {
    create?: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput> | BiddingSessionCreateWithoutIdeaInput[] | BiddingSessionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutIdeaInput | BiddingSessionCreateOrConnectWithoutIdeaInput[]
    createMany?: BiddingSessionCreateManyIdeaInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type EnumIdeaCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IdeaCategory
  }

  export type EnumIdeaStatusFieldUpdateOperationsInput = {
    set?: $Enums.IdeaStatus
  }

  export type EnumIdeaVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.IdeaVisibility
  }

  export type UserUpdateOneRequiredWithoutIdeasNestedInput = {
    create?: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    connectOrCreate?: UserCreateOrConnectWithoutIdeasInput
    upsert?: UserUpsertWithoutIdeasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIdeasInput, UserUpdateWithoutIdeasInput>, UserUncheckedUpdateWithoutIdeasInput>
  }

  export type ResearchReportUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput> | ResearchReportCreateWithoutIdeaInput[] | ResearchReportUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutIdeaInput | ResearchReportCreateOrConnectWithoutIdeaInput[]
    upsert?: ResearchReportUpsertWithWhereUniqueWithoutIdeaInput | ResearchReportUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: ResearchReportCreateManyIdeaInputEnvelope
    set?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    disconnect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    delete?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    update?: ResearchReportUpdateWithWhereUniqueWithoutIdeaInput | ResearchReportUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: ResearchReportUpdateManyWithWhereWithoutIdeaInput | ResearchReportUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
  }

  export type IdeaDiscussionUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput> | IdeaDiscussionCreateWithoutIdeaInput[] | IdeaDiscussionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutIdeaInput | IdeaDiscussionCreateOrConnectWithoutIdeaInput[]
    upsert?: IdeaDiscussionUpsertWithWhereUniqueWithoutIdeaInput | IdeaDiscussionUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: IdeaDiscussionCreateManyIdeaInputEnvelope
    set?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    disconnect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    delete?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    update?: IdeaDiscussionUpdateWithWhereUniqueWithoutIdeaInput | IdeaDiscussionUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: IdeaDiscussionUpdateManyWithWhereWithoutIdeaInput | IdeaDiscussionUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
  }

  export type BiddingSessionUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput> | BiddingSessionCreateWithoutIdeaInput[] | BiddingSessionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutIdeaInput | BiddingSessionCreateOrConnectWithoutIdeaInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutIdeaInput | BiddingSessionUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: BiddingSessionCreateManyIdeaInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutIdeaInput | BiddingSessionUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutIdeaInput | BiddingSessionUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type ResearchReportUncheckedUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput> | ResearchReportCreateWithoutIdeaInput[] | ResearchReportUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: ResearchReportCreateOrConnectWithoutIdeaInput | ResearchReportCreateOrConnectWithoutIdeaInput[]
    upsert?: ResearchReportUpsertWithWhereUniqueWithoutIdeaInput | ResearchReportUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: ResearchReportCreateManyIdeaInputEnvelope
    set?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    disconnect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    delete?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    connect?: ResearchReportWhereUniqueInput | ResearchReportWhereUniqueInput[]
    update?: ResearchReportUpdateWithWhereUniqueWithoutIdeaInput | ResearchReportUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: ResearchReportUpdateManyWithWhereWithoutIdeaInput | ResearchReportUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
  }

  export type IdeaDiscussionUncheckedUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput> | IdeaDiscussionCreateWithoutIdeaInput[] | IdeaDiscussionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutIdeaInput | IdeaDiscussionCreateOrConnectWithoutIdeaInput[]
    upsert?: IdeaDiscussionUpsertWithWhereUniqueWithoutIdeaInput | IdeaDiscussionUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: IdeaDiscussionCreateManyIdeaInputEnvelope
    set?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    disconnect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    delete?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    connect?: IdeaDiscussionWhereUniqueInput | IdeaDiscussionWhereUniqueInput[]
    update?: IdeaDiscussionUpdateWithWhereUniqueWithoutIdeaInput | IdeaDiscussionUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: IdeaDiscussionUpdateManyWithWhereWithoutIdeaInput | IdeaDiscussionUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
  }

  export type BiddingSessionUncheckedUpdateManyWithoutIdeaNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput> | BiddingSessionCreateWithoutIdeaInput[] | BiddingSessionUncheckedCreateWithoutIdeaInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutIdeaInput | BiddingSessionCreateOrConnectWithoutIdeaInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutIdeaInput | BiddingSessionUpsertWithWhereUniqueWithoutIdeaInput[]
    createMany?: BiddingSessionCreateManyIdeaInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutIdeaInput | BiddingSessionUpdateWithWhereUniqueWithoutIdeaInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutIdeaInput | BiddingSessionUpdateManyWithWhereWithoutIdeaInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type IdeaCreateNestedOneWithoutBiddingSessionsInput = {
    create?: XOR<IdeaCreateWithoutBiddingSessionsInput, IdeaUncheckedCreateWithoutBiddingSessionsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutBiddingSessionsInput
    connect?: IdeaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBiddingSessionsInput = {
    create?: XOR<UserCreateWithoutBiddingSessionsInput, UserUncheckedCreateWithoutBiddingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiddingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type IdeaDiscussionCreateNestedOneWithoutSessionsInput = {
    create?: XOR<IdeaDiscussionCreateWithoutSessionsInput, IdeaDiscussionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutSessionsInput
    connect?: IdeaDiscussionWhereUniqueInput
  }

  export type BidCreateNestedManyWithoutSessionInput = {
    create?: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput> | BidCreateWithoutSessionInput[] | BidUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BidCreateOrConnectWithoutSessionInput | BidCreateOrConnectWithoutSessionInput[]
    createMany?: BidCreateManySessionInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type PriceGuessCreateNestedManyWithoutSessionInput = {
    create?: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput> | PriceGuessCreateWithoutSessionInput[] | PriceGuessUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutSessionInput | PriceGuessCreateOrConnectWithoutSessionInput[]
    createMany?: PriceGuessCreateManySessionInputEnvelope
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
  }

  export type AIInteractionCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput> | AIInteractionCreateWithoutSessionInput[] | AIInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIInteractionCreateOrConnectWithoutSessionInput | AIInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: AIInteractionCreateManySessionInputEnvelope
    connect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
  }

  export type UserBiddingBehaviorCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput> | UserBiddingBehaviorCreateWithoutSessionInput[] | UserBiddingBehaviorUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutSessionInput | UserBiddingBehaviorCreateOrConnectWithoutSessionInput[]
    createMany?: UserBiddingBehaviorCreateManySessionInputEnvelope
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
  }

  export type BidUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput> | BidCreateWithoutSessionInput[] | BidUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BidCreateOrConnectWithoutSessionInput | BidCreateOrConnectWithoutSessionInput[]
    createMany?: BidCreateManySessionInputEnvelope
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
  }

  export type PriceGuessUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput> | PriceGuessCreateWithoutSessionInput[] | PriceGuessUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutSessionInput | PriceGuessCreateOrConnectWithoutSessionInput[]
    createMany?: PriceGuessCreateManySessionInputEnvelope
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
  }

  export type AIInteractionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput> | AIInteractionCreateWithoutSessionInput[] | AIInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIInteractionCreateOrConnectWithoutSessionInput | AIInteractionCreateOrConnectWithoutSessionInput[]
    createMany?: AIInteractionCreateManySessionInputEnvelope
    connect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
  }

  export type UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput> | UserBiddingBehaviorCreateWithoutSessionInput[] | UserBiddingBehaviorUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutSessionInput | UserBiddingBehaviorCreateOrConnectWithoutSessionInput[]
    createMany?: UserBiddingBehaviorCreateManySessionInputEnvelope
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBiddingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BiddingStatus
  }

  export type EnumBiddingPhaseFieldUpdateOperationsInput = {
    set?: $Enums.BiddingPhase
  }

  export type IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput = {
    create?: XOR<IdeaCreateWithoutBiddingSessionsInput, IdeaUncheckedCreateWithoutBiddingSessionsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutBiddingSessionsInput
    upsert?: IdeaUpsertWithoutBiddingSessionsInput
    connect?: IdeaWhereUniqueInput
    update?: XOR<XOR<IdeaUpdateToOneWithWhereWithoutBiddingSessionsInput, IdeaUpdateWithoutBiddingSessionsInput>, IdeaUncheckedUpdateWithoutBiddingSessionsInput>
  }

  export type UserUpdateOneWithoutBiddingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutBiddingSessionsInput, UserUncheckedCreateWithoutBiddingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiddingSessionsInput
    upsert?: UserUpsertWithoutBiddingSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiddingSessionsInput, UserUpdateWithoutBiddingSessionsInput>, UserUncheckedUpdateWithoutBiddingSessionsInput>
  }

  export type IdeaDiscussionUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutSessionsInput, IdeaDiscussionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutSessionsInput
    upsert?: IdeaDiscussionUpsertWithoutSessionsInput
    disconnect?: IdeaDiscussionWhereInput | boolean
    delete?: IdeaDiscussionWhereInput | boolean
    connect?: IdeaDiscussionWhereUniqueInput
    update?: XOR<XOR<IdeaDiscussionUpdateToOneWithWhereWithoutSessionsInput, IdeaDiscussionUpdateWithoutSessionsInput>, IdeaDiscussionUncheckedUpdateWithoutSessionsInput>
  }

  export type BidUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput> | BidCreateWithoutSessionInput[] | BidUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BidCreateOrConnectWithoutSessionInput | BidCreateOrConnectWithoutSessionInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutSessionInput | BidUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BidCreateManySessionInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutSessionInput | BidUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BidUpdateManyWithWhereWithoutSessionInput | BidUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type PriceGuessUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput> | PriceGuessCreateWithoutSessionInput[] | PriceGuessUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutSessionInput | PriceGuessCreateOrConnectWithoutSessionInput[]
    upsert?: PriceGuessUpsertWithWhereUniqueWithoutSessionInput | PriceGuessUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PriceGuessCreateManySessionInputEnvelope
    set?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    disconnect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    delete?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    update?: PriceGuessUpdateWithWhereUniqueWithoutSessionInput | PriceGuessUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PriceGuessUpdateManyWithWhereWithoutSessionInput | PriceGuessUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
  }

  export type AIInteractionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput> | AIInteractionCreateWithoutSessionInput[] | AIInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIInteractionCreateOrConnectWithoutSessionInput | AIInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: AIInteractionUpsertWithWhereUniqueWithoutSessionInput | AIInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIInteractionCreateManySessionInputEnvelope
    set?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    disconnect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    delete?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    connect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    update?: AIInteractionUpdateWithWhereUniqueWithoutSessionInput | AIInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIInteractionUpdateManyWithWhereWithoutSessionInput | AIInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIInteractionScalarWhereInput | AIInteractionScalarWhereInput[]
  }

  export type UserBiddingBehaviorUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput> | UserBiddingBehaviorCreateWithoutSessionInput[] | UserBiddingBehaviorUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutSessionInput | UserBiddingBehaviorCreateOrConnectWithoutSessionInput[]
    upsert?: UserBiddingBehaviorUpsertWithWhereUniqueWithoutSessionInput | UserBiddingBehaviorUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserBiddingBehaviorCreateManySessionInputEnvelope
    set?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    disconnect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    delete?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    update?: UserBiddingBehaviorUpdateWithWhereUniqueWithoutSessionInput | UserBiddingBehaviorUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserBiddingBehaviorUpdateManyWithWhereWithoutSessionInput | UserBiddingBehaviorUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
  }

  export type BidUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput> | BidCreateWithoutSessionInput[] | BidUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BidCreateOrConnectWithoutSessionInput | BidCreateOrConnectWithoutSessionInput[]
    upsert?: BidUpsertWithWhereUniqueWithoutSessionInput | BidUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BidCreateManySessionInputEnvelope
    set?: BidWhereUniqueInput | BidWhereUniqueInput[]
    disconnect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    delete?: BidWhereUniqueInput | BidWhereUniqueInput[]
    connect?: BidWhereUniqueInput | BidWhereUniqueInput[]
    update?: BidUpdateWithWhereUniqueWithoutSessionInput | BidUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BidUpdateManyWithWhereWithoutSessionInput | BidUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BidScalarWhereInput | BidScalarWhereInput[]
  }

  export type PriceGuessUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput> | PriceGuessCreateWithoutSessionInput[] | PriceGuessUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PriceGuessCreateOrConnectWithoutSessionInput | PriceGuessCreateOrConnectWithoutSessionInput[]
    upsert?: PriceGuessUpsertWithWhereUniqueWithoutSessionInput | PriceGuessUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PriceGuessCreateManySessionInputEnvelope
    set?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    disconnect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    delete?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    connect?: PriceGuessWhereUniqueInput | PriceGuessWhereUniqueInput[]
    update?: PriceGuessUpdateWithWhereUniqueWithoutSessionInput | PriceGuessUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PriceGuessUpdateManyWithWhereWithoutSessionInput | PriceGuessUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
  }

  export type AIInteractionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput> | AIInteractionCreateWithoutSessionInput[] | AIInteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AIInteractionCreateOrConnectWithoutSessionInput | AIInteractionCreateOrConnectWithoutSessionInput[]
    upsert?: AIInteractionUpsertWithWhereUniqueWithoutSessionInput | AIInteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AIInteractionCreateManySessionInputEnvelope
    set?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    disconnect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    delete?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    connect?: AIInteractionWhereUniqueInput | AIInteractionWhereUniqueInput[]
    update?: AIInteractionUpdateWithWhereUniqueWithoutSessionInput | AIInteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AIInteractionUpdateManyWithWhereWithoutSessionInput | AIInteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AIInteractionScalarWhereInput | AIInteractionScalarWhereInput[]
  }

  export type UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput> | UserBiddingBehaviorCreateWithoutSessionInput[] | UserBiddingBehaviorUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: UserBiddingBehaviorCreateOrConnectWithoutSessionInput | UserBiddingBehaviorCreateOrConnectWithoutSessionInput[]
    upsert?: UserBiddingBehaviorUpsertWithWhereUniqueWithoutSessionInput | UserBiddingBehaviorUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: UserBiddingBehaviorCreateManySessionInputEnvelope
    set?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    disconnect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    delete?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    connect?: UserBiddingBehaviorWhereUniqueInput | UserBiddingBehaviorWhereUniqueInput[]
    update?: UserBiddingBehaviorUpdateWithWhereUniqueWithoutSessionInput | UserBiddingBehaviorUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: UserBiddingBehaviorUpdateManyWithWhereWithoutSessionInput | UserBiddingBehaviorUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
  }

  export type BiddingSessionCreateNestedOneWithoutBidsInput = {
    create?: XOR<BiddingSessionCreateWithoutBidsInput, BiddingSessionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutBidsInput
    connect?: BiddingSessionWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BiddingSessionUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutBidsInput, BiddingSessionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutBidsInput
    upsert?: BiddingSessionUpsertWithoutBidsInput
    connect?: BiddingSessionWhereUniqueInput
    update?: XOR<XOR<BiddingSessionUpdateToOneWithWhereWithoutBidsInput, BiddingSessionUpdateWithoutBidsInput>, BiddingSessionUncheckedUpdateWithoutBidsInput>
  }

  export type BiddingSessionCreateNestedOneWithoutPriceGuessesInput = {
    create?: XOR<BiddingSessionCreateWithoutPriceGuessesInput, BiddingSessionUncheckedCreateWithoutPriceGuessesInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutPriceGuessesInput
    connect?: BiddingSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPriceGuessesInput = {
    create?: XOR<UserCreateWithoutPriceGuessesInput, UserUncheckedCreateWithoutPriceGuessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceGuessesInput
    connect?: UserWhereUniqueInput
  }

  export type BiddingSessionUpdateOneRequiredWithoutPriceGuessesNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutPriceGuessesInput, BiddingSessionUncheckedCreateWithoutPriceGuessesInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutPriceGuessesInput
    upsert?: BiddingSessionUpsertWithoutPriceGuessesInput
    connect?: BiddingSessionWhereUniqueInput
    update?: XOR<XOR<BiddingSessionUpdateToOneWithWhereWithoutPriceGuessesInput, BiddingSessionUpdateWithoutPriceGuessesInput>, BiddingSessionUncheckedUpdateWithoutPriceGuessesInput>
  }

  export type UserUpdateOneRequiredWithoutPriceGuessesNestedInput = {
    create?: XOR<UserCreateWithoutPriceGuessesInput, UserUncheckedCreateWithoutPriceGuessesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPriceGuessesInput
    upsert?: UserUpsertWithoutPriceGuessesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPriceGuessesInput, UserUpdateWithoutPriceGuessesInput>, UserUncheckedUpdateWithoutPriceGuessesInput>
  }

  export type BiddingSessionCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<BiddingSessionCreateWithoutInteractionsInput, BiddingSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutInteractionsInput
    connect?: BiddingSessionWhereUniqueInput
  }

  export type EnumAIInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AIInteractionType
  }

  export type BiddingSessionUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutInteractionsInput, BiddingSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutInteractionsInput
    upsert?: BiddingSessionUpsertWithoutInteractionsInput
    connect?: BiddingSessionWhereUniqueInput
    update?: XOR<XOR<BiddingSessionUpdateToOneWithWhereWithoutInteractionsInput, BiddingSessionUpdateWithoutInteractionsInput>, BiddingSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type BiddingSessionCreateNestedOneWithoutBehaviorsInput = {
    create?: XOR<BiddingSessionCreateWithoutBehaviorsInput, BiddingSessionUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutBehaviorsInput
    connect?: BiddingSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBiddingBehaviorsInput = {
    create?: XOR<UserCreateWithoutBiddingBehaviorsInput, UserUncheckedCreateWithoutBiddingBehaviorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiddingBehaviorsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUserBiddingActionFieldUpdateOperationsInput = {
    set?: $Enums.UserBiddingAction
  }

  export type BiddingSessionUpdateOneRequiredWithoutBehaviorsNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutBehaviorsInput, BiddingSessionUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutBehaviorsInput
    upsert?: BiddingSessionUpsertWithoutBehaviorsInput
    connect?: BiddingSessionWhereUniqueInput
    update?: XOR<XOR<BiddingSessionUpdateToOneWithWhereWithoutBehaviorsInput, BiddingSessionUpdateWithoutBehaviorsInput>, BiddingSessionUncheckedUpdateWithoutBehaviorsInput>
  }

  export type UserUpdateOneRequiredWithoutBiddingBehaviorsNestedInput = {
    create?: XOR<UserCreateWithoutBiddingBehaviorsInput, UserUncheckedCreateWithoutBiddingBehaviorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiddingBehaviorsInput
    upsert?: UserUpsertWithoutBiddingBehaviorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiddingBehaviorsInput, UserUpdateWithoutBiddingBehaviorsInput>, UserUncheckedUpdateWithoutBiddingBehaviorsInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type IdeaCreateNestedOneWithoutResearchReportsInput = {
    create?: XOR<IdeaCreateWithoutResearchReportsInput, IdeaUncheckedCreateWithoutResearchReportsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutResearchReportsInput
    connect?: IdeaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResearchReportsInput = {
    create?: XOR<UserCreateWithoutResearchReportsInput, UserUncheckedCreateWithoutResearchReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResearchReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type IdeaUpdateOneRequiredWithoutResearchReportsNestedInput = {
    create?: XOR<IdeaCreateWithoutResearchReportsInput, IdeaUncheckedCreateWithoutResearchReportsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutResearchReportsInput
    upsert?: IdeaUpsertWithoutResearchReportsInput
    connect?: IdeaWhereUniqueInput
    update?: XOR<XOR<IdeaUpdateToOneWithWhereWithoutResearchReportsInput, IdeaUpdateWithoutResearchReportsInput>, IdeaUncheckedUpdateWithoutResearchReportsInput>
  }

  export type UserUpdateOneRequiredWithoutResearchReportsNestedInput = {
    create?: XOR<UserCreateWithoutResearchReportsInput, UserUncheckedCreateWithoutResearchReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResearchReportsInput
    upsert?: UserUpsertWithoutResearchReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResearchReportsInput, UserUpdateWithoutResearchReportsInput>, UserUncheckedUpdateWithoutResearchReportsInput>
  }

  export type UserCreateNestedOneWithoutCreditTransactionsInput = {
    create?: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCreditTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreditTransactionType
  }

  export type UserUpdateOneRequiredWithoutCreditTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditTransactionsInput
    upsert?: UserUpsertWithoutCreditTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreditTransactionsInput, UserUpdateWithoutCreditTransactionsInput>, UserUncheckedUpdateWithoutCreditTransactionsInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type UserCreateNestedOneWithoutFilesInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    upsert?: UserUpsertWithoutFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesInput, UserUpdateWithoutFilesInput>, UserUncheckedUpdateWithoutFilesInput>
  }

  export type IdeaCreateNestedOneWithoutDiscussionsInput = {
    create?: XOR<IdeaCreateWithoutDiscussionsInput, IdeaUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutDiscussionsInput
    connect?: IdeaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDiscussionsInput = {
    create?: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionsInput
    connect?: UserWhereUniqueInput
  }

  export type BiddingSessionCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput> | BiddingSessionCreateWithoutDiscussionInput[] | BiddingSessionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutDiscussionInput | BiddingSessionCreateOrConnectWithoutDiscussionInput[]
    createMany?: BiddingSessionCreateManyDiscussionInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type DiscussionMessageCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type BiddingSessionUncheckedCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput> | BiddingSessionCreateWithoutDiscussionInput[] | BiddingSessionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutDiscussionInput | BiddingSessionCreateOrConnectWithoutDiscussionInput[]
    createMany?: BiddingSessionCreateManyDiscussionInputEnvelope
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
  }

  export type DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
  }

  export type EnumDiscussionStatusFieldUpdateOperationsInput = {
    set?: $Enums.DiscussionStatus
  }

  export type IdeaUpdateOneRequiredWithoutDiscussionsNestedInput = {
    create?: XOR<IdeaCreateWithoutDiscussionsInput, IdeaUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: IdeaCreateOrConnectWithoutDiscussionsInput
    upsert?: IdeaUpsertWithoutDiscussionsInput
    connect?: IdeaWhereUniqueInput
    update?: XOR<XOR<IdeaUpdateToOneWithWhereWithoutDiscussionsInput, IdeaUpdateWithoutDiscussionsInput>, IdeaUncheckedUpdateWithoutDiscussionsInput>
  }

  export type UserUpdateOneRequiredWithoutDiscussionsNestedInput = {
    create?: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDiscussionsInput
    upsert?: UserUpsertWithoutDiscussionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDiscussionsInput, UserUpdateWithoutDiscussionsInput>, UserUncheckedUpdateWithoutDiscussionsInput>
  }

  export type BiddingSessionUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput> | BiddingSessionCreateWithoutDiscussionInput[] | BiddingSessionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutDiscussionInput | BiddingSessionCreateOrConnectWithoutDiscussionInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutDiscussionInput | BiddingSessionUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: BiddingSessionCreateManyDiscussionInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutDiscussionInput | BiddingSessionUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutDiscussionInput | BiddingSessionUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type DiscussionMessageUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput | DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type BiddingSessionUncheckedUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput> | BiddingSessionCreateWithoutDiscussionInput[] | BiddingSessionUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: BiddingSessionCreateOrConnectWithoutDiscussionInput | BiddingSessionCreateOrConnectWithoutDiscussionInput[]
    upsert?: BiddingSessionUpsertWithWhereUniqueWithoutDiscussionInput | BiddingSessionUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: BiddingSessionCreateManyDiscussionInputEnvelope
    set?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    disconnect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    delete?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    connect?: BiddingSessionWhereUniqueInput | BiddingSessionWhereUniqueInput[]
    update?: BiddingSessionUpdateWithWhereUniqueWithoutDiscussionInput | BiddingSessionUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: BiddingSessionUpdateManyWithWhereWithoutDiscussionInput | BiddingSessionUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput = {
    create?: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput> | DiscussionMessageCreateWithoutDiscussionInput[] | DiscussionMessageUncheckedCreateWithoutDiscussionInput[]
    connectOrCreate?: DiscussionMessageCreateOrConnectWithoutDiscussionInput | DiscussionMessageCreateOrConnectWithoutDiscussionInput[]
    upsert?: DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput[]
    createMany?: DiscussionMessageCreateManyDiscussionInputEnvelope
    set?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    disconnect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    delete?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    connect?: DiscussionMessageWhereUniqueInput | DiscussionMessageWhereUniqueInput[]
    update?: DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput | DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput[]
    updateMany?: DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput | DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput[]
    deleteMany?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
  }

  export type IdeaDiscussionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<IdeaDiscussionCreateWithoutMessagesInput, IdeaDiscussionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutMessagesInput
    connect?: IdeaDiscussionWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type IdeaDiscussionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<IdeaDiscussionCreateWithoutMessagesInput, IdeaDiscussionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: IdeaDiscussionCreateOrConnectWithoutMessagesInput
    upsert?: IdeaDiscussionUpsertWithoutMessagesInput
    connect?: IdeaDiscussionWhereUniqueInput
    update?: XOR<XOR<IdeaDiscussionUpdateToOneWithWhereWithoutMessagesInput, IdeaDiscussionUpdateWithoutMessagesInput>, IdeaDiscussionUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<UserCreateWithoutCartItemsInput, UserUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartItemsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCartItemsNestedInput = {
    create?: XOR<UserCreateWithoutCartItemsInput, UserUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartItemsInput
    upsert?: UserUpsertWithoutCartItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartItemsInput, UserUpdateWithoutCartItemsInput>, UserUncheckedUpdateWithoutCartItemsInput>
  }

  export type EnumAgentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AgentType
  }

  export type EnumAgentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AgentStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUserLevelFilter<$PrismaModel> | $Enums.UserLevel
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumUserLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserLevel | EnumUserLevelFieldRefInput<$PrismaModel>
    in?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserLevel[] | ListEnumUserLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumUserLevelWithAggregatesFilter<$PrismaModel> | $Enums.UserLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserLevelFilter<$PrismaModel>
    _max?: NestedEnumUserLevelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumIdeaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaCategory | EnumIdeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaCategoryFilter<$PrismaModel> | $Enums.IdeaCategory
  }

  export type NestedEnumIdeaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaStatus | EnumIdeaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaStatusFilter<$PrismaModel> | $Enums.IdeaStatus
  }

  export type NestedEnumIdeaVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaVisibility | EnumIdeaVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaVisibilityFilter<$PrismaModel> | $Enums.IdeaVisibility
  }

  export type NestedEnumIdeaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaCategory | EnumIdeaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaCategory[] | ListEnumIdeaCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IdeaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaCategoryFilter<$PrismaModel>
    _max?: NestedEnumIdeaCategoryFilter<$PrismaModel>
  }

  export type NestedEnumIdeaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaStatus | EnumIdeaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaStatus[] | ListEnumIdeaStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdeaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaStatusFilter<$PrismaModel>
    _max?: NestedEnumIdeaStatusFilter<$PrismaModel>
  }

  export type NestedEnumIdeaVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdeaVisibility | EnumIdeaVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdeaVisibility[] | ListEnumIdeaVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumIdeaVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.IdeaVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdeaVisibilityFilter<$PrismaModel>
    _max?: NestedEnumIdeaVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumBiddingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingStatus | EnumBiddingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingStatusFilter<$PrismaModel> | $Enums.BiddingStatus
  }

  export type NestedEnumBiddingPhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingPhase | EnumBiddingPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingPhaseFilter<$PrismaModel> | $Enums.BiddingPhase
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBiddingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingStatus | EnumBiddingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingStatus[] | ListEnumBiddingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BiddingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiddingStatusFilter<$PrismaModel>
    _max?: NestedEnumBiddingStatusFilter<$PrismaModel>
  }

  export type NestedEnumBiddingPhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiddingPhase | EnumBiddingPhaseFieldRefInput<$PrismaModel>
    in?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiddingPhase[] | ListEnumBiddingPhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumBiddingPhaseWithAggregatesFilter<$PrismaModel> | $Enums.BiddingPhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiddingPhaseFilter<$PrismaModel>
    _max?: NestedEnumBiddingPhaseFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAIInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInteractionType | EnumAIInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIInteractionTypeFilter<$PrismaModel> | $Enums.AIInteractionType
  }

  export type NestedEnumAIInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AIInteractionType | EnumAIInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AIInteractionType[] | ListEnumAIInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAIInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AIInteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAIInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumAIInteractionTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserBiddingActionFilter<$PrismaModel = never> = {
    equals?: $Enums.UserBiddingAction | EnumUserBiddingActionFieldRefInput<$PrismaModel>
    in?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumUserBiddingActionFilter<$PrismaModel> | $Enums.UserBiddingAction
  }

  export type NestedEnumUserBiddingActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserBiddingAction | EnumUserBiddingActionFieldRefInput<$PrismaModel>
    in?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserBiddingAction[] | ListEnumUserBiddingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumUserBiddingActionWithAggregatesFilter<$PrismaModel> | $Enums.UserBiddingAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserBiddingActionFilter<$PrismaModel>
    _max?: NestedEnumUserBiddingActionFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumCreditTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeFilter<$PrismaModel> | $Enums.CreditTransactionType
  }

  export type NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditTransactionType | EnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditTransactionType[] | ListEnumCreditTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreditTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscussionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionStatus | EnumDiscussionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionStatusFilter<$PrismaModel> | $Enums.DiscussionStatus
  }

  export type NestedEnumDiscussionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscussionStatus | EnumDiscussionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscussionStatus[] | ListEnumDiscussionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscussionStatusWithAggregatesFilter<$PrismaModel> | $Enums.DiscussionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscussionStatusFilter<$PrismaModel>
    _max?: NestedEnumDiscussionStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumAgentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeFilter<$PrismaModel> | $Enums.AgentType
  }

  export type NestedEnumAgentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusFilter<$PrismaModel> | $Enums.AgentStatus
  }

  export type NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentType | EnumAgentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentType[] | ListEnumAgentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AgentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentTypeFilter<$PrismaModel>
    _max?: NestedEnumAgentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgentStatus | EnumAgentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgentStatus[] | ListEnumAgentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAgentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AgentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgentStatusFilter<$PrismaModel>
    _max?: NestedEnumAgentStatusFilter<$PrismaModel>
  }

  export type IdeaCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    researchReports?: ResearchReportCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutUserInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput>
  }

  export type IdeaCreateManyUserInputEnvelope = {
    data: IdeaCreateManyUserInput | IdeaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResearchReportCreateWithoutUserInput = {
    id?: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutResearchReportsInput
  }

  export type ResearchReportUncheckedCreateWithoutUserInput = {
    id?: string
    ideaId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResearchReportCreateOrConnectWithoutUserInput = {
    where: ResearchReportWhereUniqueInput
    create: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput>
  }

  export type ResearchReportCreateManyUserInputEnvelope = {
    data: ResearchReportCreateManyUserInput | ResearchReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CreditTransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
  }

  export type CreditTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
  }

  export type CreditTransactionCreateOrConnectWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    create: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput>
  }

  export type CreditTransactionCreateManyUserInputEnvelope = {
    data: CreditTransactionCreateManyUserInput | CreditTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutUserInput = {
    id?: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileUncheckedCreateWithoutUserInput = {
    id?: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileCreateOrConnectWithoutUserInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileCreateManyUserInputEnvelope = {
    data: FileCreateManyUserInput | FileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IdeaDiscussionCreateWithoutUserInput = {
    id?: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutDiscussionsInput
    sessions?: BiddingSessionCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUncheckedCreateWithoutUserInput = {
    id?: string
    ideaId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sessions?: BiddingSessionUncheckedCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionCreateOrConnectWithoutUserInput = {
    where: IdeaDiscussionWhereUniqueInput
    create: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput>
  }

  export type IdeaDiscussionCreateManyUserInputEnvelope = {
    data: IdeaDiscussionCreateManyUserInput | IdeaDiscussionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutUserInput = {
    id?: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemUncheckedCreateWithoutUserInput = {
    id?: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutUserInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput>
  }

  export type CartItemCreateManyUserInputEnvelope = {
    data: CartItemCreateManyUserInput | CartItemCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BiddingSessionCreateWithoutUserInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    ideaId: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutUserInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput>
  }

  export type BiddingSessionCreateManyUserInputEnvelope = {
    data: BiddingSessionCreateManyUserInput | BiddingSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PriceGuessCreateWithoutUserInput = {
    id?: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
    session: BiddingSessionCreateNestedOneWithoutPriceGuessesInput
  }

  export type PriceGuessUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type PriceGuessCreateOrConnectWithoutUserInput = {
    where: PriceGuessWhereUniqueInput
    create: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput>
  }

  export type PriceGuessCreateManyUserInputEnvelope = {
    data: PriceGuessCreateManyUserInput | PriceGuessCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBiddingBehaviorCreateWithoutUserInput = {
    id?: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
    session: BiddingSessionCreateNestedOneWithoutBehaviorsInput
  }

  export type UserBiddingBehaviorUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type UserBiddingBehaviorCreateOrConnectWithoutUserInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    create: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput>
  }

  export type UserBiddingBehaviorCreateManyUserInputEnvelope = {
    data: UserBiddingBehaviorCreateManyUserInput | UserBiddingBehaviorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IdeaUpsertWithWhereUniqueWithoutUserInput = {
    where: IdeaWhereUniqueInput
    update: XOR<IdeaUpdateWithoutUserInput, IdeaUncheckedUpdateWithoutUserInput>
    create: XOR<IdeaCreateWithoutUserInput, IdeaUncheckedCreateWithoutUserInput>
  }

  export type IdeaUpdateWithWhereUniqueWithoutUserInput = {
    where: IdeaWhereUniqueInput
    data: XOR<IdeaUpdateWithoutUserInput, IdeaUncheckedUpdateWithoutUserInput>
  }

  export type IdeaUpdateManyWithWhereWithoutUserInput = {
    where: IdeaScalarWhereInput
    data: XOR<IdeaUpdateManyMutationInput, IdeaUncheckedUpdateManyWithoutUserInput>
  }

  export type IdeaScalarWhereInput = {
    AND?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
    OR?: IdeaScalarWhereInput[]
    NOT?: IdeaScalarWhereInput | IdeaScalarWhereInput[]
    id?: StringFilter<"Idea"> | string
    title?: StringFilter<"Idea"> | string
    description?: StringFilter<"Idea"> | string
    category?: EnumIdeaCategoryFilter<"Idea"> | $Enums.IdeaCategory
    tags?: StringFilter<"Idea"> | string
    userId?: StringFilter<"Idea"> | string
    isAnonymous?: BoolFilter<"Idea"> | boolean
    status?: EnumIdeaStatusFilter<"Idea"> | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFilter<"Idea"> | $Enums.IdeaVisibility
    viewCount?: IntFilter<"Idea"> | number
    likeCount?: IntFilter<"Idea"> | number
    createdAt?: DateTimeFilter<"Idea"> | Date | string
    updatedAt?: DateTimeFilter<"Idea"> | Date | string
  }

  export type ResearchReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ResearchReportWhereUniqueInput
    update: XOR<ResearchReportUpdateWithoutUserInput, ResearchReportUncheckedUpdateWithoutUserInput>
    create: XOR<ResearchReportCreateWithoutUserInput, ResearchReportUncheckedCreateWithoutUserInput>
  }

  export type ResearchReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ResearchReportWhereUniqueInput
    data: XOR<ResearchReportUpdateWithoutUserInput, ResearchReportUncheckedUpdateWithoutUserInput>
  }

  export type ResearchReportUpdateManyWithWhereWithoutUserInput = {
    where: ResearchReportScalarWhereInput
    data: XOR<ResearchReportUpdateManyMutationInput, ResearchReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ResearchReportScalarWhereInput = {
    AND?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
    OR?: ResearchReportScalarWhereInput[]
    NOT?: ResearchReportScalarWhereInput | ResearchReportScalarWhereInput[]
    id?: StringFilter<"ResearchReport"> | string
    ideaId?: StringFilter<"ResearchReport"> | string
    userId?: StringFilter<"ResearchReport"> | string
    reportData?: JsonFilter<"ResearchReport">
    summary?: StringNullableFilter<"ResearchReport"> | string | null
    basicAnalysis?: JsonNullableFilter<"ResearchReport">
    researchMethods?: JsonNullableFilter<"ResearchReport">
    dataSources?: JsonNullableFilter<"ResearchReport">
    mvpGuidance?: JsonNullableFilter<"ResearchReport">
    businessModel?: JsonNullableFilter<"ResearchReport">
    status?: EnumReportStatusFilter<"ResearchReport"> | $Enums.ReportStatus
    progress?: IntFilter<"ResearchReport"> | number
    creditsCost?: IntFilter<"ResearchReport"> | number
    createdAt?: DateTimeFilter<"ResearchReport"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ResearchReport"> | Date | string | null
  }

  export type CreditTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    update: XOR<CreditTransactionUpdateWithoutUserInput, CreditTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<CreditTransactionCreateWithoutUserInput, CreditTransactionUncheckedCreateWithoutUserInput>
  }

  export type CreditTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: CreditTransactionWhereUniqueInput
    data: XOR<CreditTransactionUpdateWithoutUserInput, CreditTransactionUncheckedUpdateWithoutUserInput>
  }

  export type CreditTransactionUpdateManyWithWhereWithoutUserInput = {
    where: CreditTransactionScalarWhereInput
    data: XOR<CreditTransactionUpdateManyMutationInput, CreditTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type CreditTransactionScalarWhereInput = {
    AND?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
    OR?: CreditTransactionScalarWhereInput[]
    NOT?: CreditTransactionScalarWhereInput | CreditTransactionScalarWhereInput[]
    id?: StringFilter<"CreditTransaction"> | string
    userId?: StringFilter<"CreditTransaction"> | string
    amount?: IntFilter<"CreditTransaction"> | number
    type?: EnumCreditTransactionTypeFilter<"CreditTransaction"> | $Enums.CreditTransactionType
    description?: StringNullableFilter<"CreditTransaction"> | string | null
    relatedId?: StringNullableFilter<"CreditTransaction"> | string | null
    balanceBefore?: IntFilter<"CreditTransaction"> | number
    balanceAfter?: IntFilter<"CreditTransaction"> | number
    createdAt?: DateTimeFilter<"CreditTransaction"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    outTradeNo?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    credits?: IntFilter<"Payment"> | number
    description?: StringFilter<"Payment"> | string
    currency?: StringFilter<"Payment"> | string
    provider?: StringFilter<"Payment"> | string
    providerOrderId?: StringNullableFilter<"Payment"> | string | null
    payUrl?: StringNullableFilter<"Payment"> | string | null
    qrCodeUrl?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    expiredAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type FileUpsertWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
    create: XOR<FileCreateWithoutUserInput, FileUncheckedCreateWithoutUserInput>
  }

  export type FileUpdateWithWhereUniqueWithoutUserInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutUserInput, FileUncheckedUpdateWithoutUserInput>
  }

  export type FileUpdateManyWithWhereWithoutUserInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutUserInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    userId?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    originalName?: StringFilter<"File"> | string
    key?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    contentType?: StringFilter<"File"> | string
    type?: StringFilter<"File"> | string
    status?: StringFilter<"File"> | string
    metadata?: JsonNullableFilter<"File">
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    deletedAt?: DateTimeNullableFilter<"File"> | Date | string | null
  }

  export type IdeaDiscussionUpsertWithWhereUniqueWithoutUserInput = {
    where: IdeaDiscussionWhereUniqueInput
    update: XOR<IdeaDiscussionUpdateWithoutUserInput, IdeaDiscussionUncheckedUpdateWithoutUserInput>
    create: XOR<IdeaDiscussionCreateWithoutUserInput, IdeaDiscussionUncheckedCreateWithoutUserInput>
  }

  export type IdeaDiscussionUpdateWithWhereUniqueWithoutUserInput = {
    where: IdeaDiscussionWhereUniqueInput
    data: XOR<IdeaDiscussionUpdateWithoutUserInput, IdeaDiscussionUncheckedUpdateWithoutUserInput>
  }

  export type IdeaDiscussionUpdateManyWithWhereWithoutUserInput = {
    where: IdeaDiscussionScalarWhereInput
    data: XOR<IdeaDiscussionUpdateManyMutationInput, IdeaDiscussionUncheckedUpdateManyWithoutUserInput>
  }

  export type IdeaDiscussionScalarWhereInput = {
    AND?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
    OR?: IdeaDiscussionScalarWhereInput[]
    NOT?: IdeaDiscussionScalarWhereInput | IdeaDiscussionScalarWhereInput[]
    id?: StringFilter<"IdeaDiscussion"> | string
    ideaId?: StringFilter<"IdeaDiscussion"> | string
    userId?: StringFilter<"IdeaDiscussion"> | string
    status?: EnumDiscussionStatusFilter<"IdeaDiscussion"> | $Enums.DiscussionStatus
    currentRound?: IntFilter<"IdeaDiscussion"> | number
    totalRounds?: IntFilter<"IdeaDiscussion"> | number
    aiAgentType?: StringFilter<"IdeaDiscussion"> | string
    aiAgentName?: StringFilter<"IdeaDiscussion"> | string
    createdAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    updatedAt?: DateTimeFilter<"IdeaDiscussion"> | Date | string
    completedAt?: DateTimeNullableFilter<"IdeaDiscussion"> | Date | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    amount?: FloatFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    description?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
  }

  export type CartItemUpsertWithWhereUniqueWithoutUserInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutUserInput, CartItemUncheckedUpdateWithoutUserInput>
    create: XOR<CartItemCreateWithoutUserInput, CartItemUncheckedCreateWithoutUserInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutUserInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutUserInput, CartItemUncheckedUpdateWithoutUserInput>
  }

  export type CartItemUpdateManyWithWhereWithoutUserInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutUserInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    userId?: StringFilter<"CartItem"> | string
    agentId?: StringFilter<"CartItem"> | string
    price?: FloatNullableFilter<"CartItem"> | number | null
    quantity?: IntFilter<"CartItem"> | number
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    updatedAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type BiddingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: BiddingSessionWhereUniqueInput
    update: XOR<BiddingSessionUpdateWithoutUserInput, BiddingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<BiddingSessionCreateWithoutUserInput, BiddingSessionUncheckedCreateWithoutUserInput>
  }

  export type BiddingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: BiddingSessionWhereUniqueInput
    data: XOR<BiddingSessionUpdateWithoutUserInput, BiddingSessionUncheckedUpdateWithoutUserInput>
  }

  export type BiddingSessionUpdateManyWithWhereWithoutUserInput = {
    where: BiddingSessionScalarWhereInput
    data: XOR<BiddingSessionUpdateManyMutationInput, BiddingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type BiddingSessionScalarWhereInput = {
    AND?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
    OR?: BiddingSessionScalarWhereInput[]
    NOT?: BiddingSessionScalarWhereInput | BiddingSessionScalarWhereInput[]
    id?: StringFilter<"BiddingSession"> | string
    ideaId?: StringFilter<"BiddingSession"> | string
    userId?: StringNullableFilter<"BiddingSession"> | string | null
    startPrice?: IntFilter<"BiddingSession"> | number
    currentHigh?: IntFilter<"BiddingSession"> | number
    winnerAgent?: StringNullableFilter<"BiddingSession"> | string | null
    winnerAgentType?: StringNullableFilter<"BiddingSession"> | string | null
    finalPrice?: IntNullableFilter<"BiddingSession"> | number | null
    status?: EnumBiddingStatusFilter<"BiddingSession"> | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFilter<"BiddingSession"> | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFilter<"BiddingSession"> | boolean
    discussionId?: StringNullableFilter<"BiddingSession"> | string | null
    enhancementScore?: FloatFilter<"BiddingSession"> | number
    participantCount?: IntFilter<"BiddingSession"> | number
    viewerCount?: IntFilter<"BiddingSession"> | number
    maxViewerCount?: IntFilter<"BiddingSession"> | number
    totalInteractions?: IntFilter<"BiddingSession"> | number
    durationSeconds?: IntFilter<"BiddingSession"> | number
    discussionDuration?: IntFilter<"BiddingSession"> | number
    biddingDuration?: IntFilter<"BiddingSession"> | number
    startedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    discussionStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    biddingStartedAt?: DateTimeNullableFilter<"BiddingSession"> | Date | string | null
    createdAt?: DateTimeFilter<"BiddingSession"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingSession"> | Date | string
    avgResponseTime?: FloatFilter<"BiddingSession"> | number
    aiServiceCost?: FloatFilter<"BiddingSession"> | number
    userEngagementScore?: FloatFilter<"BiddingSession"> | number
    contentQualityScore?: FloatFilter<"BiddingSession"> | number
  }

  export type PriceGuessUpsertWithWhereUniqueWithoutUserInput = {
    where: PriceGuessWhereUniqueInput
    update: XOR<PriceGuessUpdateWithoutUserInput, PriceGuessUncheckedUpdateWithoutUserInput>
    create: XOR<PriceGuessCreateWithoutUserInput, PriceGuessUncheckedCreateWithoutUserInput>
  }

  export type PriceGuessUpdateWithWhereUniqueWithoutUserInput = {
    where: PriceGuessWhereUniqueInput
    data: XOR<PriceGuessUpdateWithoutUserInput, PriceGuessUncheckedUpdateWithoutUserInput>
  }

  export type PriceGuessUpdateManyWithWhereWithoutUserInput = {
    where: PriceGuessScalarWhereInput
    data: XOR<PriceGuessUpdateManyMutationInput, PriceGuessUncheckedUpdateManyWithoutUserInput>
  }

  export type PriceGuessScalarWhereInput = {
    AND?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
    OR?: PriceGuessScalarWhereInput[]
    NOT?: PriceGuessScalarWhereInput | PriceGuessScalarWhereInput[]
    id?: StringFilter<"PriceGuess"> | string
    sessionId?: StringFilter<"PriceGuess"> | string
    userId?: StringFilter<"PriceGuess"> | string
    guessedPrice?: IntFilter<"PriceGuess"> | number
    confidence?: FloatFilter<"PriceGuess"> | number
    stakeAmount?: IntFilter<"PriceGuess"> | number
    actualPrice?: IntNullableFilter<"PriceGuess"> | number | null
    accuracy?: FloatNullableFilter<"PriceGuess"> | number | null
    reward?: IntNullableFilter<"PriceGuess"> | number | null
    basedOnDiscussion?: BoolFilter<"PriceGuess"> | boolean
    predictionConfidenceBonus?: FloatFilter<"PriceGuess"> | number
    timeSpentMs?: IntNullableFilter<"PriceGuess"> | number | null
    adjustmentCount?: IntFilter<"PriceGuess"> | number
    createdAt?: DateTimeFilter<"PriceGuess"> | Date | string
  }

  export type UserBiddingBehaviorUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    update: XOR<UserBiddingBehaviorUpdateWithoutUserInput, UserBiddingBehaviorUncheckedUpdateWithoutUserInput>
    create: XOR<UserBiddingBehaviorCreateWithoutUserInput, UserBiddingBehaviorUncheckedCreateWithoutUserInput>
  }

  export type UserBiddingBehaviorUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    data: XOR<UserBiddingBehaviorUpdateWithoutUserInput, UserBiddingBehaviorUncheckedUpdateWithoutUserInput>
  }

  export type UserBiddingBehaviorUpdateManyWithWhereWithoutUserInput = {
    where: UserBiddingBehaviorScalarWhereInput
    data: XOR<UserBiddingBehaviorUpdateManyMutationInput, UserBiddingBehaviorUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBiddingBehaviorScalarWhereInput = {
    AND?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
    OR?: UserBiddingBehaviorScalarWhereInput[]
    NOT?: UserBiddingBehaviorScalarWhereInput | UserBiddingBehaviorScalarWhereInput[]
    id?: StringFilter<"UserBiddingBehavior"> | string
    sessionId?: StringFilter<"UserBiddingBehavior"> | string
    userId?: StringFilter<"UserBiddingBehavior"> | string
    actionType?: EnumUserBiddingActionFilter<"UserBiddingBehavior"> | $Enums.UserBiddingAction
    actionData?: JsonNullableFilter<"UserBiddingBehavior">
    timestamp?: DateTimeFilter<"UserBiddingBehavior"> | Date | string
    phase?: StringNullableFilter<"UserBiddingBehavior"> | string | null
    agentName?: StringNullableFilter<"UserBiddingBehavior"> | string | null
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringFilter<"UserAchievement"> | string
    category?: StringFilter<"UserAchievement"> | string
    bonusPoints?: IntFilter<"UserAchievement"> | number
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progressData?: JsonNullableFilter<"UserAchievement">
    isRare?: BoolFilter<"UserAchievement"> | boolean
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutIdeasInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIdeasInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIdeasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
  }

  export type ResearchReportCreateWithoutIdeaInput = {
    id?: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutResearchReportsInput
  }

  export type ResearchReportUncheckedCreateWithoutIdeaInput = {
    id?: string
    userId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResearchReportCreateOrConnectWithoutIdeaInput = {
    where: ResearchReportWhereUniqueInput
    create: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput>
  }

  export type ResearchReportCreateManyIdeaInputEnvelope = {
    data: ResearchReportCreateManyIdeaInput | ResearchReportCreateManyIdeaInput[]
    skipDuplicates?: boolean
  }

  export type IdeaDiscussionCreateWithoutIdeaInput = {
    id?: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDiscussionsInput
    sessions?: BiddingSessionCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUncheckedCreateWithoutIdeaInput = {
    id?: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sessions?: BiddingSessionUncheckedCreateNestedManyWithoutDiscussionInput
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionCreateOrConnectWithoutIdeaInput = {
    where: IdeaDiscussionWhereUniqueInput
    create: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput>
  }

  export type IdeaDiscussionCreateManyIdeaInputEnvelope = {
    data: IdeaDiscussionCreateManyIdeaInput | IdeaDiscussionCreateManyIdeaInput[]
    skipDuplicates?: boolean
  }

  export type BiddingSessionCreateWithoutIdeaInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutIdeaInput = {
    id?: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutIdeaInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput>
  }

  export type BiddingSessionCreateManyIdeaInputEnvelope = {
    data: BiddingSessionCreateManyIdeaInput | BiddingSessionCreateManyIdeaInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIdeasInput = {
    update: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
    create: XOR<UserCreateWithoutIdeasInput, UserUncheckedCreateWithoutIdeasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIdeasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIdeasInput, UserUncheckedUpdateWithoutIdeasInput>
  }

  export type UserUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIdeasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResearchReportUpsertWithWhereUniqueWithoutIdeaInput = {
    where: ResearchReportWhereUniqueInput
    update: XOR<ResearchReportUpdateWithoutIdeaInput, ResearchReportUncheckedUpdateWithoutIdeaInput>
    create: XOR<ResearchReportCreateWithoutIdeaInput, ResearchReportUncheckedCreateWithoutIdeaInput>
  }

  export type ResearchReportUpdateWithWhereUniqueWithoutIdeaInput = {
    where: ResearchReportWhereUniqueInput
    data: XOR<ResearchReportUpdateWithoutIdeaInput, ResearchReportUncheckedUpdateWithoutIdeaInput>
  }

  export type ResearchReportUpdateManyWithWhereWithoutIdeaInput = {
    where: ResearchReportScalarWhereInput
    data: XOR<ResearchReportUpdateManyMutationInput, ResearchReportUncheckedUpdateManyWithoutIdeaInput>
  }

  export type IdeaDiscussionUpsertWithWhereUniqueWithoutIdeaInput = {
    where: IdeaDiscussionWhereUniqueInput
    update: XOR<IdeaDiscussionUpdateWithoutIdeaInput, IdeaDiscussionUncheckedUpdateWithoutIdeaInput>
    create: XOR<IdeaDiscussionCreateWithoutIdeaInput, IdeaDiscussionUncheckedCreateWithoutIdeaInput>
  }

  export type IdeaDiscussionUpdateWithWhereUniqueWithoutIdeaInput = {
    where: IdeaDiscussionWhereUniqueInput
    data: XOR<IdeaDiscussionUpdateWithoutIdeaInput, IdeaDiscussionUncheckedUpdateWithoutIdeaInput>
  }

  export type IdeaDiscussionUpdateManyWithWhereWithoutIdeaInput = {
    where: IdeaDiscussionScalarWhereInput
    data: XOR<IdeaDiscussionUpdateManyMutationInput, IdeaDiscussionUncheckedUpdateManyWithoutIdeaInput>
  }

  export type BiddingSessionUpsertWithWhereUniqueWithoutIdeaInput = {
    where: BiddingSessionWhereUniqueInput
    update: XOR<BiddingSessionUpdateWithoutIdeaInput, BiddingSessionUncheckedUpdateWithoutIdeaInput>
    create: XOR<BiddingSessionCreateWithoutIdeaInput, BiddingSessionUncheckedCreateWithoutIdeaInput>
  }

  export type BiddingSessionUpdateWithWhereUniqueWithoutIdeaInput = {
    where: BiddingSessionWhereUniqueInput
    data: XOR<BiddingSessionUpdateWithoutIdeaInput, BiddingSessionUncheckedUpdateWithoutIdeaInput>
  }

  export type BiddingSessionUpdateManyWithWhereWithoutIdeaInput = {
    where: BiddingSessionScalarWhereInput
    data: XOR<BiddingSessionUpdateManyMutationInput, BiddingSessionUncheckedUpdateManyWithoutIdeaInput>
  }

  export type IdeaCreateWithoutBiddingSessionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdeasInput
    researchReports?: ResearchReportCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutBiddingSessionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    userId: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutIdeaInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutBiddingSessionsInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutBiddingSessionsInput, IdeaUncheckedCreateWithoutBiddingSessionsInput>
  }

  export type UserCreateWithoutBiddingSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiddingSessionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiddingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiddingSessionsInput, UserUncheckedCreateWithoutBiddingSessionsInput>
  }

  export type IdeaDiscussionCreateWithoutSessionsInput = {
    id?: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutDiscussionsInput
    user: UserCreateNestedOneWithoutDiscussionsInput
    messages?: DiscussionMessageCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUncheckedCreateWithoutSessionsInput = {
    id?: string
    ideaId: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    messages?: DiscussionMessageUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionCreateOrConnectWithoutSessionsInput = {
    where: IdeaDiscussionWhereUniqueInput
    create: XOR<IdeaDiscussionCreateWithoutSessionsInput, IdeaDiscussionUncheckedCreateWithoutSessionsInput>
  }

  export type BidCreateWithoutSessionInput = {
    id?: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
  }

  export type BidUncheckedCreateWithoutSessionInput = {
    id?: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
  }

  export type BidCreateOrConnectWithoutSessionInput = {
    where: BidWhereUniqueInput
    create: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput>
  }

  export type BidCreateManySessionInputEnvelope = {
    data: BidCreateManySessionInput | BidCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type PriceGuessCreateWithoutSessionInput = {
    id?: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPriceGuessesInput
  }

  export type PriceGuessUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type PriceGuessCreateOrConnectWithoutSessionInput = {
    where: PriceGuessWhereUniqueInput
    create: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput>
  }

  export type PriceGuessCreateManySessionInputEnvelope = {
    data: PriceGuessCreateManySessionInput | PriceGuessCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AIInteractionCreateWithoutSessionInput = {
    id?: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
  }

  export type AIInteractionUncheckedCreateWithoutSessionInput = {
    id?: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
  }

  export type AIInteractionCreateOrConnectWithoutSessionInput = {
    where: AIInteractionWhereUniqueInput
    create: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput>
  }

  export type AIInteractionCreateManySessionInputEnvelope = {
    data: AIInteractionCreateManySessionInput | AIInteractionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserBiddingBehaviorCreateWithoutSessionInput = {
    id?: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
    user: UserCreateNestedOneWithoutBiddingBehaviorsInput
  }

  export type UserBiddingBehaviorUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type UserBiddingBehaviorCreateOrConnectWithoutSessionInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    create: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput>
  }

  export type UserBiddingBehaviorCreateManySessionInputEnvelope = {
    data: UserBiddingBehaviorCreateManySessionInput | UserBiddingBehaviorCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type IdeaUpsertWithoutBiddingSessionsInput = {
    update: XOR<IdeaUpdateWithoutBiddingSessionsInput, IdeaUncheckedUpdateWithoutBiddingSessionsInput>
    create: XOR<IdeaCreateWithoutBiddingSessionsInput, IdeaUncheckedCreateWithoutBiddingSessionsInput>
    where?: IdeaWhereInput
  }

  export type IdeaUpdateToOneWithWhereWithoutBiddingSessionsInput = {
    where?: IdeaWhereInput
    data: XOR<IdeaUpdateWithoutBiddingSessionsInput, IdeaUncheckedUpdateWithoutBiddingSessionsInput>
  }

  export type IdeaUpdateWithoutBiddingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdeasNestedInput
    researchReports?: ResearchReportUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutBiddingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    researchReports?: ResearchReportUncheckedUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutIdeaNestedInput
  }

  export type UserUpsertWithoutBiddingSessionsInput = {
    update: XOR<UserUpdateWithoutBiddingSessionsInput, UserUncheckedUpdateWithoutBiddingSessionsInput>
    create: XOR<UserCreateWithoutBiddingSessionsInput, UserUncheckedCreateWithoutBiddingSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiddingSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiddingSessionsInput, UserUncheckedUpdateWithoutBiddingSessionsInput>
  }

  export type UserUpdateWithoutBiddingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiddingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IdeaDiscussionUpsertWithoutSessionsInput = {
    update: XOR<IdeaDiscussionUpdateWithoutSessionsInput, IdeaDiscussionUncheckedUpdateWithoutSessionsInput>
    create: XOR<IdeaDiscussionCreateWithoutSessionsInput, IdeaDiscussionUncheckedCreateWithoutSessionsInput>
    where?: IdeaDiscussionWhereInput
  }

  export type IdeaDiscussionUpdateToOneWithWhereWithoutSessionsInput = {
    where?: IdeaDiscussionWhereInput
    data: XOR<IdeaDiscussionUpdateWithoutSessionsInput, IdeaDiscussionUncheckedUpdateWithoutSessionsInput>
  }

  export type IdeaDiscussionUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutDiscussionsNestedInput
    user?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type BidUpsertWithWhereUniqueWithoutSessionInput = {
    where: BidWhereUniqueInput
    update: XOR<BidUpdateWithoutSessionInput, BidUncheckedUpdateWithoutSessionInput>
    create: XOR<BidCreateWithoutSessionInput, BidUncheckedCreateWithoutSessionInput>
  }

  export type BidUpdateWithWhereUniqueWithoutSessionInput = {
    where: BidWhereUniqueInput
    data: XOR<BidUpdateWithoutSessionInput, BidUncheckedUpdateWithoutSessionInput>
  }

  export type BidUpdateManyWithWhereWithoutSessionInput = {
    where: BidScalarWhereInput
    data: XOR<BidUpdateManyMutationInput, BidUncheckedUpdateManyWithoutSessionInput>
  }

  export type BidScalarWhereInput = {
    AND?: BidScalarWhereInput | BidScalarWhereInput[]
    OR?: BidScalarWhereInput[]
    NOT?: BidScalarWhereInput | BidScalarWhereInput[]
    id?: StringFilter<"Bid"> | string
    sessionId?: StringFilter<"Bid"> | string
    agentName?: StringFilter<"Bid"> | string
    agentType?: StringFilter<"Bid"> | string
    amount?: IntFilter<"Bid"> | number
    comment?: StringNullableFilter<"Bid"> | string | null
    confidence?: FloatNullableFilter<"Bid"> | number | null
    analysisData?: JsonNullableFilter<"Bid">
    reasoning?: StringNullableFilter<"Bid"> | string | null
    emotionalState?: StringFilter<"Bid"> | string
    isScripted?: BoolFilter<"Bid"> | boolean
    aiServiceUsed?: StringNullableFilter<"Bid"> | string | null
    generationCost?: FloatFilter<"Bid"> | number
    responseTimeMs?: IntFilter<"Bid"> | number
    qualityScore?: FloatFilter<"Bid"> | number
    understandingDepth?: FloatFilter<"Bid"> | number
    contextRichness?: FloatFilter<"Bid"> | number
    createdAt?: DateTimeFilter<"Bid"> | Date | string
  }

  export type PriceGuessUpsertWithWhereUniqueWithoutSessionInput = {
    where: PriceGuessWhereUniqueInput
    update: XOR<PriceGuessUpdateWithoutSessionInput, PriceGuessUncheckedUpdateWithoutSessionInput>
    create: XOR<PriceGuessCreateWithoutSessionInput, PriceGuessUncheckedCreateWithoutSessionInput>
  }

  export type PriceGuessUpdateWithWhereUniqueWithoutSessionInput = {
    where: PriceGuessWhereUniqueInput
    data: XOR<PriceGuessUpdateWithoutSessionInput, PriceGuessUncheckedUpdateWithoutSessionInput>
  }

  export type PriceGuessUpdateManyWithWhereWithoutSessionInput = {
    where: PriceGuessScalarWhereInput
    data: XOR<PriceGuessUpdateManyMutationInput, PriceGuessUncheckedUpdateManyWithoutSessionInput>
  }

  export type AIInteractionUpsertWithWhereUniqueWithoutSessionInput = {
    where: AIInteractionWhereUniqueInput
    update: XOR<AIInteractionUpdateWithoutSessionInput, AIInteractionUncheckedUpdateWithoutSessionInput>
    create: XOR<AIInteractionCreateWithoutSessionInput, AIInteractionUncheckedCreateWithoutSessionInput>
  }

  export type AIInteractionUpdateWithWhereUniqueWithoutSessionInput = {
    where: AIInteractionWhereUniqueInput
    data: XOR<AIInteractionUpdateWithoutSessionInput, AIInteractionUncheckedUpdateWithoutSessionInput>
  }

  export type AIInteractionUpdateManyWithWhereWithoutSessionInput = {
    where: AIInteractionScalarWhereInput
    data: XOR<AIInteractionUpdateManyMutationInput, AIInteractionUncheckedUpdateManyWithoutSessionInput>
  }

  export type AIInteractionScalarWhereInput = {
    AND?: AIInteractionScalarWhereInput | AIInteractionScalarWhereInput[]
    OR?: AIInteractionScalarWhereInput[]
    NOT?: AIInteractionScalarWhereInput | AIInteractionScalarWhereInput[]
    id?: StringFilter<"AIInteraction"> | string
    sessionId?: StringFilter<"AIInteraction"> | string
    agentName?: StringFilter<"AIInteraction"> | string
    agentType?: StringFilter<"AIInteraction"> | string
    interactionType?: EnumAIInteractionTypeFilter<"AIInteraction"> | $Enums.AIInteractionType
    phase?: StringFilter<"AIInteraction"> | string
    content?: StringFilter<"AIInteraction"> | string
    emotion?: StringFilter<"AIInteraction"> | string
    animation?: StringFilter<"AIInteraction"> | string
    isScripted?: BoolFilter<"AIInteraction"> | boolean
    aiServiceUsed?: StringNullableFilter<"AIInteraction"> | string | null
    generationCost?: FloatFilter<"AIInteraction"> | number
    responseTimeMs?: IntFilter<"AIInteraction"> | number
    qualityScore?: FloatFilter<"AIInteraction"> | number
    userReactions?: JsonFilter<"AIInteraction">
    engagementScore?: FloatFilter<"AIInteraction"> | number
    isRandomEvent?: BoolFilter<"AIInteraction"> | boolean
    eventType?: StringNullableFilter<"AIInteraction"> | string | null
    createdAt?: DateTimeFilter<"AIInteraction"> | Date | string
  }

  export type UserBiddingBehaviorUpsertWithWhereUniqueWithoutSessionInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    update: XOR<UserBiddingBehaviorUpdateWithoutSessionInput, UserBiddingBehaviorUncheckedUpdateWithoutSessionInput>
    create: XOR<UserBiddingBehaviorCreateWithoutSessionInput, UserBiddingBehaviorUncheckedCreateWithoutSessionInput>
  }

  export type UserBiddingBehaviorUpdateWithWhereUniqueWithoutSessionInput = {
    where: UserBiddingBehaviorWhereUniqueInput
    data: XOR<UserBiddingBehaviorUpdateWithoutSessionInput, UserBiddingBehaviorUncheckedUpdateWithoutSessionInput>
  }

  export type UserBiddingBehaviorUpdateManyWithWhereWithoutSessionInput = {
    where: UserBiddingBehaviorScalarWhereInput
    data: XOR<UserBiddingBehaviorUpdateManyMutationInput, UserBiddingBehaviorUncheckedUpdateManyWithoutSessionInput>
  }

  export type BiddingSessionCreateWithoutBidsInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutBidsInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutBidsInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutBidsInput, BiddingSessionUncheckedCreateWithoutBidsInput>
  }

  export type BiddingSessionUpsertWithoutBidsInput = {
    update: XOR<BiddingSessionUpdateWithoutBidsInput, BiddingSessionUncheckedUpdateWithoutBidsInput>
    create: XOR<BiddingSessionCreateWithoutBidsInput, BiddingSessionUncheckedCreateWithoutBidsInput>
    where?: BiddingSessionWhereInput
  }

  export type BiddingSessionUpdateToOneWithWhereWithoutBidsInput = {
    where?: BiddingSessionWhereInput
    data: XOR<BiddingSessionUpdateWithoutBidsInput, BiddingSessionUncheckedUpdateWithoutBidsInput>
  }

  export type BiddingSessionUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionCreateWithoutPriceGuessesInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutPriceGuessesInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutPriceGuessesInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutPriceGuessesInput, BiddingSessionUncheckedCreateWithoutPriceGuessesInput>
  }

  export type UserCreateWithoutPriceGuessesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPriceGuessesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPriceGuessesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPriceGuessesInput, UserUncheckedCreateWithoutPriceGuessesInput>
  }

  export type BiddingSessionUpsertWithoutPriceGuessesInput = {
    update: XOR<BiddingSessionUpdateWithoutPriceGuessesInput, BiddingSessionUncheckedUpdateWithoutPriceGuessesInput>
    create: XOR<BiddingSessionCreateWithoutPriceGuessesInput, BiddingSessionUncheckedCreateWithoutPriceGuessesInput>
    where?: BiddingSessionWhereInput
  }

  export type BiddingSessionUpdateToOneWithWhereWithoutPriceGuessesInput = {
    where?: BiddingSessionWhereInput
    data: XOR<BiddingSessionUpdateWithoutPriceGuessesInput, BiddingSessionUncheckedUpdateWithoutPriceGuessesInput>
  }

  export type BiddingSessionUpdateWithoutPriceGuessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutPriceGuessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutPriceGuessesInput = {
    update: XOR<UserUpdateWithoutPriceGuessesInput, UserUncheckedUpdateWithoutPriceGuessesInput>
    create: XOR<UserCreateWithoutPriceGuessesInput, UserUncheckedCreateWithoutPriceGuessesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPriceGuessesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPriceGuessesInput, UserUncheckedUpdateWithoutPriceGuessesInput>
  }

  export type UserUpdateWithoutPriceGuessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPriceGuessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiddingSessionCreateWithoutInteractionsInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutInteractionsInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutInteractionsInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutInteractionsInput, BiddingSessionUncheckedCreateWithoutInteractionsInput>
  }

  export type BiddingSessionUpsertWithoutInteractionsInput = {
    update: XOR<BiddingSessionUpdateWithoutInteractionsInput, BiddingSessionUncheckedUpdateWithoutInteractionsInput>
    create: XOR<BiddingSessionCreateWithoutInteractionsInput, BiddingSessionUncheckedCreateWithoutInteractionsInput>
    where?: BiddingSessionWhereInput
  }

  export type BiddingSessionUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: BiddingSessionWhereInput
    data: XOR<BiddingSessionUpdateWithoutInteractionsInput, BiddingSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type BiddingSessionUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionCreateWithoutBehaviorsInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    discussion?: IdeaDiscussionCreateNestedOneWithoutSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutBehaviorsInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutBehaviorsInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutBehaviorsInput, BiddingSessionUncheckedCreateWithoutBehaviorsInput>
  }

  export type UserCreateWithoutBiddingBehaviorsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiddingBehaviorsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiddingBehaviorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiddingBehaviorsInput, UserUncheckedCreateWithoutBiddingBehaviorsInput>
  }

  export type BiddingSessionUpsertWithoutBehaviorsInput = {
    update: XOR<BiddingSessionUpdateWithoutBehaviorsInput, BiddingSessionUncheckedUpdateWithoutBehaviorsInput>
    create: XOR<BiddingSessionCreateWithoutBehaviorsInput, BiddingSessionUncheckedCreateWithoutBehaviorsInput>
    where?: BiddingSessionWhereInput
  }

  export type BiddingSessionUpdateToOneWithWhereWithoutBehaviorsInput = {
    where?: BiddingSessionWhereInput
    data: XOR<BiddingSessionUpdateWithoutBehaviorsInput, BiddingSessionUncheckedUpdateWithoutBehaviorsInput>
  }

  export type BiddingSessionUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutBiddingBehaviorsInput = {
    update: XOR<UserUpdateWithoutBiddingBehaviorsInput, UserUncheckedUpdateWithoutBiddingBehaviorsInput>
    create: XOR<UserCreateWithoutBiddingBehaviorsInput, UserUncheckedCreateWithoutBiddingBehaviorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiddingBehaviorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiddingBehaviorsInput, UserUncheckedUpdateWithoutBiddingBehaviorsInput>
  }

  export type UserUpdateWithoutBiddingBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiddingBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IdeaCreateWithoutResearchReportsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdeasInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutResearchReportsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    userId: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutResearchReportsInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutResearchReportsInput, IdeaUncheckedCreateWithoutResearchReportsInput>
  }

  export type UserCreateWithoutResearchReportsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResearchReportsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResearchReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResearchReportsInput, UserUncheckedCreateWithoutResearchReportsInput>
  }

  export type IdeaUpsertWithoutResearchReportsInput = {
    update: XOR<IdeaUpdateWithoutResearchReportsInput, IdeaUncheckedUpdateWithoutResearchReportsInput>
    create: XOR<IdeaCreateWithoutResearchReportsInput, IdeaUncheckedCreateWithoutResearchReportsInput>
    where?: IdeaWhereInput
  }

  export type IdeaUpdateToOneWithWhereWithoutResearchReportsInput = {
    where?: IdeaWhereInput
    data: XOR<IdeaUpdateWithoutResearchReportsInput, IdeaUncheckedUpdateWithoutResearchReportsInput>
  }

  export type IdeaUpdateWithoutResearchReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdeasNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutResearchReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutIdeaNestedInput
  }

  export type UserUpsertWithoutResearchReportsInput = {
    update: XOR<UserUpdateWithoutResearchReportsInput, UserUncheckedUpdateWithoutResearchReportsInput>
    create: XOR<UserCreateWithoutResearchReportsInput, UserUncheckedCreateWithoutResearchReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResearchReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResearchReportsInput, UserUncheckedUpdateWithoutResearchReportsInput>
  }

  export type UserUpdateWithoutResearchReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResearchReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreditTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditTransactionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
  }

  export type UserUpsertWithoutCreditTransactionsInput = {
    update: XOR<UserUpdateWithoutCreditTransactionsInput, UserUncheckedUpdateWithoutCreditTransactionsInput>
    create: XOR<UserCreateWithoutCreditTransactionsInput, UserUncheckedCreateWithoutCreditTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreditTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreditTransactionsInput, UserUncheckedUpdateWithoutCreditTransactionsInput>
  }

  export type UserUpdateWithoutCreditTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreditTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type RefundCreateWithoutPaymentInput = {
    id?: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    outRefundNo?: StringFilter<"Refund"> | string
    refundAmount?: FloatFilter<"Refund"> | number
    reason?: StringFilter<"Refund"> | string
    status?: StringFilter<"Refund"> | string
    providerRefundId?: StringNullableFilter<"Refund"> | string | null
    operatorId?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    refundedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
  }

  export type PaymentCreateWithoutRefundsInput = {
    id?: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: string
    userId: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFilesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFilesInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
  }

  export type UserUpsertWithoutFilesInput = {
    update: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IdeaCreateWithoutDiscussionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutIdeasInput
    researchReports?: ResearchReportCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutIdeaInput
  }

  export type IdeaUncheckedCreateWithoutDiscussionsInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    userId: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutIdeaInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutIdeaInput
  }

  export type IdeaCreateOrConnectWithoutDiscussionsInput = {
    where: IdeaWhereUniqueInput
    create: XOR<IdeaCreateWithoutDiscussionsInput, IdeaUncheckedCreateWithoutDiscussionsInput>
  }

  export type UserCreateWithoutDiscussionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDiscussionsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDiscussionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
  }

  export type BiddingSessionCreateWithoutDiscussionInput = {
    id?: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    idea: IdeaCreateNestedOneWithoutBiddingSessionsInput
    user?: UserCreateNestedOneWithoutBiddingSessionsInput
    bids?: BidCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionUncheckedCreateWithoutDiscussionInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
    bids?: BidUncheckedCreateNestedManyWithoutSessionInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutSessionInput
    interactions?: AIInteractionUncheckedCreateNestedManyWithoutSessionInput
    behaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutSessionInput
  }

  export type BiddingSessionCreateOrConnectWithoutDiscussionInput = {
    where: BiddingSessionWhereUniqueInput
    create: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput>
  }

  export type BiddingSessionCreateManyDiscussionInputEnvelope = {
    data: BiddingSessionCreateManyDiscussionInput | BiddingSessionCreateManyDiscussionInput[]
    skipDuplicates?: boolean
  }

  export type DiscussionMessageCreateWithoutDiscussionInput = {
    id?: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DiscussionMessageUncheckedCreateWithoutDiscussionInput = {
    id?: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DiscussionMessageCreateOrConnectWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    create: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput>
  }

  export type DiscussionMessageCreateManyDiscussionInputEnvelope = {
    data: DiscussionMessageCreateManyDiscussionInput | DiscussionMessageCreateManyDiscussionInput[]
    skipDuplicates?: boolean
  }

  export type IdeaUpsertWithoutDiscussionsInput = {
    update: XOR<IdeaUpdateWithoutDiscussionsInput, IdeaUncheckedUpdateWithoutDiscussionsInput>
    create: XOR<IdeaCreateWithoutDiscussionsInput, IdeaUncheckedCreateWithoutDiscussionsInput>
    where?: IdeaWhereInput
  }

  export type IdeaUpdateToOneWithWhereWithoutDiscussionsInput = {
    where?: IdeaWhereInput
    data: XOR<IdeaUpdateWithoutDiscussionsInput, IdeaUncheckedUpdateWithoutDiscussionsInput>
  }

  export type IdeaUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutIdeasNestedInput
    researchReports?: ResearchReportUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    researchReports?: ResearchReportUncheckedUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutIdeaNestedInput
  }

  export type UserUpsertWithoutDiscussionsInput = {
    update: XOR<UserUpdateWithoutDiscussionsInput, UserUncheckedUpdateWithoutDiscussionsInput>
    create: XOR<UserCreateWithoutDiscussionsInput, UserUncheckedCreateWithoutDiscussionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDiscussionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDiscussionsInput, UserUncheckedUpdateWithoutDiscussionsInput>
  }

  export type UserUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiddingSessionUpsertWithWhereUniqueWithoutDiscussionInput = {
    where: BiddingSessionWhereUniqueInput
    update: XOR<BiddingSessionUpdateWithoutDiscussionInput, BiddingSessionUncheckedUpdateWithoutDiscussionInput>
    create: XOR<BiddingSessionCreateWithoutDiscussionInput, BiddingSessionUncheckedCreateWithoutDiscussionInput>
  }

  export type BiddingSessionUpdateWithWhereUniqueWithoutDiscussionInput = {
    where: BiddingSessionWhereUniqueInput
    data: XOR<BiddingSessionUpdateWithoutDiscussionInput, BiddingSessionUncheckedUpdateWithoutDiscussionInput>
  }

  export type BiddingSessionUpdateManyWithWhereWithoutDiscussionInput = {
    where: BiddingSessionScalarWhereInput
    data: XOR<BiddingSessionUpdateManyMutationInput, BiddingSessionUncheckedUpdateManyWithoutDiscussionInput>
  }

  export type DiscussionMessageUpsertWithWhereUniqueWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    update: XOR<DiscussionMessageUpdateWithoutDiscussionInput, DiscussionMessageUncheckedUpdateWithoutDiscussionInput>
    create: XOR<DiscussionMessageCreateWithoutDiscussionInput, DiscussionMessageUncheckedCreateWithoutDiscussionInput>
  }

  export type DiscussionMessageUpdateWithWhereUniqueWithoutDiscussionInput = {
    where: DiscussionMessageWhereUniqueInput
    data: XOR<DiscussionMessageUpdateWithoutDiscussionInput, DiscussionMessageUncheckedUpdateWithoutDiscussionInput>
  }

  export type DiscussionMessageUpdateManyWithWhereWithoutDiscussionInput = {
    where: DiscussionMessageScalarWhereInput
    data: XOR<DiscussionMessageUpdateManyMutationInput, DiscussionMessageUncheckedUpdateManyWithoutDiscussionInput>
  }

  export type DiscussionMessageScalarWhereInput = {
    AND?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
    OR?: DiscussionMessageScalarWhereInput[]
    NOT?: DiscussionMessageScalarWhereInput | DiscussionMessageScalarWhereInput[]
    id?: StringFilter<"DiscussionMessage"> | string
    discussionId?: StringFilter<"DiscussionMessage"> | string
    content?: StringFilter<"DiscussionMessage"> | string
    messageType?: EnumMessageTypeFilter<"DiscussionMessage"> | $Enums.MessageType
    roundNumber?: IntFilter<"DiscussionMessage"> | number
    senderType?: EnumSenderTypeFilter<"DiscussionMessage"> | $Enums.SenderType
    senderName?: StringNullableFilter<"DiscussionMessage"> | string | null
    analysisData?: JsonNullableFilter<"DiscussionMessage">
    suggestions?: JsonNullableFilter<"DiscussionMessage">
    createdAt?: DateTimeFilter<"DiscussionMessage"> | Date | string
  }

  export type IdeaDiscussionCreateWithoutMessagesInput = {
    id?: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    idea: IdeaCreateNestedOneWithoutDiscussionsInput
    user: UserCreateNestedOneWithoutDiscussionsInput
    sessions?: BiddingSessionCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionUncheckedCreateWithoutMessagesInput = {
    id?: string
    ideaId: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
    sessions?: BiddingSessionUncheckedCreateNestedManyWithoutDiscussionInput
  }

  export type IdeaDiscussionCreateOrConnectWithoutMessagesInput = {
    where: IdeaDiscussionWhereUniqueInput
    create: XOR<IdeaDiscussionCreateWithoutMessagesInput, IdeaDiscussionUncheckedCreateWithoutMessagesInput>
  }

  export type IdeaDiscussionUpsertWithoutMessagesInput = {
    update: XOR<IdeaDiscussionUpdateWithoutMessagesInput, IdeaDiscussionUncheckedUpdateWithoutMessagesInput>
    create: XOR<IdeaDiscussionCreateWithoutMessagesInput, IdeaDiscussionUncheckedCreateWithoutMessagesInput>
    where?: IdeaDiscussionWhereInput
  }

  export type IdeaDiscussionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: IdeaDiscussionWhereInput
    data: XOR<IdeaDiscussionUpdateWithoutMessagesInput, IdeaDiscussionUncheckedUpdateWithoutMessagesInput>
  }

  export type IdeaDiscussionUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutDiscussionsNestedInput
    user?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    sessions?: BiddingSessionUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: BiddingSessionUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    cartItems?: CartItemCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCartItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartItemsInput = {
    id?: string
    email: string
    username: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    phone?: string | null
    avatar?: string | null
    bio?: string | null
    status?: $Enums.UserStatus
    role?: $Enums.UserRole
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    credits?: number
    level?: $Enums.UserLevel
    totalSpent?: number
    totalEarned?: number
    totalGuesses?: number
    guessAccuracy?: number
    guessEarnings?: number
    guessLevel?: number
    levelProgress?: number
    consecutiveGuesses?: number
    bestStreak?: number
    favoriteAgent?: string | null
    emailNotifications?: boolean
    marketingEmails?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    ideas?: IdeaUncheckedCreateNestedManyWithoutUserInput
    researchReports?: ResearchReportUncheckedCreateNestedManyWithoutUserInput
    creditTransactions?: CreditTransactionUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutUserInput
    discussions?: IdeaDiscussionUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    biddingSessions?: BiddingSessionUncheckedCreateNestedManyWithoutUserInput
    priceGuesses?: PriceGuessUncheckedCreateNestedManyWithoutUserInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartItemsInput, UserUncheckedCreateWithoutCartItemsInput>
  }

  export type UserUpsertWithoutCartItemsInput = {
    update: XOR<UserUpdateWithoutCartItemsInput, UserUncheckedUpdateWithoutCartItemsInput>
    create: XOR<UserCreateWithoutCartItemsInput, UserUncheckedCreateWithoutCartItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartItemsInput, UserUncheckedUpdateWithoutCartItemsInput>
  }

  export type UserUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    credits?: IntFieldUpdateOperationsInput | number
    level?: EnumUserLevelFieldUpdateOperationsInput | $Enums.UserLevel
    totalSpent?: IntFieldUpdateOperationsInput | number
    totalEarned?: IntFieldUpdateOperationsInput | number
    totalGuesses?: IntFieldUpdateOperationsInput | number
    guessAccuracy?: FloatFieldUpdateOperationsInput | number
    guessEarnings?: IntFieldUpdateOperationsInput | number
    guessLevel?: IntFieldUpdateOperationsInput | number
    levelProgress?: FloatFieldUpdateOperationsInput | number
    consecutiveGuesses?: IntFieldUpdateOperationsInput | number
    bestStreak?: IntFieldUpdateOperationsInput | number
    favoriteAgent?: NullableStringFieldUpdateOperationsInput | string | null
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    marketingEmails?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ideas?: IdeaUncheckedUpdateManyWithoutUserNestedInput
    researchReports?: ResearchReportUncheckedUpdateManyWithoutUserNestedInput
    creditTransactions?: CreditTransactionUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutUserNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutUserNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutUserNestedInput
    biddingBehaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
  }

  export type IdeaCreateManyUserInput = {
    id?: string
    title: string
    description: string
    category: $Enums.IdeaCategory
    tags?: string
    isAnonymous?: boolean
    status?: $Enums.IdeaStatus
    visibility?: $Enums.IdeaVisibility
    viewCount?: number
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchReportCreateManyUserInput = {
    id?: string
    ideaId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type CreditTransactionCreateManyUserInput = {
    id?: string
    amount: number
    type: $Enums.CreditTransactionType
    description?: string | null
    relatedId?: string | null
    balanceBefore: number
    balanceAfter: number
    createdAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    outTradeNo: string
    amount: number
    credits: number
    description: string
    currency?: string
    provider: string
    providerOrderId?: string | null
    payUrl?: string | null
    qrCodeUrl?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
    expiredAt: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type FileCreateManyUserInput = {
    id?: string
    filename: string
    originalName: string
    key: string
    url: string
    size: number
    contentType: string
    type?: string
    status?: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type IdeaDiscussionCreateManyUserInput = {
    id?: string
    ideaId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type OrderCreateManyUserInput = {
    id?: string
    amount: number
    currency?: string
    description: string
    status?: $Enums.OrderStatus
    paymentMethod?: string | null
    paymentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type CartItemCreateManyUserInput = {
    id?: string
    agentId: string
    price?: number | null
    quantity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingSessionCreateManyUserInput = {
    id?: string
    ideaId: string
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
  }

  export type PriceGuessCreateManyUserInput = {
    id?: string
    sessionId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type UserBiddingBehaviorCreateManyUserInput = {
    id?: string
    sessionId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    achievementName: string
    description: string
    category: string
    bonusPoints: number
    earnedAt?: Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: boolean
  }

  export type IdeaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    researchReports?: ResearchReportUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    researchReports?: ResearchReportUncheckedUpdateManyWithoutIdeaNestedInput
    discussions?: IdeaDiscussionUncheckedUpdateManyWithoutIdeaNestedInput
    biddingSessions?: BiddingSessionUncheckedUpdateManyWithoutIdeaNestedInput
  }

  export type IdeaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumIdeaCategoryFieldUpdateOperationsInput | $Enums.IdeaCategory
    tags?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumIdeaStatusFieldUpdateOperationsInput | $Enums.IdeaStatus
    visibility?: EnumIdeaVisibilityFieldUpdateOperationsInput | $Enums.IdeaVisibility
    viewCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutResearchReportsNestedInput
  }

  export type ResearchReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CreditTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    type?: EnumCreditTransactionTypeFieldUpdateOperationsInput | $Enums.CreditTransactionType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    balanceBefore?: IntFieldUpdateOperationsInput | number
    balanceAfter?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    outTradeNo?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    payUrl?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    contentType?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IdeaDiscussionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idea?: IdeaUpdateOneRequiredWithoutDiscussionsNestedInput
    sessions?: BiddingSessionUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: BiddingSessionUncheckedUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartItemUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type PriceGuessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: BiddingSessionUpdateOneRequiredWithoutPriceGuessesNestedInput
  }

  export type PriceGuessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBiddingBehaviorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    session?: BiddingSessionUpdateOneRequiredWithoutBehaviorsNestedInput
  }

  export type UserBiddingBehaviorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBiddingBehaviorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    bonusPoints?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressData?: NullableJsonNullValueInput | InputJsonValue
    isRare?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ResearchReportCreateManyIdeaInput = {
    id?: string
    userId: string
    reportData: JsonNullValueInput | InputJsonValue
    summary?: string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ReportStatus
    progress?: number
    creditsCost: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type IdeaDiscussionCreateManyIdeaInput = {
    id?: string
    userId: string
    status?: $Enums.DiscussionStatus
    currentRound?: number
    totalRounds?: number
    aiAgentType: string
    aiAgentName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type BiddingSessionCreateManyIdeaInput = {
    id?: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    discussionId?: string | null
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
  }

  export type ResearchReportUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutResearchReportsNestedInput
  }

  export type ResearchReportUncheckedUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResearchReportUncheckedUpdateManyWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportData?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    basicAnalysis?: NullableJsonNullValueInput | InputJsonValue
    researchMethods?: NullableJsonNullValueInput | InputJsonValue
    dataSources?: NullableJsonNullValueInput | InputJsonValue
    mvpGuidance?: NullableJsonNullValueInput | InputJsonValue
    businessModel?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    progress?: IntFieldUpdateOperationsInput | number
    creditsCost?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IdeaDiscussionUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDiscussionsNestedInput
    sessions?: BiddingSessionUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: BiddingSessionUncheckedUpdateManyWithoutDiscussionNestedInput
    messages?: DiscussionMessageUncheckedUpdateManyWithoutDiscussionNestedInput
  }

  export type IdeaDiscussionUncheckedUpdateManyWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumDiscussionStatusFieldUpdateOperationsInput | $Enums.DiscussionStatus
    currentRound?: IntFieldUpdateOperationsInput | number
    totalRounds?: IntFieldUpdateOperationsInput | number
    aiAgentType?: StringFieldUpdateOperationsInput | string
    aiAgentName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BiddingSessionUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    discussion?: IdeaDiscussionUpdateOneWithoutSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateManyWithoutIdeaInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    discussionId?: NullableStringFieldUpdateOperationsInput | string | null
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type BidCreateManySessionInput = {
    id?: string
    agentName: string
    agentType: string
    amount: number
    comment?: string | null
    confidence?: number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: string | null
    emotionalState?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    understandingDepth?: number
    contextRichness?: number
    createdAt?: Date | string
  }

  export type PriceGuessCreateManySessionInput = {
    id?: string
    userId: string
    guessedPrice: number
    confidence: number
    stakeAmount?: number
    actualPrice?: number | null
    accuracy?: number | null
    reward?: number | null
    basedOnDiscussion?: boolean
    predictionConfidenceBonus?: number
    timeSpentMs?: number | null
    adjustmentCount?: number
    createdAt?: Date | string
  }

  export type AIInteractionCreateManySessionInput = {
    id?: string
    agentName: string
    agentType: string
    interactionType: $Enums.AIInteractionType
    phase: string
    content: string
    emotion?: string
    animation?: string
    isScripted?: boolean
    aiServiceUsed?: string | null
    generationCost?: number
    responseTimeMs?: number
    qualityScore?: number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: number
    isRandomEvent?: boolean
    eventType?: string | null
    createdAt?: Date | string
  }

  export type UserBiddingBehaviorCreateManySessionInput = {
    id?: string
    userId: string
    actionType: $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    phase?: string | null
    agentName?: string | null
  }

  export type BidUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BidUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    reasoning?: NullableStringFieldUpdateOperationsInput | string | null
    emotionalState?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    understandingDepth?: FloatFieldUpdateOperationsInput | number
    contextRichness?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPriceGuessesNestedInput
  }

  export type PriceGuessUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceGuessUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    guessedPrice?: IntFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    stakeAmount?: IntFieldUpdateOperationsInput | number
    actualPrice?: NullableIntFieldUpdateOperationsInput | number | null
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    reward?: NullableIntFieldUpdateOperationsInput | number | null
    basedOnDiscussion?: BoolFieldUpdateOperationsInput | boolean
    predictionConfidenceBonus?: FloatFieldUpdateOperationsInput | number
    timeSpentMs?: NullableIntFieldUpdateOperationsInput | number | null
    adjustmentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIInteractionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    agentType?: StringFieldUpdateOperationsInput | string
    interactionType?: EnumAIInteractionTypeFieldUpdateOperationsInput | $Enums.AIInteractionType
    phase?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    emotion?: StringFieldUpdateOperationsInput | string
    animation?: StringFieldUpdateOperationsInput | string
    isScripted?: BoolFieldUpdateOperationsInput | boolean
    aiServiceUsed?: NullableStringFieldUpdateOperationsInput | string | null
    generationCost?: FloatFieldUpdateOperationsInput | number
    responseTimeMs?: IntFieldUpdateOperationsInput | number
    qualityScore?: FloatFieldUpdateOperationsInput | number
    userReactions?: JsonNullValueInput | InputJsonValue
    engagementScore?: FloatFieldUpdateOperationsInput | number
    isRandomEvent?: BoolFieldUpdateOperationsInput | boolean
    eventType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBiddingBehaviorUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutBiddingBehaviorsNestedInput
  }

  export type UserBiddingBehaviorUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBiddingBehaviorUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumUserBiddingActionFieldUpdateOperationsInput | $Enums.UserBiddingAction
    actionData?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: NullableStringFieldUpdateOperationsInput | string | null
    agentName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundCreateManyPaymentInput = {
    id?: string
    outRefundNo: string
    refundAmount: number
    reason: string
    status?: string
    providerRefundId?: string | null
    operatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    refundedAt?: Date | string | null
  }

  export type RefundUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    outRefundNo?: StringFieldUpdateOperationsInput | string
    refundAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    providerRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    operatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BiddingSessionCreateManyDiscussionInput = {
    id?: string
    ideaId: string
    userId?: string | null
    startPrice?: number
    currentHigh?: number
    winnerAgent?: string | null
    winnerAgentType?: string | null
    finalPrice?: number | null
    status?: $Enums.BiddingStatus
    phase?: $Enums.BiddingPhase
    enhancedByDiscussion?: boolean
    enhancementScore?: number
    participantCount?: number
    viewerCount?: number
    maxViewerCount?: number
    totalInteractions?: number
    durationSeconds?: number
    discussionDuration?: number
    biddingDuration?: number
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    discussionStartedAt?: Date | string | null
    biddingStartedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    avgResponseTime?: number
    aiServiceCost?: number
    userEngagementScore?: number
    contentQualityScore?: number
  }

  export type DiscussionMessageCreateManyDiscussionInput = {
    id?: string
    content: string
    messageType: $Enums.MessageType
    roundNumber: number
    senderType: $Enums.SenderType
    senderName?: string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BiddingSessionUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    idea?: IdeaUpdateOneRequiredWithoutBiddingSessionsNestedInput
    user?: UserUpdateOneWithoutBiddingSessionsNestedInput
    bids?: BidUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
    bids?: BidUncheckedUpdateManyWithoutSessionNestedInput
    priceGuesses?: PriceGuessUncheckedUpdateManyWithoutSessionNestedInput
    interactions?: AIInteractionUncheckedUpdateManyWithoutSessionNestedInput
    behaviors?: UserBiddingBehaviorUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type BiddingSessionUncheckedUpdateManyWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ideaId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startPrice?: IntFieldUpdateOperationsInput | number
    currentHigh?: IntFieldUpdateOperationsInput | number
    winnerAgent?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAgentType?: NullableStringFieldUpdateOperationsInput | string | null
    finalPrice?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBiddingStatusFieldUpdateOperationsInput | $Enums.BiddingStatus
    phase?: EnumBiddingPhaseFieldUpdateOperationsInput | $Enums.BiddingPhase
    enhancedByDiscussion?: BoolFieldUpdateOperationsInput | boolean
    enhancementScore?: FloatFieldUpdateOperationsInput | number
    participantCount?: IntFieldUpdateOperationsInput | number
    viewerCount?: IntFieldUpdateOperationsInput | number
    maxViewerCount?: IntFieldUpdateOperationsInput | number
    totalInteractions?: IntFieldUpdateOperationsInput | number
    durationSeconds?: IntFieldUpdateOperationsInput | number
    discussionDuration?: IntFieldUpdateOperationsInput | number
    biddingDuration?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    discussionStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    biddingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    aiServiceCost?: FloatFieldUpdateOperationsInput | number
    userEngagementScore?: FloatFieldUpdateOperationsInput | number
    contentQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type DiscussionMessageUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionMessageUncheckedUpdateManyWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    roundNumber?: IntFieldUpdateOperationsInput | number
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    senderName?: NullableStringFieldUpdateOperationsInput | string | null
    analysisData?: NullableJsonNullValueInput | InputJsonValue
    suggestions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}