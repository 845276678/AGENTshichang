# 用户参与式讨论系统 - 技术实现方案优化

## 1. 系统架构优化

### 1.1 微服务架构设计

```mermaid
graph TB
    subgraph "前端层"
        A[Web应用 - React/Next.js]
        B[移动应用 - React Native]
        C[PWA - 渐进式Web应用]
    end
    
    subgraph "API网关层"
        D[API Gateway - Kong/Nginx]
        E[WebSocket Gateway]
        F[负载均衡器]
    end
    
    subgraph "业务服务层"
        G[用户服务]
        H[讨论服务]
        I[Agent服务]
        J[AI服务]
        K[通知服务]
        L[分析服务]
    end
    
    subgraph "数据层"
        M[PostgreSQL - 主数据库]
        N[Redis - 缓存&会话]
        O[MongoDB - 日志&分析]
        P[ElasticSearch - 搜索]
    end
    
    subgraph "AI/ML层"
        Q[OpenAI/Claude API]
        R[本地LLM服务]
        S[语音识别服务]
        T[情感分析服务]
    end
    
    A --> D
    B --> D
    C --> D
    D --> G
    D --> H
    E --> H
    H --> I
    I --> J
    J --> Q
    J --> R
    G --> M
    H --> M
    H --> N
    L --> O
    H --> P
```

### 1.2 实时通信架构

```javascript
class RealTimeCommunicationService {
    constructor() {
        this.websocketServer = new WebSocketServer();
        this.redisAdapter = new RedisAdapter(); // 集群支持
        this.eventBus = new EventBus();
        this.messageQueue = new MessageQueue(); // 消息队列
    }
    
    // 房间管理
    roomManager = {
        // 创建讨论房间
        createDiscussionRoom(ideaId, participants) {
            const roomId = `discussion_${ideaId}`;
            const room = {
                id: roomId,
                ideaId,
                participants: new Set(participants),
                agents: new Set(['wang', 'lin', 'alex', 'allen', 'li']),
                state: {
                    phase: 'waiting',
                    startTime: null,
                    currentSpeaker: null,
                    userSpeakingSlots: this.initializeSpeakingSlots()
                },
                messageHistory: [],
                analyticsData: {
                    participationMetrics: {},
                    engagementScores: {},
                    impactMeasurements: {}
                }
            };
            
            this.rooms.set(roomId, room);
            return room;
        },
        
        // 管理用户连接
        handleUserConnection(socket, userId, roomId) {
            const room = this.rooms.get(roomId);
            if (!room) return false;
            
            socket.join(roomId);
            room.participants.add(userId);
            
            // 发送房间状态
            socket.emit('room_state', {
                room: room.state,
                participants: Array.from(room.participants),
                messageHistory: room.messageHistory.slice(-50) // 最近50条消息
            });
            
            // 通知其他参与者
            socket.to(roomId).emit('user_joined', { userId });
            
            return true;
        }
    };
    
    // 消息处理
    messageHandler = {
        // 用户发言处理
        async handleUserSpeech(roomId, userId, speechData) {
            const room = this.rooms.get(roomId);
            if (!room) return;
            
            // 验证发言权限
            const canSpeak = this.validateSpeakingPermission(room, userId);
            if (!canSpeak.allowed) {
                return { success: false, reason: canSpeak.reason };
            }
            
            // 处理语音转文字（如果需要）
            let processedContent = speechData.content;
            if (speechData.type === 'voice') {
                processedContent = await this.speechToTextService.convert(speechData.audioData);
            }
            
            // 内容过滤和增强
            const filteredContent = await this.contentFilter.process(processedContent);
            const enhancedContent = await this.contentEnhancer.enhance(filteredContent, room.state);
            
            // 创建消息对象
            const message = {
                id: `msg_${Date.now()}_${userId}`,
                type: 'user_speech',
                userId,
                content: enhancedContent,
                timestamp: new Date().toISOString(),
                metadata: {
                    originalContent: processedContent,
                    speechSlot: canSpeak.slotUsed,
                    processingTime: Date.now() - speechData.timestamp
                }
            };
            
            // 保存消息
            room.messageHistory.push(message);
            
            // 广播消息
            this.websocketServer.to(roomId).emit('new_message', message);
            
            // 触发Agent反应
            this.triggerAgentReactions(roomId, message);
            
            // 更新发言权限
            this.updateSpeakingSlots(room, userId, canSpeak.slotUsed);
            
            // 记录分析数据
            this.recordUserEngagement(room, userId, message);
            
            return { success: true, messageId: message.id };
        },
        
        // Agent响应处理
        async handleAgentResponse(roomId, agentId, responseData) {
            const room = this.rooms.get(roomId);
            if (!room) return;
            
            const message = {
                id: `msg_${Date.now()}_${agentId}`,
                type: 'agent_response',
                agentId,
                content: responseData.content,
                timestamp: new Date().toISOString(),
                metadata: {
                    responseType: responseData.type, // 'reaction', 'analysis', 'bid'
                    confidence: responseData.confidence,
                    processingTime: responseData.processingTime,
                    relatedMessageId: responseData.relatedMessageId
                }
            };
            
            room.messageHistory.push(message);
            this.websocketServer.to(roomId).emit('new_message', message);
            
            // 如果是出价消息，更新竞价状态
            if (responseData.type === 'bid') {
                this.updateBiddingState(room, agentId, responseData.bidAmount);
            }
            
            return { success: true, messageId: message.id };
        }
    };
}
```

## 2. AI服务优化

### 2.1 智能负载分配

```javascript
class AIServiceOptimizer {
    constructor() {
        this.modelProviders = {
            primary: new OpenAIProvider(),
            secondary: new ClaudeProvider(),
            fallback: new DeepSeekProvider(),
            local: new LocalLLMProvider()
        };
        this.loadBalancer = new AILoadBalancer();
        this.costOptimizer = new CostOptimizer();
    }
    
    // 智能模型选择
    async selectOptimalModel(taskType, complexity, budget, urgency) {
        const modelOptions = [
            {
                provider: 'primary',
                model: 'gpt-4-turbo',
                cost: 0.03,
                latency: 2000,
                quality: 0.95,
                suitability: this.calculateSuitability(taskType, 'gpt-4-turbo')
            },
            {
                provider: 'secondary', 
                model: 'claude-3-opus',
                cost: 0.025,
                latency: 1800,
                quality: 0.93,
                suitability: this.calculateSuitability(taskType, 'claude-3-opus')
            },
            {
                provider: 'fallback',
                model: 'deepseek-chat',
                cost: 0.001,
                latency: 1200,
                quality: 0.85,
                suitability: this.calculateSuitability(taskType, 'deepseek-chat')
            }
        ];
        
        // 多维度评分
        const scores = modelOptions.map(option => {
            const costScore = this.calculateCostScore(option.cost, budget);
            const latencyScore = this.calculateLatencyScore(option.latency, urgency);
            const qualityScore = option.quality;
            const suitabilityScore = option.suitability;
            
            return {
                ...option,
                totalScore: (costScore * 0.2) + (latencyScore * 0.3) + 
                           (qualityScore * 0.3) + (suitabilityScore * 0.2)
            };
        });
        
        // 选择最优模型
        const selectedModel = scores.reduce((best, current) => 
            current.totalScore > best.totalScore ? current : best
        );
        
        return selectedModel;
    }
    
    // 批量请求优化
    async optimizeBatchRequests(requests) {
        // 按模型类型分组
        const groupedRequests = this.groupRequestsByModel(requests);
        
        // 并行处理不同模型的请求
        const promises = Object.entries(groupedRequests).map(async ([modelKey, modelRequests]) => {
            const provider = this.modelProviders[modelKey];
            
            // 对于同一模型，进行批量优化
            if (modelRequests.length > 1 && provider.supportsBatch) {
                return provider.batchProcess(modelRequests);
            } else {
                // 并发处理单个请求
                return Promise.all(
                    modelRequests.map(request => provider.process(request))
                );
            }
        });
        
        const results = await Promise.all(promises);
        return this.mergeResults(results);
    }
    
    // 成本控制
    costController = {
        dailyBudget: 100, // 美元
        currentSpend: 0,
        
        async checkBudget(estimatedCost) {
            if (this.currentSpend + estimatedCost > this.dailyBudget) {
                // 切换到低成本模型
                return {
                    allowed: false,
                    suggestion: 'switch_to_budget_model',
                    alternativeModel: 'deepseek-chat'
                };
            }
            return { allowed: true };
        },
        
        recordSpend(cost, modelUsed, taskType) {
            this.currentSpend += cost;
            
            // 记录详细的成本分析
            this.costAnalytics.record({
                timestamp: Date.now(),
                cost,
                modelUsed,
                taskType,
                remainingBudget: this.dailyBudget - this.currentSpend
            });
        }
    };
}
```

### 2.2 Agent响应生成优化

```javascript
class AgentResponseGenerator {
    constructor() {
        this.agentPersonalities = {
            wang: new WangPersonality(),
            lin: new LinPersonality(),
            alex: new AlexPersonality(),
            allen: new AllenPersonality(),
            li: new LiPersonality()
        };
        this.contextManager = new ContextManager();
        this.responseCache = new ResponseCache();
    }
    
    // 并行Agent响应生成
    async generateParallelResponses(userMessage, discussionContext, activeAgents) {
        const promises = activeAgents.map(async (agentId) => {
            const personality = this.agentPersonalities[agentId];
            
            // 检查缓存
            const cacheKey = this.generateCacheKey(userMessage, discussionContext, agentId);
            const cachedResponse = await this.responseCache.get(cacheKey);
            if (cachedResponse) {
                return { agentId, response: cachedResponse, fromCache: true };
            }
            
            try {
                // 生成个性化响应
                const response = await personality.generateResponse({
                    userMessage,
                    discussionContext,
                    currentState: discussionContext.agentStates[agentId]
                });
                
                // 缓存响应
                await this.responseCache.set(cacheKey, response, '5min');
                
                return { agentId, response, fromCache: false };
            } catch (error) {
                console.error(`Error generating response for ${agentId}:`, error);
                
                // 降级处理
                const fallbackResponse = personality.getFallbackResponse(userMessage);
                return { agentId, response: fallbackResponse, fromCache: false, fallback: true };
            }
        });
        
        // 等待所有响应完成，但有超时保护
        const responses = await Promise.allSettled(promises);
        
        return responses.map(result => {
            if (result.status === 'fulfilled') {
                return result.value;
            } else {
                // 处理失败的情况
                return {
                    agentId: 'unknown',
                    response: { error: result.reason },
                    failed: true
                };
            }
        });
    }
    
    // 响应质量控制
    responseQualityController = {
        // 验证响应质量
        async validateResponse(agentId, response, context) {
            const checks = {
                // 长度检查
                lengthCheck: this.checkResponseLength(response),
                
                // 个性一致性检查
                personalityCheck: this.checkPersonalityConsistency(agentId, response),
                
                // 内容相关性检查
                relevanceCheck: this.checkContentRelevance(response, context),
                
                // 情感一致性检查
                emotionCheck: this.checkEmotionalConsistency(agentId, response, context),
                
                // 重复性检查
                duplicateCheck: this.checkForDuplicates(response, context.messageHistory)
            };
            
            const overallScore = Object.values(checks).reduce((sum, check) => sum + check.score, 0) / Object.keys(checks).length;
            
            return {
                passed: overallScore >= 0.7,
                score: overallScore,
                checks,
                suggestions: this.generateImprovementSuggestions(checks)
            };
        },
        
        // 响应优化
        async optimizeResponse(agentId, response, qualityReport) {
            if (qualityReport.passed) return response;
            
            const optimizations = [];
            
            // 基于质量报告应用优化
            for (const [checkName, checkResult] of Object.entries(qualityReport.checks)) {
                if (checkResult.score < 0.7) {
                    const optimization = await this.applyOptimization(agentId, response, checkName, checkResult);
                    optimizations.push(optimization);
                }
            }
            
            // 合并优化结果
            return this.mergeOptimizations(response, optimizations);
        }
    };
}
```

## 3. 数据处理优化

### 3.1 实时数据流处理

```javascript
class RealTimeDataProcessor {
    constructor() {
        this.eventStream = new EventStream();
        this.dataBuffer = new CircularBuffer(1000); // 循环缓冲区
        this.analytics = new RealTimeAnalytics();
        this.persistenceLayer = new DataPersistence();
    }
    
    // 流式数据处理
    streamProcessor = {
        // 处理用户交互事件
        processUserInteraction(event) {
            // 立即分析
            const immediateAnalysis = this.analyzeInteractionImmediate(event);
            
            // 添加到缓冲区
            this.dataBuffer.add({
                ...event,
                analysis: immediateAnalysis,
                timestamp: Date.now()
            });
            
            // 触发实时更新
            this.eventStream.emit('user_interaction', {
                event,
                analysis: immediateAnalysis
            });
            
            // 异步深度分析
            this.scheduleDeepAnalysis(event);
        },
        
        // 批量处理缓冲区数据
        async processBatchedData() {
            const batchData = this.dataBuffer.flush();
            if (batchData.length === 0) return;
            
            // 聚合分析
            const aggregatedAnalysis = this.performAggregatedAnalysis(batchData);
            
            // 更新实时指标
            this.analytics.updateMetrics(aggregatedAnalysis);
            
            // 持久化重要数据
            await this.persistenceLayer.saveBatch(batchData, aggregatedAnalysis);
            
            // 触发批量分析事件
            this.eventStream.emit('batch_analysis_complete', aggregatedAnalysis);
        }
    };
    
    // 性能监控
    performanceMonitor = {
        metrics: {
            messageProcessingTime: [],
            agentResponseTime: [],
            userEngagementScore: [],
            systemLoad: []
        },
        
        recordMetric(type, value) {
            if (!this.metrics[type]) this.metrics[type] = [];
            
            this.metrics[type].push({
                value,
                timestamp: Date.now()
            });
            
            // 保持最近1000个数据点
            if (this.metrics[type].length > 1000) {
                this.metrics[type].shift();
            }
            
            // 检查性能阈值
            this.checkPerformanceThresholds(type, value);
        },
        
        checkPerformanceThresholds(type, value) {
            const thresholds = {
                messageProcessingTime: 500, // 500ms
                agentResponseTime: 3000,    // 3s
                userEngagementScore: 0.3,   // 30%
                systemLoad: 0.8             // 80%
            };
            
            if (value > thresholds[type]) {
                this.eventStream.emit('performance_alert', {
                    type,
                    value,
                    threshold: thresholds[type],
                    severity: this.calculateSeverity(value, thresholds[type])
                });
            }
        }
    };
}
```

### 3.2 缓存策略优化

```javascript
class CacheOptimizer {
    constructor() {
        this.redisClient = new Redis();
        this.memoryCache = new MemoryCache();
        this.cacheHierarchy = new CacheHierarchy();
    }
    
    // 多层缓存策略
    multiLayerCache = {
        // L1: 内存缓存 (最快访问)
        l1Cache: {
            maxSize: '100MB',
            ttl: '30s',
            strategy: 'LRU',
            items: [
                'current_discussion_state',
                'active_user_sessions',
                'agent_response_templates'
            ]
        },
        
        // L2: Redis缓存 (中等速度)
        l2Cache: {
            ttl: '5min',
            items: [
                'user_profiles',
                'discussion_history',
                'agent_personalities',
                'computed_analytics'
            ]
        },
        
        // L3: 数据库缓存 (持久化)
        l3Cache: {
            ttl: '1hour',
            items: [
                'historical_discussions',
                'user_behavior_patterns',
                'long_term_analytics'
            ]
        },
        
        // 智能缓存选择
        async get(key, category) {
            // 尝试L1缓存
            let result = await this.memoryCache.get(key);
            if (result) return { data: result, source: 'L1' };
            
            // 尝试L2缓存
            result = await this.redisClient.get(key);
            if (result) {
                // 回填L1缓存
                await this.memoryCache.set(key, result, this.l1Cache.ttl);
                return { data: result, source: 'L2' };
            }
            
            // 尝试L3缓存（数据库）
            result = await this.databaseCache.get(key);
            if (result) {
                // 回填上层缓存
                await this.redisClient.set(key, result, this.l2Cache.ttl);
                await this.memoryCache.set(key, result, this.l1Cache.ttl);
                return { data: result, source: 'L3' };
            }
            
            return null;
        }
    };
    
    // 智能预加载
    intelligentPreloader = {
        // 预测用户需求
        async predictUserNeeds(userId, currentContext) {
            const userPattern = await this.getUserBehaviorPattern(userId);
            const contextualNeeds = this.analyzeContextualNeeds(currentContext);
            
            const predictions = {
                likelyDiscussions: this.predictDiscussionTopics(userPattern, contextualNeeds),
                probableAgentInteractions: this.predictAgentInteractions(userPattern),
                nextUserActions: this.predictUserActions(userPattern, currentContext)
            };
            
            // 基于预测预加载数据
            await this.preloadBasedOnPredictions(predictions);
            
            return predictions;
        },
        
        // 预加载策略
        async preloadBasedOnPredictions(predictions) {
            const preloadTasks = [];
            
            // 预加载可能的讨论数据
            predictions.likelyDiscussions.forEach(topic => {
                preloadTasks.push(this.preloadDiscussionData(topic));
            });
            
            // 预加载Agent个性数据
            predictions.probableAgentInteractions.forEach(agentId => {
                preloadTasks.push(this.preloadAgentPersonality(agentId));
            });
            
            // 并行执行预加载
            await Promise.all(preloadTasks);
        }
    };
}
```

## 4. 安全性增强

### 4.1 内容安全

```javascript
class ContentSecurityManager {
    constructor() {
        this.toxicityDetector = new ToxicityDetector();
        this.spamFilter = new SpamFilter();
        this.privacyProtector = new PrivacyProtector();
        this.rateLimiter = new RateLimiter();
    }
    
    // 内容审核管道
    contentModerationPipeline = {
        async moderateContent(content, userId, context) {
            const results = {
                toxicity: await this.toxicityDetector.analyze(content),
                spam: await this.spamFilter.detect(content, userId),
                privacy: await this.privacyProtector.scanForPII(content),
                rateLimiting: await this.rateLimiter.checkLimits(userId),
                sentiment: await this.sentimentAnalyzer.analyze(content)
            };
            
            // 综合评估
            const overallRisk = this.calculateOverallRisk(results);
            const action = this.determineAction(overallRisk, results);
            
            return {
                approved: action.type === 'approve',
                action,
                results,
                overallRisk,
                suggestedModifications: action.type === 'modify' ? action.suggestions : null
            };
        },
        
        determineAction(riskLevel, results) {
            // 高风险内容直接拒绝
            if (riskLevel > 0.8) {
                return {
                    type: 'reject',
                    reason: 'high_risk_content',
                    details: this.getHighestRiskFactors(results)
                };
            }
            
            // 中等风险内容建议修改
            if (riskLevel > 0.5) {
                return {
                    type: 'modify',
                    reason: 'medium_risk_content',
                    suggestions: this.generateModificationSuggestions(results)
                };
            }
            
            // 低风险内容通过，但可能需要标记
            if (riskLevel > 0.2) {
                return {
                    type: 'approve_with_flag',
                    reason: 'low_risk_content',
                    flags: this.generateContentFlags(results)
                };
            }
            
            // 安全内容直接通过
            return {
                type: 'approve',
                reason: 'safe_content'
            };
        }
    };
    
    // 用户行为监控
    userBehaviorMonitor = {
        // 异常行为检测
        detectAnomalousBehavior(userId, action, context) {
            const userProfile = this.getUserBehaviorProfile(userId);
            const anomalyScore = this.calculateAnomalyScore(action, userProfile, context);
            
            if (anomalyScore > 0.8) {
                return {
                    isAnomalous: true,
                    severity: 'high',
                    recommendedAction: 'temporary_restriction',
                    reason: this.identifyAnomalyReason(action, userProfile)
                };
            }
            
            if (anomalyScore > 0.5) {
                return {
                    isAnomalous: true,
                    severity: 'medium',
                    recommendedAction: 'enhanced_monitoring',
                    reason: this.identifyAnomalyReason(action, userProfile)
                };
            }
            
            return { isAnomalous: false };
        },
        
        // 滥用检测
        detectAbuse(userId, recentActions) {
            const patterns = {
                spamming: this.detectSpammingPattern(recentActions),
                harassment: this.detectHarassmentPattern(recentActions),
                manipulation: this.detectManipulationPattern(recentActions),
                evasion: this.detectEvasionPattern(recentActions)
            };
            
            const abusivePatterns = Object.entries(patterns)
                .filter(([_, detected]) => detected.isDetected)
                .map(([type, details]) => ({ type, ...details }));
            
            return {
                hasAbuse: abusivePatterns.length > 0,
                patterns: abusivePatterns,
                riskLevel: this.calculateAbuseRiskLevel(abusivePatterns),
                recommendedActions: this.getRecommendedActions(abusivePatterns)
            };
        }
    };
}
```

### 4.2 数据隐私保护

```javascript
class PrivacyProtectionManager {
    constructor() {
        this.encryptionService = new EncryptionService();
        this.anonymizationService = new AnonymizationService();
        this.consentManager = new ConsentManager();
        this.dataRetentionManager = new DataRetentionManager();
    }
    
    // 数据保护策略
    dataProtectionStrategy = {
        // 敏感数据加密
        async encryptSensitiveData(data, dataType) {
            const encryptionLevel = this.determineEncryptionLevel(dataType);
            
            switch (encryptionLevel) {
                case 'high':
                    return this.encryptionService.encrypt(data, 'AES-256-GCM');
                case 'medium':
                    return this.encryptionService.encrypt(data, 'AES-128-CBC');
                case 'low':
                    return this.encryptionService.hash(data, 'SHA-256');
                default:
                    return data; // 无需加密
            }
        },
        
        // 数据匿名化
        async anonymizeUserData(userData, purpose) {
            const anonymizationLevel = this.determineAnonymizationLevel(purpose);
            
            return {
                userId: this.anonymizationService.anonymizeId(userData.userId, anonymizationLevel),
                demographicData: this.anonymizationService.anonymizeDemographics(userData.demographics),
                behaviorData: this.anonymizationService.anonymizeBehavior(userData.behavior, anonymizationLevel),
                interactionData: this.anonymizationService.anonymizeInteractions(userData.interactions)
            };
        },
        
        // 用户同意管理
        async manageUserConsent(userId, dataType, purpose) {
            const consentRecord = await this.consentManager.getConsent(userId, dataType, purpose);
            
            if (!consentRecord || this.isConsentExpired(consentRecord)) {
                const newConsent = await this.requestUserConsent(userId, dataType, purpose);
                if (newConsent.granted) {
                    await this.consentManager.recordConsent(userId, dataType, purpose, newConsent);
                    return { hasConsent: true, consentLevel: newConsent.level };
                } else {
                    return { hasConsent: false, reason: newConsent.reason };
                }
            }
            
            return { hasConsent: true, consentLevel: consentRecord.level };
        }
    };
    
    // 数据生命周期管理
    dataLifecycleManager = {
        // 自动数据清理
        async scheduleDataCleanup() {
            const retentionPolicies = {
                userInteractions: '90days',
                discussionHistory: '1year',
                analyticsData: '2years',
                logData: '30days'
            };
            
            for (const [dataType, retention] of Object.entries(retentionPolicies)) {
                await this.scheduleCleanupJob(dataType, retention);
            }
        },
        
        // 用户数据导出
        async exportUserData(userId, format = 'json') {
            const userData = await this.collectAllUserData(userId);
            const exportData = {
                profile: userData.profile,
                interactions: userData.interactions,
                preferences: userData.preferences,
                analyticsData: this.anonymizeForExport(userData.analytics)
            };
            
            switch (format) {
                case 'json':
                    return JSON.stringify(exportData, null, 2);
                case 'csv':
                    return this.convertToCSV(exportData);
                case 'xml':
                    return this.convertToXML(exportData);
                default:
                    throw new Error(`Unsupported export format: ${format}`);
            }
        },
        
        // 数据删除（被遗忘权）
        async deleteUserData(userId, deletionType = 'complete') {
            const deletionPlan = this.createDeletionPlan(userId, deletionType);
            
            for (const step of deletionPlan.steps) {
                await this.executeDeletionStep(step);
            }
            
            // 记录删除操作
            await this.recordDeletion(userId, deletionType, deletionPlan);
            
            return {
                success: true,
                deletedItems: deletionPlan.steps.length,
                retainedItems: deletionPlan.retainedItems || []
            };
        }
    };
}
```

## 5. 部署与监控

### 5.1 容器化部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 前端服务
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - API_BASE_URL=http://backend:8000
    depends_on:
      - backend

  # 后端API服务
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@postgres:5432/aiagentmarket
      - REDIS_URL=redis://redis:6379
      - AI_SERVICE_URL=http://ai-service:8001
    depends_on:
      - postgres
      - redis
      - ai-service

  # AI服务
  ai-service:
    build: ./ai-service
    ports:
      - "8001:8001"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - CLAUDE_API_KEY=${CLAUDE_API_KEY}
      - MODEL_CACHE_SIZE=1GB
    volumes:
      - ./models:/app/models
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]

  # WebSocket服务
  websocket-service:
    build: ./websocket-service
    ports:
      - "8002:8002"
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis

  # 数据库
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=aiagentmarket
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql

  # 缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # 监控
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  postgres_data:
  redis_data:
  grafana_data:
```

### 5.2 监控与告警

```javascript
class MonitoringService {
    constructor() {
        this.metricsCollector = new MetricsCollector();
        this.alertManager = new AlertManager();
        this.healthChecker = new HealthChecker();
        this.performanceAnalyzer = new PerformanceAnalyzer();
    }
    
    // 系统健康监控
    healthMonitoring = {
        // 健康检查端点
        async checkSystemHealth() {
            const checks = await Promise.allSettled([
                this.checkDatabaseHealth(),
                this.checkRedisHealth(),
                this.checkAIServiceHealth(),
                this.checkWebSocketHealth(),
                this.checkExternalAPIHealth()
            ]);
            
            const healthStatus = {
                overall: 'healthy',
                services: {},
                timestamp: new Date().toISOString(),
                uptime: process.uptime()
            };
            
            checks.forEach((check, index) => {
                const serviceName = ['database', 'redis', 'ai-service', 'websocket', 'external-api'][index];
                
                if (check.status === 'fulfilled') {
                    healthStatus.services[serviceName] = check.value;
                } else {
                    healthStatus.services[serviceName] = {
                        status: 'unhealthy',
                        error: check.reason.message
                    };
                    healthStatus.overall = 'degraded';
                }
            });
            
            // 如果有服务不健康，触发告警
            if (healthStatus.overall !== 'healthy') {
                await this.alertManager.triggerAlert('system_health', healthStatus);
            }
            
            return healthStatus;
        },
        
        // 性能指标收集
        async collectPerformanceMetrics() {
            return {
                // 系统指标
                system: {
                    cpuUsage: await this.getCPUUsage(),
                    memoryUsage: await this.getMemoryUsage(),
                    diskUsage: await this.getDiskUsage(),
                    networkIO: await this.getNetworkIO()
                },
                
                // 应用指标
                application: {
                    activeConnections: this.getActiveConnections(),
                    requestsPerSecond: this.getRequestsPerSecond(),
                    averageResponseTime: this.getAverageResponseTime(),
                    errorRate: this.getErrorRate()
                },
                
                // 业务指标
                business: {
                    activeDiscussions: await this.getActiveDiscussions(),
                    userEngagement: await this.getUserEngagement(),
                    aiServiceUsage: await this.getAIServiceUsage(),
                    costMetrics: await this.getCostMetrics()
                }
            };
        }
    };
    
    // 智能告警系统
    intelligentAlerting = {
        // 异常检测
        async detectAnomalies(metrics) {
            const anomalies = [];
            
            // 使用统计方法检测异常
            for (const [metricName, value] of Object.entries(metrics)) {
                const historicalData = await this.getHistoricalData(metricName, '24h');
                const anomalyScore = this.calculateAnomalyScore(value, historicalData);
                
                if (anomalyScore > 0.8) {
                    anomalies.push({
                        metric: metricName,
                        currentValue: value,
                        anomalyScore,
                        expectedRange: this.calculateExpectedRange(historicalData),
                        severity: this.calculateSeverity(anomalyScore)
                    });
                }
            }
            
            return anomalies;
        },
        
        // 预测性告警
        async generatePredictiveAlerts(metrics, timeHorizon = '1h') {
            const predictions = await this.generatePredictions(metrics, timeHorizon);
            const alerts = [];
            
            for (const prediction of predictions) {
                if (prediction.exceedsThreshold) {
                    alerts.push({
                        type: 'predictive',
                        metric: prediction.metric,
                        predictedValue: prediction.value,
                        timeToThreshold: prediction.timeToThreshold,
                        confidence: prediction.confidence,
                        recommendedAction: this.getRecommendedAction(prediction)
                    });
                }
            }
            
            return alerts;
        }
    };
}
```

## 6. 总结

这个优化的技术实现方案提供了：

### 核心技术优势
1. **高性能微服务架构** - 可扩展的服务分离
2. **智能AI服务优化** - 成本控制和负载均衡
3. **多层缓存策略** - 极致的响应速度
4. **全面安全保护** - 内容安全和隐私保护
5. **完善监控体系** - 实时监控和预测性告警

### 技术创新点
- 实时数据流处理和分析
- 智能模型选择和成本优化
- 多维度缓存预加载
- AI驱动的异常检测
- 预测性系统监控

### 可扩展性
- 支持水平扩展的微服务架构
- 容器化部署便于扩容
- 智能负载均衡
- 弹性资源管理

这个技术方案确保了用户参与式讨论系统能够稳定、高效、安全地运行，同时提供了优秀的用户体验和完整的运营监控能力。